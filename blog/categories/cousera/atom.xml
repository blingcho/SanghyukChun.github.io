<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cousera | README]]></title>
  <link href="http://SanghyukChun.github.io/blog/categories/cousera/atom.xml" rel="self"/>
  <link href="http://SanghyukChun.github.io/"/>
  <updated>2016-12-18T16:03:02+09:00</updated>
  <id>http://SanghyukChun.github.io/</id>
  <author>
    <name><![CDATA[Sanghyuk Chun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Game Theory Study (2) Mixed-Strategy Nash Equilibrium]]></title>
    <link href="http://SanghyukChun.github.io/102/"/>
    <updated>2016-08-29T00:40:00+09:00</updated>
    <id>http://SanghyukChun.github.io/102</id>
    <content type="html"><![CDATA[<h3 id="section">들어가며</h3>
<p>이 글은 Coursera의 <a href="https://www.coursera.org/learn/game-theory-1">Game Theory</a> course의 2주차 강의를 요약한 글이다.
첫 주에서 간단한 예제들을 통해 normal form game을 엄밀하게 정의하고, pure strategy 상황에서의 Nash equilibrium 등을 정의했다면,
이번 주에는 좀 더 일반화된 strategy인 mixed strategy에 대해 다루고, 해당 상황에서의 NE에 대해 다룬다.</p>

<h3 id="mixed-strategy">Mixed Strategy</h3>
<p>첫 주차 글에서 다룬 Matching Pennies 문제를 다시 살펴보자. 이 문제에서 한 가지 알 수 있는 사실은, deterministic한 strategy를 고르는 것은 적절한 strategy가 아니라는 사실이다.
즉, A가 Head를 고른다면, B는 반드시 Tail을 고르게 되고, … 이 과정이 cycle이 발생하여 NE가 성립하지 않는다는 사실은 이미 앞에서 살펴보았다.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>Head</th>
      <th>Tails</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Head</td>
      <td>1, -1</td>
      <td>-1, 1</td>
    </tr>
    <tr>
      <td>Tails</td>
      <td>-1, 1</td>
      <td>1, -1</td>
    </tr>
  </tbody>
</table>

<p>사실 이 상황에서 가장 적절한 전략은, random하게 play를 함으로써 상대방을 교란시키는 것이다. 즉, A가 Head/Tail을 50:50으로 고르게 된다면, B는 Head를 고르나 Tail을 고르나, expected payoff가 동일하기 때문에 전략을 세우기가 한 층 더 어려워진다. Mixed strategy를 간단하게 표현하면, <strong>deterministic한 pure strategy를 probabilistic하게 바꾼 것</strong> 정도로 이해할 수 있을 것 같다. 이제 조금 더 엄밀하게 정의해보자.</p>

<p>Strategy $s_i$는 action set $A_i$에 대한 probability distribution으로 정의할 수 있다. 이때, pure strategy와 mixed strategy는 각각 다음과 같이 정의할 수 있다.</p>

<ul>
  <li>Pure strategy: $s_i$는 반드시 하나의 action만 1의 확률로 고르고, 나머지는 0의 확률로 고른다.</li>
  <li>Mixed strategy: $s_i$의 distribution에서 하나보다 많은 positive value가 있다.</li>
</ul>

<p>여기에서, 모든 i에게 가능한 모든 strategy set을 $S_i$라 정의하고, 모든 i에 대한 strategy 들의 조합을 (cross product를) ‘all strategy profile’ $S$ 라고 정의하자.</p>

<p>여기에서 문제가 한 가지 생긴다. Pure strategy에서는 반드시 하나의 결과가 나오지만 mixed strategy에서는 여러 결과가 확률적으로 나오기 때문에 이전에 사용했었던 best response와 Nash equilibrium의 정의를 그대로 사용할 수 없게 된다. (참고로, pure strategy에서의 best response는 ‘action’에 대해 정의가 되고, NE 역시 action set에 대해서 정의가 된다.)</p>

<p>이 문제를 해결하기 위해서 먼저 다음과 같은 질문을 던져보자, Player들이 strategy $s$에 따라 게임을 했을 때, payoff를 어떻게 정의하는 것이 좋을까? 예를 들어서 위의 Matching Pennies 게임에서 A가 Head를 고르고, B가 Tail를 골랐다면, 이에 해당하는 payoff는 (1, -1)이기 때문에 utility는 그냥 payoff값을 사용하면 된다. 그렇다면 A와 B가 각각 Head를 50%, Tail을 50% 확률로 선택하는 상황이라면 payoff는 어떻게 정의해야할까? 확률적으로 payoff가 정해지기 때문에 주어진 mixed strategy에 대해 정확한 payoff 값을 정하는 것은 불가능하다. 대신 간단한 대안으로 payoff의 expectation으로 utility function을 정의할 수 있다.</p>

<p>이제 앞에서 정의한 strategy, strategy set, 그리고 utility function을 사용하면, pure strategy에서 했던 것과 거의 비슷한 방법으로 best response와 Nash equilibrium을 정의하는 것이 가능하다.</p>

<script type="math/tex; mode=display"> s_i^* \in \mbox{BR}(s_{-i}) ~\mbox{iff}~ \forall s_i \in S_i, u(s_i^*, s_{-i}) \geq u_i(s_i, s_{-i}).</script>

<script type="math/tex; mode=display">s = (s_1, \ldots, s_n) ~\mbox{is a Nash Equilibrium iff}~ \forall i, s_i \in BR(s_{-i}).</script>

<p>간단하게 생각하면 deterministic한 개념이었던 action a와 utility function만 변하고 나머지는 동일하다. 이것으로 끝이 아니라, 이렇게 Nash equilibrium을 정의하게 되면 다음과 같은 엄청난 theorem이 나오게 된다.</p>

<blockquote>
  <p>Theorem (Nash, 1950). Every finite game has a Nash equilibrium.</p>
</blockquote>

<p>분명 첫 주 글에서는 ‘pure strategy’ Nash equilibrium은 항상 존재하는건 아니다라고 했는데, mixed strategy 개념으로 NE를 정의하는 순간, 모든 finite game에서 NE가 있다는 것을 보장할 수 있는 것이다. 예를 들어 Matching Pennies는 (당연하게도) 둘 다 50%의 확률로 head/tail을 고르는 것이 NE가 된다.</p>

<h3 id="computing-mixed-nash-equilibrium">Computing Mixed Nash Equilibrium</h3>
<p>이제 NE를 정의했으니, 실제 NE를 어떻게 찾아낼 수 있는지 예제를 통해서 알아보자. Battles of Sexes 문제를 다시 살펴보자.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>B</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>B</td>
      <td>2, 1</td>
      <td>0, 0</td>
    </tr>
    <tr>
      <td>F</td>
      <td>0, 0</td>
      <td>1, 2</td>
    </tr>
  </tbody>
</table>

<p>정의에 따라, NE는 서로의 utility function을 maximize해야만 한다. 만약 player 2가 B를 p의 확률로, F를 1-p의 확률로 play한다고 가정해보자. 이 경우 player 2의 utility는 다음과 같이 계산할 수 있다.</p>

<script type="math/tex; mode=display">  </script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Game Theory Study (1) Introduction and Overview]]></title>
    <link href="http://SanghyukChun.github.io/101/"/>
    <updated>2016-08-21T23:47:00+09:00</updated>
    <id>http://SanghyukChun.github.io/101</id>
    <content type="html"><![CDATA[<h3 id="section">들어가며</h3>
<p>최근 Coursera의 <a href="https://www.coursera.org/learn/game-theory-1">Game Theory</a> Course를 수강 중이다. 꽤 만족도가 높아서, <a href="https://www.coursera.org/learn/game-theory-2">Game Theory 2: Advanced Application</a> course까지 이어서 수강할 계획을 세우고 있다. 두 번째 course가 9월 12일부터 시작하기 때문에 첫 번째 course를 9월 첫주까지 끝낼 생각으로 수강 중이다. 아무래도 공부를 하고 나서 블로그에 정리 글을 올리지 않으면 공부를 끝마친 기분이 들지 않아서, 이번 course도 블로그에 계속 요약글을 올릴까한다.
Geoffrey Hinton 교수가 2012년 Coursera에서 강의 한 <a href="https://class.coursera.org/neuralnets-2012-001/lecture">Neural Networks for Machine Learning</a> 이후로 Coursera에 처음 들어가봤는데, 예전이랑 많이 바뀐 것 같다. 진짜 MOOC에 집중해서 ‘수강’이라는 개념을 좀 더 강화한듯. 예전에 조금 보다 말았던 Probabilistic Graphical Model이나 위에 링크한 Neural Network course도 전부 예전 자료에 access가 되지 않는다. 음.. 다시 듣고 싶었는데 또 enrollment하라고 해서 둘 다 일단 enroll해둔 상태. 이래저래 Coursera는 내 취향에 안맞는다.</p>

<p>다시 본문으로 돌아와서, 이 글은 Coursera의 <a href="https://www.coursera.org/learn/game-theory-1">Game Theory</a> course의 첫 주차 강의를 요약한 글이다.
대부분의 course의 첫 주가 그러하듯, 이 lecture 역시 Game Theory에 대한 introduction과 몇 가지 기본적인 definition에 대해 설명한다.</p>

<h3 id="what-is-game">What is “Game”?</h3>
<p>제목이 ‘Game Theory’ 인 만큼, game이 무엇인지부터 정의하고 넘어갈 필요가 있다. 우리가 게임이라고 부르는 것들에는 무엇이 포함될까?
먼저 대표적인 게임인 가위바위보를 생각해보자. 이 게임을 구성하기 위해서는 먼저 <strong>두 명의 player</strong>가 있으야 하며, 각 player들이 할 수 있는 <strong>action (가위, 바위, 보)</strong>가 있어야하며, 마지막으로 게임이 끝날 때 마다 정해지는 <strong>payoff (승/패)</strong>가 있어야한다.</p>

<p>Game을 나타내는 standard한 방법으로는 크게 두 가지가 있다. 하나는 Normal form (a.k.a. Matrix form, strategic form)이고, 또 하나는 Extensive form이다.
Normal form은 player들의 action에 따른 각각의 player들의 payoff를 표현한 방법으로, player가 두 명이라면 2차원 matrix로 표현이 가능하기 때문에 matrix form이라고도 부른다. Normal form은 player들이 지금 당장 action을 취했을 때 나타나는 payoff를 나타내는데, 예를 들어 체스같은 게임은 sequential한 movement를 포함하기 때문에 normal form으로 나타내기 쉽지 않다. (처음부터 게임이 끝날 때 까지 모든 가능한 경우의 수를 action으로 나타내면 가능할 수도 있지만 space가 너무 넓기 때문에 사실상 표현이 불가능하다.)
Extensive form은 그런 sequential한 movement를 포함하는 form으로, tree형태로 표현이 된다고 한다. 보다 자세한 얘기는 course의 뒷 부분에서 다룬다고 하니, 여기에서는 우선 넘어가자.</p>

<h3 id="definition-of-game-the-normal-form">Definition of Game: The Normal Form</h3>
<p>이제 game을 normal form을 정의해보자. Finite, n-person normal form game: &lt;N, A, u&gt;는 다음과 같이 정의된다.</p>

<ul>
  <li>Players: $N = {1, \ldots, n}$ is a finite set of n, indexes by i</li>
  <li>Action set for player i $A_i$
    <ul>
      <li>
        <p>$a = (a_1, \ldots, a_n) \in A$, where $A = A_1 \times \ldots  \times A_n$ 을 action profile이라 부른다.</p>
      </li>
    </ul>
  </li>
  <li>Utility function or Payoff function for player i: $u_i: A \to \mathbb R$
    <ul>
      <li>$u = (u_1, \ldots, u_n)$을 utility function의 profile이라 부른다.</li>
    </ul>
  </li>
</ul>

<p>이제 두 명이 진행하는 가위바위보를 normal form, 정확히는 matrix 형태로 적어보자.</p>

<ul>
  <li>Player는 1과 2 두 명이 존재한다.</li>
  <li>
    <p>Row는 player 1의 action $a_1 \in A_1$에 대응하고, column은 player 2의 action $a_2 \in A_2$에 대응한다.</p>
  </li>
  <li>Matrix의 각각의 cell은 각 player들의 payoff value에 해당한다. (a, b)라고 표현되며, 여기에서 a는 1번의 payoff, b는 2번의 payoff이다.</li>
</ul>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>Rock</th>
      <th>Paper</th>
      <th>Scissors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Rock</td>
      <td>0, 0</td>
      <td>-1, 1</td>
      <td>1, -1</td>
    </tr>
    <tr>
      <td>Paper</td>
      <td>1, -1</td>
      <td>0, 0</td>
      <td>-1, 1</td>
    </tr>
    <tr>
      <td>Scissors</td>
      <td>-1, 1</td>
      <td>1, -1</td>
      <td>0, 0</td>
    </tr>
  </tbody>
</table>

<p>비슷한 방식으로 훨씬 더 큰 게임도 기술할 수 있다.</p>

<h3 id="examples">Examples</h3>

<h4 id="matching-pennies">Matching Pennies</h4>
<p>두 player가 동전의 면을 고르는데, 한 명은 둘이 같은 선택을 해야, 한 명은 둘이 다른 선택을 해야 이기는 게임</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>Head</th>
      <th>Tails</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Head</td>
      <td>1, -1</td>
      <td>-1, 1</td>
    </tr>
    <tr>
      <td>Tails</td>
      <td>-1, 1</td>
      <td>1, -1</td>
    </tr>
  </tbody>
</table>

<h4 id="rock-paper-scissors">Rock-Paper-Scissors</h4>
<p>우리가 아는 바로 그 가위바위보는 아래와 같이 쓸 수 있다. (위에서 이미 언급했었다)</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>Rock</th>
      <th>Paper</th>
      <th>Scissors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Rock</td>
      <td>0, 0</td>
      <td>-1, 1</td>
      <td>1, -1</td>
    </tr>
    <tr>
      <td>Paper</td>
      <td>1, -1</td>
      <td>0, 0</td>
      <td>-1, 1</td>
    </tr>
    <tr>
      <td>Scissors</td>
      <td>-1, 1</td>
      <td>1, -1</td>
      <td>0, 0</td>
    </tr>
  </tbody>
</table>

<p>Matching Pennies와 Rock-Paper-Scissors는 서로 정확히 반대의 payoff를 가지는 게임인데, 이런 게임을 ‘games of pure competition’이라고 부른다.</p>

<h4 id="prisoners-dilemma">Prisoner’s Dilemma</h4>
<p>그 유명한 죄수의 딜레마<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>도 아래와 같이 표현할 수 있다.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C</td>
      <td>a, a</td>
      <td>b, c</td>
    </tr>
    <tr>
      <td>D</td>
      <td>c, b</td>
      <td>d, d</td>
    </tr>
  </tbody>
</table>

<p>이때 c &gt; a &gt; d &gt; b 라는 관계가 성립하면 ‘죄수의 딜레마’가 발생한다.</p>

<h4 id="battle-of-the-sexes">Battle of the Sexes</h4>
<p>어느 커플이 영화관에 영화를 보러갔는데, 남자와 여자가 선호하는 영화가 조금씩 달랐다고 가정해보자.
남자는 어벤져스를 (액션을) 더 좋아하고, 여자는 러브 엑츄얼리를 (로맨틱 코미디를) 더 좋아한다고 생각해보자. 하지만 둘 다 서로 떨어져서 영화를 보는건 원하지 않는다.
즉, 둘 다 같은 영화를 봐야지만 payoff가 발생하는데, 이렇게 둘 다 같은 interest를 가진 게임을 cooperation game이라고 한다.
그런데 지금처럼 각자 서로 조금씩 interest가 달라서 경쟁하는 경우에는 cooperation과 competition의 특징을 둘 다 가지게 된다.
Normal form으로는 아래와 같이 표현할 수 있다.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>B</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>B</td>
      <td>2, 1</td>
      <td>0, 0</td>
    </tr>
    <tr>
      <td>F</td>
      <td>0, 0</td>
      <td>1, 2</td>
    </tr>
  </tbody>
</table>

<h3 id="best-response-and-nash-equilibrium">Best Response and Nash Equilibrium</h3>
<p>이제 게임이 무엇인지 정의하였으니 Game Theory의 핵심이라 할 수 있는 Nash Equilibrium에 대해 알아보자.
Nash Equilibrium (NE)를 한 마디로 정의하자면, 게임에 참여하는 모든 agent들이 현재 선택한 action이 선택할 수 있는 모든 action들보다 더 좋거나 같은 상황이 유지되는 상황이다. 죄수의 딜레마를 예로 들어보자. 위의 게임에서 둘 다 (D, D)를 고르는 경우, 죄수 1은 협조하는 것이 협조하지 않는 것 보다 좋고, 죄수 2역시 마찬가지이므로 둘 다 협조하는 것이 NE에 해당한다. 이를 좀 더 정확한 formula로 정의해보자.</p>

<p>먼저 Best response $a_i^*$를 다음과 같이 정의하자</p>

<script type="math/tex; mode=display"> a_i^* \in \mbox{BR}(a_{-i}) ~\mbox{iff}~ \forall a_i \in A_i, u(a_i^*, a_{-i}) \geq u_i(a_i, a_{-i}), ~\mbox{where}~ a_{-i} = (a_1, \ldots, a_{i-1}, a_{i+1}, \ldots, a_n)</script>

<p>즉, best response란 나를 제외한 모든 player들이 어떻게 행동하는지 알고 있을 때 내가 선택할 수 있는 가장 optimal한 action이 best response(BR)이다. 이때 유의할 점은, BR은 하나만 존재하는 것이 아니라 동시에 여러 개 존재할 수도 있기 때문에 위의 정의에서 $a_i^*$가 set $\mbox{BR}(a_{-i})$에 포함되게 되는 것이다.</p>

<p>이제 BR을 정의했으니 NE를 정의할 차례이다. 앞에서 설명한대로 NE는 모든 agent들이 stable한 action을 가지는 상태를 말하며, 모든 player들이 optimal하다면 항상 BR을 고를 것이다. 즉, NE는 모든 player들이 BR을 선택했을 경우가 NE로 정의되게 된다. 보다 엄밀한 Nash Equilibrium의 정의는 다음과 같다.</p>

<script type="math/tex; mode=display">a = (a_1, \ldots, a_n) ~\mbox{is a "pure strategy" Nash Equilibrium iff}~ \forall i, a_i \in BR(a_{-i}).</script>

<p>이제 실제 예시들에서 (pure strategy) Nash Equilibrium을 찾아보자. 먼저 죄수의 딜레마는 앞에서 설명한 것 처럼, 어떤 상황에서도 둘 다 협조를 하는 것이 더 나은 선택이므로, 둘 다 협조하는 쪽이 NE가 된다. Battle of the Sexes에서는 남자가 액션영화를 골랐을 때, 여자가 로코를 고르면 payoff가 0이므로 반드시 액션을 고르게 된다. 반대로 남자가 로코를 골랐다면 여자는 반드시 로코를 고르게 된다. 남자에게도 같은 방식이 적용되므로, 이 게임의 NE는 둘 다 같은 영화를 고르는 두 점이 된다.</p>

<p>마지막으로 Matching Pennies를 살펴보자. 시작하기 전에 Pure strategy NE는 서로 상대가 고른 전략을 정확하게 알고 있다고 가정한다는 점에 유의하자.
만약 player 2가 head를 골랐다면 player 1은 head를 고르는 것이 optimal solution이다. (1은 서로 같은 면을 골라야, 2는 서로 다른 면을 골라야 이긴다) 그런데 이렇게 되면 player 2가 player 1이 head를 골랐다는 것을 알기 때문에 player 2는 tail을 고르는 것이 optimum이다. 다시 player 1은 tail을 고르게 되고, player 2는 head를 고르게 된다. 이제 player 1은 다시 head를 고르게 되는데, 이 결과는 우리가 가장 먼저 살펴봤던 결과와 같다. 즉, Matching Pennies는 cycle이 생기기 때문에 pure strategy Nash Equilibrium이 존재하지 않는다는 사실을 알 수 있다.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th> </th>
      <th>Head</th>
      <th>Tails</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Head</td>
      <td>1, -1</td>
      <td>-1, 1</td>
    </tr>
    <tr>
      <td>Tails</td>
      <td>-1, 1</td>
      <td>1, -1</td>
    </tr>
  </tbody>
</table>

<h3 id="dominant-strategies">Dominant Strategies</h3>
<p>이제 Game Theory에서 중요한 개념 중 하나인 dominant strategy에 대해 살펴보자. Strategy를 아직 엄밀하게 정의한 상태는 아니기 때문에 단순히 ‘어떤 action을 고르는 행위’ 정도로 이해하자. (Reinforcement learning에서 나오는 policy와 동일한 개념이다.) 이때, (strictly/weakly) dominant라는 것은 다음과 같이 정의할 수 있다.</p>

<script type="math/tex; mode=display"> s_i ~\mbox{strictly dominates}~ s_i^\prime ~\mbox{if}~ \forall s_{-i} \in S_{-i}, u_i(s_i, s_{-i}) > u_i(s_i^\prime, s_{-i}). </script>

<script type="math/tex; mode=display"> s_i ~\mbox{weakly dominates}~ s_i^\prime ~\mbox{if}~ \forall s_{-i} \in S_{-i}, u_i(s_i, s_{-i}) \geq u_i(s_i^\prime, s_{-i}). </script>

<p>만약 어떤 strategy가 모든 다른 strategy에 대해 dominate하다면 우리는 그런 strategy를 dominant하다고 부른다.
정의에 따라 dominant strategy가 성립하는 경우, Nash equilibrium이 성립하며, 만약 strictly dominant한 strategy라면, Nash equilibrium은 그 점에서만 unique하다.</p>

<h3 id="pareto-optimality">Pareto Optimality</h3>
<p>마지막으로 Pareto optimality에 대해 다루면 week1은 끝이 난다.
지금까지 우리는 각각의 player의 입장에서 game과 strategy, equilibrium 등을 정의했다. 그런데 만약에 게임에 참여하는 player가 아니라 게임에 참여하지 않는 누군가의 관점에서 게임을 결정하게 된다면 어떻게 될까? 예를 들어 죄수의 딜레마에서 바깥에 있는 우리는 둘 모두가 협조하지 않는 것이 optimal이라는 것을 알고 있는데, 이런 것들을 게임에 반영할 수는 없을까?
즉, 게임을 참여하는 입장이 아닌 상태에서 ‘최종 outcome’이 게임 참여자들에게 어떤 결과를 주는지를 바탕으로 action을 결정하는 것이다. 그렇다면 이것을 어떻게 엄밀하게 정의할 수 있을까?</p>

<p>아이디어는 이렇다. 하나의 outcome $o$가 또 다른 outcome $o^\prime$ 보다 모든 다른 agent들에게 좋고, 만약 $o^\prime$을 $o$보다 strictly prefer하는 agent가 존재한다면, $o^\prime$을 고르는 것이 $o$를 고르는 것 보다 나을 것이라고 생각하는 것이다. 또한 이런 경우 우리는 ‘$o$ Pareto-dominates $o^\prime$’ 라고 정의한다. 이렇게 정의할 경우, Pareto-optimal은 다음과 같이 정의된다.</p>

<blockquote>
  <p>An outcome $o^*$ is Pareto-optimal if there is no other outcome that Pareto-dominates it.</p>
</blockquote>

<p>물론 2주차에서 다루듯, Pareto optimal이 존재하는지 확인하는 문제는 NP-complete이기 때문에 풀기 매우 어려운 문제이긴 하지만, 이런 개념을 통해 조금 더 ‘공익적인’ 게임을 설계할 수도 있다.</p>

<h3 id="section-1">정리</h3>
<p>가장 간단한 개념을 다루는 첫 주차인 만큼, 전반적으로 ‘개념’들에 초점이 맞춰져 있다. 가장 기본적이라고 할 수 있는 ‘game’의 정의와 Nash Equilibrium,
dominat strategy와 Pareto optimality까지, 전체적으로 간단한 개념들을 훑어가는 주라고 생각하면 될 것 같다.</p>

<h3 id="references">References</h3>

<ol class="reference">
  <li><a href="https://www.coursera.org/learn/game-theory-1">Coursera Game Theory Course</a></li>
</ol>

<h3 id="section-2">변경 이력</h3>
<ul>
  <li>2016년 8월 21일: 글 등록</li>
</ul>

<p>----

### [Game Theory 스터디](/blog/categories/game-theory-study/)의 다른 글들

#### [Game Theory](https://www.coursera.org/learn/game-theory-1)

* [Week 1: Introduction and Overview](/101)
* [Week 2: Mixed-Strategy Nash Equilibrium](/102)
* Week 3: Alternate Solution Concepts
* Week 4: Extensive-Form Games
* Week 5: Repeated Games
* Week 6: Bayesian Games
* Week 7: Coalitional Games

#### [Game Theory 2: Advanced Application](https://www.coursera.org/learn/game-theory-2)

* Week 1: Social Choice
* Week 2: Mechanism Design
* Week 3: Efficient Mechanisms
* Week 4: Auctions</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>죄수의 딜레마란, 두 명의 죄수가 전부 협조하지 않으면 아주 가벼운 형을 (a) 살고, 둘 중 한 명만 협조할 경우 협조한 죄수는 가장 경미한 형을 (b) 살게 되고, 협조하지 않은 죄수는 엄청나게 무거운 형을 (c) 살게 되며, 마지막으로 둘 다 협조할 경우 둘 다 혐의가 인정되어 협조하지 않았을 때보다는 무겁고, 둘 중 한 명이 배신해서 얻는 형보다는 가벼운 형을 (d) 살게 된다. (c &gt; a &gt; d &gt; b) 당연히 둘 다 협조하지 않는 것이 optimal solution이지만, 죄수 1의 입장에서는 죄수2가 협조 하지 않는다고 생각할 경우 협조하는 것이 유리하고, 반대로 죄수2가 협조할 것으로 되는 경우에도 협조하는 것이 유리하다. 따라서 죄수1는 죄수2가 어떤 선택을 하든지 협조하는 길을 선택하게 되고 죄수2역시 협조를 하게 된다. 따라서 둘 다 협조하지 않는 것이 optimal임에도 불구하고, 이 게임의 균형은 둘 다 협조하고 d만큼의 형을 사는 것으로 결론나게 된다. 더 자세한건 <a href="https://ko.wikipedia.org/wiki/죄수의_딜레마">위키 페이지</a> 참고.<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera Neural Networks for Machine Learning Week4 & 5 - Applications]]></title>
    <link href="http://SanghyukChun.github.io/43/"/>
    <updated>2014-04-05T21:38:00+09:00</updated>
    <id>http://SanghyukChun.github.io/43</id>
    <content type="html"><![CDATA[<h3>들어가기 전에</h3>
<p>이 글은 Geoffrey Hinton 교수가 2012년 Coursera에서 강의 한 <a href="https://class.coursera.org/neuralnets-2012-001/lecture">Neural Networks for Machine Learning</a> 4주차와 5주차 강의를 요약한 글이다. 이 강의에서는 이론적인 형태의 무언가를 배운다기보다는 real application의 예로 Neural Network를 사용해 word prediction (NLP에서 쓰이는) 그리고 object recognition를 하는 방법에 대해 다룬다. 내가 관심이 있는 부분은 실제 이 NN을 어떻게 적용하냐라기 보다는 NN이란 무엇이며 어떤 이론적 배경이 있는 것이며 그 알고리듬에 더 관심이 있기 때문에 대부분이 engineerning issue인 이번 두 강의들은 대략적으로 어떤 내용에 대해서 다루는지만 아주 간략하게 기술하였다.</p>
<h3>Learning feature vectors for words</h3>
<p>Speech recoginition에서 가장 중요한 문제 중 하나는 바로 제대로 인식되지 않은 단어가 무엇일지 추측하는 것이다. 아무리 기술이 좋아지더라도 speech를 완전하게 복원하는 것은 불가능하다. 살제 사람들도 완전하게 speech를 인식하는 것은 아니고 때에 따라 적당히 추측해서 이해하는 것처럼, 이런 문제가 음성 인식에서 많이 중요한 문제로 대두되고 있다. 나도 seri를 사용하다보면 음성인식률이 생각보다 좋지않아서 실망하고는 하는데, 이런 문제점을 해결하기 위해 다양한 방법들이 제시되고 있다. 이 강의는 이런 것들을 개선시키기 위해 neural network를 도입했었던 연구들에 대해 다룬다. 참고로 여기에서 사용하는 모든 NN들은 softmax function neuron을 사용하고 error function은 cross entropy error를 사용한다. 이유는 sigmoid function을 사용했을 때 error가 rmse라면 제대로 우리가 원하는 방향으로 학습하기가 어렵기 때문이다. 왜냐하면 sigmoid function은 양 쪽 끝 부분이 거의 평평하기 때문에 만약 우리가 정 반대쪽 방향에서 rmse의 gradient 방향을 취하게 된다면 거의 변화가 없다고 판단할 수도 있기 때문이다. 따라서 이런 방법을 개선하기 위해서 cross entropy error를 사용하였고, 이 방법을 사용하기 위하여 sigmoid를 softmax로 바꿔서 probability distribution으로 만들어준 것이다. 아무튼 이 강의에서 설명하는 방법들은 이런 방법들에 기반해서 NN을 만든다. 아무튼 우리가 처음에 풀려고 했었던 단어를 추측하는 고전적인 방법 중에 <a href="http://en.wikipedia.org/wiki/N-gram">N-gram</a>문제라는 것이 있는데, n개의 단어 배열들을 학습하여 임의의 n-1개의 단어가 주어졌을 때 그 다음 단어가 무엇일지 예측하는 문제이다. 실제로 자연언어처리에서 많이 사용하는 기법 중 하나인데, 보통 trigram을 많이 사용한다 (3개의 단어 시퀀스를 학습) 그런데 이 경우 우리가 모든 단어를 학습할 수도 없고, 우리가 관측하지 못한 단어배열이라고 해서 세상에 존재하지 않는 단어 배열이라 확신할 수가 없기 때문에 당연히 성능 역시 좋지 않을 것이라고 예측할 수 있을 것이다. 대신 input을 앞의 2개의 단어를 취하고 그 output을 세 번째 단어로 하는 neural network를 학습할 수도 있을 것이다. 하지만 이렇게 할 경우 output의 양이 너무 많아지므로 대신 3번째 단어의 후보군들의 집합을 같이 넣어서 결과를 얻는 방식을 취할 수도 있을 것이다. 더 성능을 높이기 위해서 엄청 긴 word seqeunce를 통채로 학습하고, 임의의 단어의 앞의 n개 단어 뒤의 m개 단어를 보고 추측하는 것이 가능할 것이다. 이 경우, 지금 단어가 random인지 제대로 된 단어인지 일부러 섞어서 learning을 하게 되면 output을 binary로 받는 것이 가능해져서 엄청나게 빠른 test time을 가질 수가 있게 된다는 장점이 있다.</p>
<h3>Object recognition with neural nets</h3>
<p>우리가 물체를 인식하는 것을 매우 자연스러운 일로 생각하지만 실제로 이것을 구현하는 것은 절대로 쉬운 일이 아니다. 우리는 물체가 살짝 가려져 있어도 구분이 가능하고, 또한 해당 물체를 유동적으로 인식한다. 무슨 말인가하면, 인식 알고리듬을 디자인하는데 있어서 문제점은 (1) 물체가 다른 물체 혹은 주변 환경에 의해서 가려진 상태일 때 (2) 밝기와 조명에 따른 해당 물체의 색 변화 (pixel 정보가 변한다) (3) 같은 클래스에 속해도 조금씩 다른 모습 - 예를 들어서 손글씨 숫자는 비록 같은 숫자이나 전부 필체가 달라서 variation이 있다. (4) 물체가 정의되는 것은 모양이 아니라 다른 방법으로 결정되는 경우도 많다 - 예를 들어 의자는 모습으로 구분하는 것이 아니라 그 사용처가 어디인가에 따라 분류해야 구분할 수 있을 것이다.</p>
<p>그 밖에도 결국 우리가 사용할 수 있는 정보는 image 정보이고, 디지털 input image는 단순한 pixel map이다. 예를 들어서 1024 by 720 pixel의 사진이라고 한다면 총 737280개의 pixel이 input이 될 것이다. 각 pixel은 RGB정보를 가지고 있으므로 값은 (0,0,0) ~ (255,255,255) 사이의 값으로 정해질 것이다. 색상이 중요하지 않은 경우에는 흑백 사진으로 바꾸어 단순히 밝기로만 판단하기도 한다. 아무튼 그렇기 때문에 약간의 물체의 이동도 성능을 크게 바꿔버릴 수 있다. 단순히 옆으로 이동한 것 뿐 아니라 회전된 정보나 뒤집힌 정보는 우리가 인식 알고리듬을 작성하는데에 매우 어려운 부분으로 작용한다. 따라서 우리는 모든 정보를 normalization시켜야할 필요가 있으며 align해야 할 필요가 있다. 이런 처리 없이는 올바른 정보를 학습하기가 매우 어려워질 것이다.</p>
<p>이 강의에서는 이런 문제점들을 가지고 있는 object recognition을 neural network로 접근한다. 이런 경우 determistic method보다 훨씬 더 좋은 성능을 낼 수 있으리라는 것은 자명할 것이다. Input은 pixel map이고, output은 어떤 object인지 알려주는 label 혹은 class가 될 것이다. 이런 Hidden layer가 포함된 neural network를 backpropagation 방법을 사용하여 learning한다. 실제로 많은 image recoginition에서 neural network를 사용하고 있으며, 앞에서 설명했었던 여러 문제점들을 해결해주는 경우가 많다. 또한 아마 이런 목적을 가지고 설계된 알고리듬 중에서는 neural network가 가장 성능이 좋을 것이다.</p>

<h3>Coursera Neural Networks for Machine Learning</h3>
<p>다른 요약글들 보기 (<a href="http://SanghyukChun.github.io/blog/categories/cousera-nn/">카테고리로 이동</a>)</p>
<ul>
	<li>Lecture 1: <a href="http://SanghyukChun.github.io/39">Introduction</a></li>
	<li>Lecture 2: <a href="http://SanghyukChun.github.io/40">The Perceptron learning procedure</a></li>
	<li>Lecture 3: <a href="http://SanghyukChun.github.io/42">The backpropagation learning proccedure</a></li>
	<li>Lecture 4: <a href="http://SanghyukChun.github.io/43">Learning feature vectors for words</a></li>
	<li>Lecture 5: <a href="http://SanghyukChun.github.io/43">Object recognition with neural nets</a></li>
	<li>Lecture 6: Optimization: How to make the learning go faster</li>
	<li>Lecture 7: Recurrent neural networks</li>
	<li>Lecture 8: More recurrent neural networks</li>
	<li>Lecture 9: Ways to make neural networks generalize better</li>
	<li>Lecture 10: Combining multiple neural networks to improve generalization</li>
	<li>Lecture 11: Hopfield nets and Boltzmann machines</li>
	<li>Lecture 12: Restricted Boltzmann machines (RBMs)</li>
	<li>Lecture 13: Stacking RBMs to make Deep Belief Nets</li>
	<li>Lecture 14: Deep neural nets with generative pre-training</li>
	<li>Lecture 15: Modeling hierarchical structure with neural nets</li>
	<li>Lecture 16: Recent applications of deep neural nets</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera Neural Networks for Machine Learning Week3 - Backpropagation]]></title>
    <link href="http://SanghyukChun.github.io/42/"/>
    <updated>2014-03-26T00:10:00+09:00</updated>
    <id>http://SanghyukChun.github.io/42</id>
    <content type="html"><![CDATA[<h3>들어가기 전에</h3>
<p>이 글은 Geoffrey Hinton 교수가 2012년 Coursera에서 강의 한 <a href="https://class.coursera.org/neuralnets-2012-001/lecture">Neural Networks for Machine Learning</a> 3주차 강의를 요약한 글이다. 이 렉쳐에서는 Perceptron의 한계를 극복하기 위해 도입된 multi-layer feed forward network를 learning하는 algorithm인 backpropagation algorithm에 대해서 다룬다.</p>
<h3>Learning the weights of a linear neuron</h3>
<p><a href="http://SanghyukChun.github.io/40#what-perceptrons-cant-do">Lecture 2의 마지막</a>에서 다뤘던 perceptron의 가장 큰 문제점은 문제가 조금만 복잡해지거나, linear하게 표현되지 않는 문제는 올바른 결과로 수렴할 수 없다는 것이었다. 예를 들어서 엄청나게 간단한 로직인 xor은 perceptron으로 learning될 수 없다. 이런 문제를 해결하기 위해 <a class="red tip" title="이 렉쳐에서는 multi-layer perceptron이라고 지칭한다.">multi-layer feed forwad neural network</a>의 필요성이 대두된다. 일단 우리는 기존의 perceptron algorithm으로는 해당 문제를 해결할 수 없다는 것을 알고있으므로, 무언가 다른 알고리듬을 한 번 고안해보도록 하자. 가장 간단하게 생각할 수 있는 알고리듬은 어떤 error function을 정의하고 그 error를 minimize시키는 network를 learning하는 것일 것이다. 그렇다면 어떤 error function을 minimize해야할까? 간단하게 neural network의 output을 계산해서 expected value (target value)와 actual output value의 차이를 error로 정의하면 어떨까? 즉, neural network의 output이 우리가 원하는 output과 가장 근접한 weight를 learning하는 방법을 취하는 것이다. 근데 여기에서 문제가 하나 생기게 되는데, 바로 이 error function이 weight에 대해서 convex하지가 않다는 것이다. 당연히 관련되는 weight set도 엄청나게 많고, network자체가 convex한 form이 아니기 때문이다. 즉, 실제 좋은 performance를 내는 weight들의 여러 set을 취해 그 중간 값을 취해 얻은 weight가 좋은 weight가 아닐 수도 있다는 것이다. perceptron algorithm의 가장 attractive한 점은 algorithm이 convex하기 때문에 언제나 같은 값으로 converge한다는 점인데, 이런 방식으로는 그런 convergence가 보장이 안되는 것이다.</p>
<p>일단, 어쨌거나 perceptron이 적용이 안되는 상황이니깐, 위에서 정의한 error minimization의 측면에서 문제를 접근해보도록하자. 가장 간단한 예시인 Linear neuron에 대해서 살펴보자. 일단 y를 neuron을 통해서 얻어진 estimated output, w를 weight vector, x를 input vector라고 하면 다음과 같은 식을 세울 수 있다.</p>
<p>$$ y = \sum_i w_i x_i = \mathbf w^\top \mathbf x $$</p>
<p>이 상황에서 input vector x의 real output을 t (target output)이라고 해보자. 이런 상황에서 가장 간단한 error는 actual output과 desired output의 squared difference이다. 즉, 이를 수식으로 나타내면 $error = \sqrt{t-y}$로 표현할 수 있을 것이다. 우리의 목표는 이런 상황에서 weight를 iterative method를 사용하여 구하고 싶은 것이다. Iterative method라는 것은 어떤 특정한 반복적인 알고리듬을 사용하여 (예를 들어 gradient descent나 perceptron처럼) 계속 값을 update시켜나가면서 가장 적절한 것으로 보이는 값을 찾아내는 방법이다. 즉, $w_{t+1} = f(w_t) $로 표현이 가능하다. $w_t$는 t번 째 loop에서 w의 값이고, f는 w를 update하는 rule이다. 그렇다면 여기에서 잠시 궁금한 점이 생길 수 있다. 만약 우리가 target vector를 알고 있다면, 왜 문제를 analytically하게 해결하지 않을까? 즉, 우리가 이미 x와 y를 안다면 이를 가장 최적화시키는 w를 계산으로 단 한 번에 구할 수 있을 것인데, 왜 하필 iterative method를 사용하여 계속 값을 update하는 것일까? 훨씬 비효율적이지 않을까? 이 질문에 대한 알고리듬 관점에서 바라봤을 때의 답을 간략하게 말해주자면, 그런 형태의 analytic solution은 반드시 문제가 linear해야하고 또 squared error measure에 대해서만 working하기 때문인 것이 하나, 그리고 Iterative method가 조금 비효율적으로 보일지는 몰라도 더 복잡한 네트워크에 대해서 generalize하기가 더 간단힌 이유 하나를 들 수 있을 것이다.</p>
<p>이런 iterative method는 맨 처음 모든 weight를 random하게 guess하고 <a class="red tip" title="조건은 바뀔 수 있다. 예를 들어 input 3개를 보고 update하는 것도 가능하다. 뒤에서 조금 더 자세히 다루도록 하겠다.">매 input마다</a> 적절하게 weight를 update시킨다. 이 방법은 weight가 어떤 특정한 value로 converge할 때까지 계속된다. 그렇다면 이런 방법의 예를 하나 들어보자. 이 강의에서는 다음과 같은 function을 정의한다. $price = x_{fish} w_{fish} + x_{chip} w_{chip} + x_{ketchup} w_{ketchup}$ 즉, 내가 식당에서 <a class="red tip" title="fish and chips라고 하는 요리.. 생선튀김이랑 감자튀김 같이 먹는거랑 똑같다">생선과 칩과 케첩</a>을 먹었을 때 내가 지불해야하는 금액을 내가 먹은 양 (x), 그리고 각 item들의 가격 (w)으로 나타낸 것이다. 내가 알고 있는 값은 input x (내가 시킨 양) 그리고 계산서를 통해 얻은 값이다. 하지만 나는 w를 모르며, 이 w를 찾는 것이 목적이다. 그렇다면 처음에는 random하게 w를 guess할 수 있을 것이다. 이때, (120, 50, 100)이 true weight라고 해보자. 즉, 현재 input이 2,5,3일 때 price는 850일 것이다. 현재 우리는 weight에 대한 정보가 없으므로 모두 50이라고 가정하면 내가 estimate한 price는 500이고, error의 값은 350이 된다. 이때, $\triangle w_i = \epsilon x_i (t-y)$라는 learning rule이 있다고 해보자. (이 learning rule은 delta-rule이라는 규칙으로, 바로 다음 단락에서 자세히 다루도록 하겠다.) 이 수식을 적용하면 다음 weight는 70, 100, 80이 되고 error는 30으로 줄어들게 된다 (esitimated price = 880, true = 850) 이런 식으로 각 iteration마다 error의 값을 줄여나가면서 true weight를 찾는 것이 iterative method의 작동원리인 것이다.</p>
<p>그렇다면 이런 방법에서 가장 중요한 개념은 아마 learning rule일 것이다. 이 렉쳐에서는 'Delta Rule'이라는 rule을 소개하고 있다. 이 방법은 일종의 Gradient Descent method인데, single layer neural network에서 주로 사용하는 방법이라고 한다. 자세한 설명은 <a href="http://en.wikipedia.org/wiki/Delta_rule">wiki</a>를 참고. 그렇다면 왜 delta-rule은 $\triangle w_i = \epsilon x_i (t-y)$ 의 꼴을 띄고 있는 것일까? 증명은 간단하다. error를 squared residuals summation error로 정의하고 차근차근 수식을 전개하면 해당 꼴을 얻을 수 있다. wiki에도 언급이 되어 있으므로 설명이 미진하다면 wiki를 참고하면 될 것 같다. 먼저 $E = \sum_j \frac 1 2 (t_j - y_j)^2$이라하자. (notation은 wiki의 notation을 사용하겠다.) 이 error는 convex function이고 domain도 convex하므로 gradient descent method를 사용하면 error의 global minimum값을 반드시 찾을 수 있다. 따라서 만약 우리가 "weight space"에 대해서 이 error를 최소화하게 된다면 매 순간 minimize하기 위해 내려가는 방향 즉, 이 함수의 gradient 값은 $\frac {\partial E} {\partial w_{ji}}$이 될 것이다. 이때, 이 gradient descent는 error를 줄이기 위해서 필요한 weight들의 change이고, 방향은 반대이므로 $\triangle w_{ij} = - \epsilon \frac \partial E \partial w_{ji}$라고 할 수 있는 것이다. 그리고 뒤의 미분항을 간단하게 chain rule을 사용하여 정리하면 이전의 식은 결국 다음과 같은 수식으로 표현이 가능하다.</p>
<p>$$ \triangle w_{ij} = \epsilon (t_j - y_j)x_i $$</p>
<p>wiki에서는 active function의 미분항까지 들어가게 되는데, 이 경우는 일단 생략하였다.</p>
<p>이제 update rule을 만들었으니 필연적으로 생기는 question들을 점검해보자. (1) 이 알고리듬은 반드시 global한 값으로 converge하는가? - convex optimization이기 때문에 global truth로 converge하긴한다. 적절한 step size가 필요한데 이것은 이론적으로 구할 수 있으므로 큰 상관이 없다. (2) converge rate는 얼마나 될 것인가? - gradient descent method들이 대부분 그러하듯 많이 느릴 것이다. 이를 개선하기 위해 steepest descent method를 적용하는 등의 방법이 있는 것으로 보인다. 마지막으로 perceptron과 비교해보자. perceptron은 'error가 발생해야만' update가 일어났으며, error는 binary error였기 때문에 update가 일어나지 않을 수도 있었다. 하지만 지금은 error가 real function이므로 error는 거의 항상 non zero value가 되고 update도 지속적으로 일어난다. 또한 perceptron이 아무런 parameter tuning이 없던 것과 비교해 (margin은 일단 예외로 하자) learning rate를 골라야하는 귀찮은 문제가 하나 생기게 되었다.</p>
<h3>The error surface for a linear neuron</h3>
<p>이 소강의는 거의 언급할 내용이 없다. 앞에서 이미 이 문제가 convex임을 밝혔으며, 또한 weight space라는 concept역시 이미 언급했다. 언급되고 있는 문제는 거의 gradient descent method의 문제점들이다. 특히 convergence rate가 느린 경우, zig-zag하게 수렴하는 경우는 어떻게 해야할 것인가? 등에 대한 question만 던지는 강의이기 때문에 과감하게 생략하도록 하겠다.</p>
<h3>Learning the weights of a logistic output neuron</h3>
<p>delta rule을 logistic neuron에 대해 적용하는 것인데, 결론만 얘기하면</p>
<p>$$ \triangle w_{ij} = \epsilon (t_j - y_j) y_i (1-y_i) x_i $$</p>
<p>의 꼴이 된다. 즉, 앞에서 언급했던 activate function의 미분값인 $y_i (1-y_i)$가 포함되는 형태라는 것만 알아두면 된다. 다만, 이 경우에 binary threshold neuron이 아니라 logistic neuron을 쓰는 이유는 binary threshold neuron은 error가 항상 0아니면 1이기 때문에 gradient descent method를 사용할 수 없기 때문이다. 이제 간단한 배경지식을 갖추었으니 이번 렉쳐의 메인인 backpropagation으로 넘어가보자.</p>
<h3>The backpropagation algorithm</h3>
<p>자, 사실 앞에서 이런저런 얘기를 주절주절 했던 이유는 바로 backpropagation algorithm에 대해 설명하기 위해서였다. 이 algorithm은 당연히 iterative method이며, logistic neuron에 대해서 delta-rule (gradient descent method)를 적용하여 최적의 weight를 계산해낸다. 이 알고리듬은 hidden layer가 존재하는 neural network를 learning하기 위해 사용이 되는 알고리듬이며, <a class="red tip" title="backpropagation은 역전파, 즉 반대 쪽으로 영향을 미친다는 뜻이다, 이 경우는 결과를 통해 weight를 학습하기 때문에 역전파라고 부른다">이름에서 알 수 있듯</a> network의 output value에서부터 역으로 weight를 learning하게 된다. 왜 우리는 hidden layer가 존재하는 neural network를 learning해야할까? 이런 방법을 쓰지 않으면 network가 항상 linear하기 때문에 real problem을 풀 수가 없기 때문이다. 그리고 또한, hidden layer를 사용한다는 의미는 우리가 임의의 feature를 정하고, 각 feature들의 weight가 얼마나 되는지 학습을 한다는 의미와 같다. 무슨 얘기이냐하면, 만약 엄청나게 dimension이 큰 input이 있을 때 (예 - 해상도 높은 사진) 실제 algorithm을 돌릴 때 모든 input을 사용해 learning하는 것은 거의 의미가 없고 (특히 high dimension, samll input인 경우는 overfitting issue가 크게 작용한다.) 해당 알고리듬에 대입해서 실행시킬 feature를 뽑아내는 과정을 필요로 하는 경우가 많다. 그런데 대부분의 경우 우리는 이런 feature를 heuristic하게 찾는다. 즉, 사진에서 눈, 코, 입을 feature로 삼아야한다고 우리의 heuristic으로 결정하고, masking을 손으로 하고 그 결과를 알고리듬에 대입하는 것이다. 그런데 hidden layer를 사용하게 되면 그런 불필요한 행동을 줄일 수 있다. 만약 hidden unit각각이 머리카락, 눈, 입술, 코, 귀 등등을 의미하고 있다면 적절한 weight를 learning함으로써 feature에 대한 weight를 결정할 수 있고, 우리가 일일이 손으로 하던 것들을 자동화시킬 수 있는 것이다. 이렇기 때문에 hidden layer가 포함된 neural network가 powerful하고 meaningful하다. 그리고 backpropagation을 사용하는 이유는 그것이 가장 효율적이고 빠른 학습 방법 중 하나이기 때문이다.</p>
<p>Backpropagation이 아닌 다른 예를 하나 생각해보자. 예를 들어서 output을 사용하지 않고 initial weight를 주고 weight를 조금씩 변화시키면서 적절한 값을 찾을 수도 있을 것이다. (Learning using perturbations) 즉, 원하는 target value를 고정해두고 해당 value에 가장 가깝도록 weight를 하나하나 강제로 조정하면서 전체 weight를 찾아가는 다소 reinforcement learning과 비슷한 방법으로 접근하는 것이 가능할 수도 있다. 그러나 이런 방법은 큰 문제가 있다. 먼저 weight가 많아질수록 찾아야하는 값이 많아지고 computation time이 엄청나게 빠르게 증가할 것이다. 또한 이런 방법은 weight에 대해 network가 convex하다면 의미가 있을 수 있지만 당연히 hidden layer가 포함된 network는 convex하지 않다. 결국 이 방법은 우리가 상상도 하지 못할 만큼 많은 양의 computation time을 필요로 하는 좋지 못한 방법인 것이다. 심지어 아주 적은 수의 neuron만 있더라도 바로 뒤에서 설명하게 될 backpropagation이 더 성능이 우수하기 때문에 이런 방법 자체를 사용하지 않는 것이다.</p>
<p>그렇다면 이제 backpropagation algorithm에 대해 discribe해보자. backpropagation의 기본 아이디어는 우리가 hidden unit들 그 자체에 대해서 알 필요가 하나도 없고 (알 수도 없을 뿐더러), 대신 hidden unit들로 인해 생성되는 error change를 관측하는 것이 더 낫다는 것이다. 즉, hidden unit 그 자체의 activity를 learning하는 것이 아니라, hidden unit들로 인해서 생겨나는 error derivatives를 사용하자는 것이다. 이 방법은 ouput layer에서 아래 layer로 정보를 backpropagation하여 (역으로 보내어) lower layer에서 그 값을 기준으로 다시 weight를 update시킨다. input pattern은 hidden layer에 전달이 되고, 다시 hidden layer가 output layer로 전달을 시키므로 (hidden layer가 하나일 때) 이런 방법으로 현재 weight에 대한 expected value와 estimated value 사이의 error를 구할 수 있고 이것을 최소화 하는 방향으로 weight를 learning하는 것이다. weight를 learning할 때는 앞에서 우리가 이미 살펴보았던 delta-rule을 사용하여 output layer에서의 각 neuron들의 error를 사용해 weight들을 update한다.</p>
<p>이를 그림으로 표현하면 아래와 같다. (출처: <a href="http://tex.stackexchange.com/questions/162326/drawing-back-propagation-neural-network">링크</a>)</p>
<p><img src="/images/post/42-1.png" width="600"></p>
<p>Backpropagation은 크게 두 가지 phase로 나눌 수가 있는데, 하나는 propagation phase이며, 하나는 weight update phase이다. propagation phase에서는 training input pattern에서부터 에러, 혹은 각 뉴런들의 변화량을 계산하며, weight update phase에서는 앞에서 계산한 값을 사용해 weight를 update시킨다.</p>
<h6>Phase 1: Propagation</h6>
<ol>
	<li>Forward propagation: input training data로부터 output을 계산하고, 각 ouput neuron에서의 error를 계산한다. (input -&gt; hidden -&gt; output 으로 정보가 흘러가므로 'forward' propagation이라 한다.)</li>
	<li>Back propagation: output neuron에서 계산된 error를 각 edge들의 weight를 사용해 바로 <a class="red tip" title="이 경우는 hidden layer가 하나이므로 hidden layer를 지칭한다.">이전 layer</a>의 neuron들이 얼마나 error에 영향을 미쳤는지 계산한다. (output -&gt; hidden 으로 정보가 흘러가므로 'back' propagation이라 한다.)</li>
</ol>
<h6>Phase 2: Weight update</h6>
<ol>
	<li>Delta rule을 사용해 weight를 update한다. update rule은 다음과 같다. (delta rule for logistic neuron)<br />
		$ \triangle w_{ij} = \epsilon (t_j - y_j) y_i (1-y_i) x_i $</li>
</ol>
<p>위의 과정은 output layer에서부터 하나하나 내려오면서 반복된다. 즉, output -&gt; hidden k, hidden k -&gt; hidden k-1, ... hidden 2 -&gt; hidden 1, hidden 1 -&gt; input의 과정을 거치면서 계속 weight가 update되는 것이다. 그리고 이 cycle자체가 converge했다고 판단될 때 까지 계속 반복된다.</p>
<p>이렇듯 backpropagation은 직접 weight를 바로 변화시키는 것이 아니라 오직 error만을 보고 gradient descent method based approach를 사용해 error를 minimize하는 방향으로 계속 weight를 update시키는 것이다. 또한 한 번 error가 연산된 이후에는 output layer에서부터 그 이전 layer로 '역으로' 정보가 update되기 때문에 이를 backpropagation, 한국어로는 역전사라고 하는 것이다.</p>
<h3>How to use the derivatives computed by the backpropagation algorithm</h3>
<p>Overfitting과 Optimization issue가 나오는데, Online, batch update 중 무엇을 고르느냐, 어떻게 overfitting을 줄이냐 등등, 이미 예전에 많이 다뤘거나 앞으로 다시 다뤄질 주제들이라 판단되어 생략하도록 하겠다.</p>
<p>다만, backpropagation에 대해 중요한 언급이 빠져있어서 첨언을 하자면, backpropagation 은 항상 global optimum으로 converge하지 않기 때문에 언제나 local minimum으로 converge할 가능성이 존재한다. 이는 특히 hidden layer가 많아지면, 혹은 네트워크가 deep해지면 deep해질 수록 더 심해진다. 따라서 initial value를 어떻게 설정하느냐가 매우 민감하다. initial value에 따라 수렴하는 방향이 달라질 수 있기 때문인데, 나중에 배울 Deep belif network에서는 initial value를 미리 pre-training하는 방법으로 이를 극복해낸다.</p>

<h3>Coursera Neural Networks for Machine Learning</h3>
<p>다른 요약글들 보기 (<a href="http://SanghyukChun.github.io/blog/categories/cousera-nn/">카테고리로 이동</a>)</p>
<ul>
	<li>Lecture 1: <a href="http://SanghyukChun.github.io/39">Introduction</a></li>
	<li>Lecture 2: <a href="http://SanghyukChun.github.io/40">The Perceptron learning procedure</a></li>
	<li>Lecture 3: <a href="http://SanghyukChun.github.io/42">The backpropagation learning proccedure</a></li>
	<li>Lecture 4: <a href="http://SanghyukChun.github.io/43">Learning feature vectors for words</a></li>
	<li>Lecture 5: <a href="http://SanghyukChun.github.io/43">Object recognition with neural nets</a></li>
	<li>Lecture 6: Optimization: How to make the learning go faster</li>
	<li>Lecture 7: Recurrent neural networks</li>
	<li>Lecture 8: More recurrent neural networks</li>
	<li>Lecture 9: Ways to make neural networks generalize better</li>
	<li>Lecture 10: Combining multiple neural networks to improve generalization</li>
	<li>Lecture 11: Hopfield nets and Boltzmann machines</li>
	<li>Lecture 12: Restricted Boltzmann machines (RBMs)</li>
	<li>Lecture 13: Stacking RBMs to make Deep Belief Nets</li>
	<li>Lecture 14: Deep neural nets with generative pre-training</li>
	<li>Lecture 15: Modeling hierarchical structure with neural nets</li>
	<li>Lecture 16: Recent applications of deep neural nets</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera Neural Networks for Machine Learning Week2 - Perceptron]]></title>
    <link href="http://SanghyukChun.github.io/40/"/>
    <updated>2014-03-21T07:21:00+09:00</updated>
    <id>http://SanghyukChun.github.io/40</id>
    <content type="html"><![CDATA[<h3>들어가기 전에</h3>
<p>이 글은 Geoffrey Hinton 교수가 2012년 Coursera에서 강의 한 <a href="https://class.coursera.org/neuralnets-2012-001/lecture">Neural Networks for Machine Learning</a> 2주차 강의를 요약한 글이다. 첫 주 강의에서 Neural Network란 무엇이며 어떤 종류의 Neural Network들이 있는지 등에 대해 간략하게 다뤘다면, 이 강의에서는 가장 오래된 Neural Network 중 하나인 Perceptron을 설명하는 내용이 주가 된다.</p>
<h3>An overview of the main types of neural network architecture</h3>
<p><a href="http://SanghyukChun.github.io/39">이전 글</a>에서 Neuron들에는 어떤 종류가 있을 수 있는가 다뤘었다. 대충 linear neuron, linear threshold neuron, binary neuron, binary threshold neuron, sigmod neuron 등이 있었다. 그렇다면 neuron들로 구성된 neural network에는 어떤 type들로 구분되는가도 간략하게 알아보도록 해보자.</p>
<p>일단 가장 간단한 형태의 network로 Feed-forward neural network가 존재한다. 가장 일반적으로 쓰이고 실제 어플리케이션에 적용되는 neural network들도 대부분이 feed-forward라고 한다. 이 네트워크는 상당히 간단한 구조인데, 첫 번째 layer는 input이며 가장 마지막 layer는 output이다. 그리고 중간의 input과 output으로 관찰되지 않는 영역을 "hidden" layer라고 하는데, 당연히 visuable하지 않으므로 (우리가 직접 관측하는 영역이 아니므로) hidden이라고 불리는 것이다. 만약 hidden layer가 하나보다 많이 존재한다면 이 network는 "deep" neural network라고 불린다.</p>
<p><img src="/images/post/40-1.png" width="350"></p>
<p>위의 그림이 Feed-forward neural network의 간단한 예시이다. (이 그림은 Hinton 교수의 slide에서 가져왔다.)</p>
<p>이보다 조금 더 복잡한 network로는 Recurrent network라는 것이 존재한다. "Recurrent"라는 이름이 붙은 이유는 graph에 cycle이 존재하기 때문인데, 이 말인 즉슨, 이 network에서는 arrow를 계속 따라가다보면 어느 순간 같은 장소를 계속 돌고 있을 수도 있다는 의미이다. 당연히 일반적인 방법으로 이것을 학습하는 것은 매우 복잡한 일이고 어려운 일이다. 그럼에도 일단 이 네트워크는 가장 "biologically" 현실적인 네트워크라고 한다.</p>
<p><img src="/images/post/40-2.png" width="200"></p>
<p>위와 같이 directed cycle이 존재하는 경우 recurrent network라고 하는데, 이 방법을 사용해서 sequential data를 modeling할 수 있다고 한다. 그런 행위가 가능한 근본적인 이유는 이 방법 자체가 일종의 시간 축으로 very deep한 network로 치환이 가능하기 때문이다. 그림으로 보면 아래와 같은 형태가 된다.</p>
<p><img src="/images/post/40-3.png" width="250"></p>
<p>자 다시 위의 그림을 보면서 차근차근 설명하자면, 위의 그림은 매 시간마다 하나의 hidden layer를 가지는 네트워크이며, 각 hidden layer는 그 다음 hidden layer에 무언가 information을 주는 형태이다. 즉, 자기 자신이 자기 자신에게 정보를 주는 cycle이 존재하는 형태이며, 매 시간마다 input과 output이 존재한다고 생각할 수 있다. 이런 이유로 recurrent network를 이런 형태의 network로 치환하여 생각할 수 있는 것이다. 당연히 실제로 학습하기는 무지하게 어렵지만, 실제 이런 network가 계속 연구가 되고 있으며 2011년 Ilya Sutskever의 연구에서 이런 형태의 network를 사용해 wikipedia의 단어들을 학습해 자동으로 sentence를 generate하는 모듈을 만들어서 실행시킨 결과, 다음과 같은 문장을 얻었다고 한다.</p>
<p>In 1974 Northern Denver had been overshadowed by CNL, and several Irish intelligence agencies in the Mediterranean region. However, on the Victoria, Kings Hebrew stated that Charles decided to escape during an alliance. The mansion house was completed in 1882, the second in its bridge are omitted, while closing is the proton reticulum composed below it aims, such that it is the blurring of appearing on any well-paid type of box printer.</p>
<p>물론, 완전한 형태의 영어는 아니지만, 매 순간 단 하나의 단어만을 generate한 결과임에도 불구하고 엄청나게 뛰어난 성능을 보이고 있음을 알 수 있다. 일반적으로 이런 sentance generate을 위한 모델은 무지무지 복잡하고 여러 단어를 동시에 학습하거나 생성하거나 하는 등의 과정을 거치는데 이 논문에서는 오직 단어를 하나씩만 생성했음에도 꽤 그럴듯한 영어가 나왔다는 점이 고무적이라는 것이다.</p>
<p>마지막으로 Symmetrically connected network가 있다. 이 network는 recurrent network의 special한 case라고 보아도 무방한데, 간단히 말하자면 이전의 neural network들은 모두 directed graph였지만, 이 symmetrically connected network는 undirected graph이다. 즉, 각 layer간에 symmetric한 edge, 다시 말하자면 양 방향으로 서로 같은 weight를 가지게 된다는 의미이다. 이런 network는 energy function이라는 것을 도입하면 recurrent network보다 훨씬 분석하기가 용이하며, performance도 powerful하다. 만약 hidden unit이 없다면 Hopfield network라고 부르며, hidden layer가 존재하면 Boltzmann machine 이라 부르는데, 이 녀석은 나중에 언젠가 다루게 될 Deep network에서 이 Boltzmann machine을 restrict시킨 형태인 Restricted Boltzmann Machine (RBM)을 설명할 때 다시 한 번 자세하게 다룰 예정이다. (Coursera lecture로 따지면 거의 맨 끝 즈음이다.)</p>
<h3>Perceptrons: The first generation of neural networks</h3>
<p>자, 어쨌거나 2주차 강의의 핵심은 바로 perceptron이다. 이 녀석은 가장 오래된 neural network 중 하나이며, 특정 상황에서는 정말 outperform한 결과를 보여주지만 그 한계가 분명한 알고리듬이다. 1690년대 Frank Rosenblatt에 의해 제안된 알고리듬으로 Artificial neural network을 태동하게 한 알고리듬이지만, 그 한계가 너무나 명백하여 한 동안 neural network 연구 자체가 이뤄지지 않게 한 원인이 되기도 한다. 1969년 Minsky가 perceptron이 linear가 아니면 아무것도 할 수 없다는 것을 증명했는데 (단적인 예로, xor조차 학습하지 못한다) 당시 multi layer perceptron에도 이 방식이 적용될 것이라 다소 과도한 추측을 하는 바람에 neural network 연구 자체가 한 동안 메일 스트림이 아니었다. 아무튼, perceptron은 엄청 간단한 feed-forward network의 일종이다. 무지무지 간단하게 그림 하나로 표현하면 아래와 같다 (그림은 google image에서 찾은 그림..)</p>
<p><img src="/images/post/40-4.png" width="600"></p>
<p>하나하나 간단하게 설명해보자. 일단 input layer가 있다. 맨 아래 $x_o$는 $x_n$의 오타로 추정된다. 맨 위의 1은 bias를 위한 term이다. 이전 글에서 bias에 대해 설명한 것을 기억하는지? input과 weight를 linear combination 형태로 정리하고 나서 거기에 상수 항으로 더해지는 값이 bias이다. 즉, input과 상관없이 늘 더해지는 값으로, $b = 1 \times w_o$ 라고 봐도 무방한 것이다. 아무튼, 지금은 간단하게 input layer에서 원래 input vector x와 bias term 1을 weight vector와 곱한 형태인 $z = \sum_i w_i x_i$를 계산했다고 간단하게 생각해보자. perceptron의 decision rule은 간단한데, 방금 계산한 값이 어떤 threshold를 넘으면 값을 activate, 넘지 못하면 값을 deactive 시키는 것이다. 간단하게 얘기하면 perceptron에서는 binary threshold neuron을 사용하는 것이다. 이 threshold를 결정하는 것은? 바로 bias가 그 역할을 하게 된다. 그러므로 이 알고리듬에서 "learning"하는 것은 weight와 bias가 될 것이다. 음.. 뭔가 간단하게 bias는 무시하고 weight만 학습하는 방법은 없을까? 앞에서 bias를 weight로 간단하게 치환한 방법을 사용하면 이렇게 문제를 간단하게 만드는 것이 가능해진다. 원래 input vector에 value 1을 추가하여 마치 input vector가 하나 더 있고, 그 component에 대한 weight가 존재하는 것처럼 trick을 쓰는 것이 가능해진다. 따라서 bias도 weight와 같은 방법으로 자연스럽게 learning할 수 있게 되고, 더 이상 threshold에 대해 고민할 필요가 없어진다!</p>
<p>perceptron이 weight를 학습하는 방법도 매우 간단하다. input vector가 들어왔을 때, 현재 weight로 맞는 값이 나온다면 weight는 update되지 않는다. ($w_{t+1} = w_t$) 만약 1이 나와야하는데 0이 나온다면 weight vector에 input vector를 더해준다. ($w_{t+1} = w_t + v$) 만약 0이 나와야하는데 1이 나온다면 weight vector에서 input vector를 빼주는 방식으로 weight를 update한다. ($w_{t+1} = w_t - v$)</p>
<p>조금 더 잘 describe해보자면, input x에 대해서 output(label) y는 다음과 같은 수식으로 표현된다 -아래 수식에서는 편의를 위해 y = {-1,1} 이라고 하자-</p>
<p>$$ y = sign( \sum_{i=0}^n w_i x_i ) \hskip 1em where, x_0 = 1 \hskip 0.3em and \hskip 0.3em w_0 = -b$$</p>
<p>즉, label y는 vector w와 x의 inner product로 나타낼 수 있으며 이 때 bias b는 $x_0 = 1$, $w_0 = -b$라는 형태로 간단한 weight vector와 input vector의 linear combination으로 표현할 수 있게 되는 것이다. 이 때 update rule은 다음과 같다</p>
<p>$$ w_{t+1} = w_t + y_n x_n, \hskip 1em when \hskip 0.3em misclassified $$</p>
<p>misclassified가 발생했을 때만 update가 일어나며, update rule은 원래 y와 x를 곱해서 원래 vector에 더해주는 것이다. 즉, 1이 나와야하는데 -1이 나왔다면 w에 +x를 취해주고, -1이 나와야하는데 1이 나왔다면 w에 -x를 취해주는 것이다. 그리고 step을 진행시키면서 (t가 점점 증가하면서) misclassified point가 발견될 때 마다 이 알고리듬을 반복한다. 이렇게 설명하면 조금 더 깔끔하게 수식적으로 설명이 가능해진다.</p>
<h3>A geometrical view of perceptrons</h3>
<p>위와 같은 update rule이 선택되는 이유는 무엇인가? 왜 하필이면 input vector를 합해야할까? 이런 질문들은 모두 geometric하게 해석할 수 있다. feature가 n개일 때, input vector와 weight vector는 some n-dimensional vectors이므로, 이 vector들이 존재하는 vector space를 정의하는 것이 가능해지기 때문이다. 여기에서는 weight space라는 새로운 형태의 space를 정의해서 perceptron을 해석할 것이다. 따라서 원래 수식과 대조하여 생각해보면 우리가 궁극적으로 찾고자하는 truth weight vector는 올바른 answer에 대한 어떤 hyperplane일 것이라는 것도 충분히 추측할 수 있다. 무슨 소리냐하면, input vector와 weight vector의 inner product의 sign이 y를 결정한다는 의미는, 곧 그 내각이 90도보다 크냐 작으냐로 생각할 수 있고 (물론 n-dimensional vector에서는 각도 개념이 정의하기 나름이지만) 아마도 대부분의 input vector들에 대해서 올바른 label을 가지게 하는 어떤 hyperplane이 우리가 찾고자하는 궁극적인 weight vector들이라는 것이다. 그림으로 설명해보자.</p>
<p><img src="/images/post/40-5.png" width="600"></p>
<p>위의 그림에서 correct answer가 1이라면 input vector와 weight vector의 inner product를 구했을 때 올바른 값이 나오기 위해서는 당연히 초록색 vector이어야한다는 사실을 알 수 있을 것이다. 이유는 위에서 언급했듯 사이각이 90도 보다 작은 두 벡터의 inner product는 언제나 0보다 크기 때문이다. 따라서 input vector에 orthogonal한 plane을 그리고, 그 plane을 기준으로 weight vector가 올바른 곳에 존재하는지 그렇지 않은지 간단하게 알 수 있을 것이다. 다음에는 correct answer가 0인 경우 (-1인 경우)를 살펴보자. 이 경우에는 두 벡터의 사이 각이 90도보다 커야하므로, input vector에 orthogonal한 plane의 반대 부분이 올바른 weight vector의 위치가 됨을 알 수 있다. 그렇다면 올바르지 않은 (misclassified된) weight vector를 올바른 영역으로 옮기기 위해서 어떤 행동을 취할 수 있을까? 조금만 생각해보면 정말 간단한 vector sum으로 hyperplane의 반대쪽으로 보낼 수 있다는 것을 알 수 있다. 왼쪽 상황에서는 빨간 벡터를 초록 벡터로 만들기 위해서 간단하게 빨간 벡터에 파란 벡터를 대해주면 되고 ($w_{t+1} = w_t + v$) 오른쪽 경우는 빼주면 된다 ($w_{t+1} = w_t - v$). 이런 이유로 벡터를 더하고 빼는 것 만으로 weight가 '개선'되었다고 할 수 있는 것이다. 만약 weight들이 올바르게 learning되었다면 우리는 아래와 같은 결과를 얻게 될 것이다.</p>
<p><img src="/images/post/40-6.png" width="300"></p>
<p>즉, 올바른 weight는 서로 다른 input vector들이 모두 well-classified되게하는 어떤 vector임을 알 수 있다. Training을 하면서, 우리가 찾아내는 값은 바로 가장 올바른 weight vector를 찾는 것이며, 위의 그림에서 볼 수 있듯 우리는 space 위에 여러 hyperplane을 그릴 수 있고, 이를 이용하여 good weight들이 위치하는 hypercone을 그릴 수 있다. 재미있는 점은, 이 cone위의 vector는 convex하다는 것이다 (그 어떤 벡터 두 개를 골라도 그 중간에 존재하는 모든 벡터들이 cone안에 존재한다) 즉, 우리가 만약 이 문제를 convex하게 해결한다면 항상 우리는 global optimum값을 찾을 수 있게 되는 것이다.</p>
<h3>Why the learning works</h3>
<p>위에서 geometric view로 perceptron을 서술하였으니, 이번에는 도대체 왜 이런 알고리듬이 작동하는지 알아보도록 해보자. 사실 엄밀한 수학적 증명이 강의에 나오지 않기 때문에 복잡한 증명은 생략하고, 간단하게 그림으로 설명해보도록 하겠다. 일단 아래 그림을 보면서 진행해보도록하자.</p>
<p><img src="/images/post/40-7.png" width="500"></p>
<p>아래 그림의 상황은 current weight vector와 any feasible한 weight vector 사이의 거리 $d_a^2+d_b^2$을 고려해보도록 하자. 만약 이런 상황에서 perceptron이 misclassified된다면, learning 알고리듬이 current vector를 조금 더 feasible한 weight vecotr에 가까워지도록 움직여줄 것이다. 하지만 문제가 생기는데, 거의 plane에 근접하게 있는 point를 생각해보자. 이 그림에서는 노란색 점이 그것이다. 이 점은 분명 조금 더 "feasible vector"에 가깝게 움직여질 필요성이 있지만, 노란색 점은 이미 feasible region 위에 위치하기 때문에 아무리 알고리듬이 running하더라도 절대로 feasible point 근처로 옮겨지지 않는 것이다. 이런 문제점을 해결하기 위해서 'margin'이라는 컨셉이 도입된다.</p>
<p><img src="/images/post/40-8.png" width="300"></p>
<p>위의 그림에는 margin이라는 것이 표현되어 있는데, 이 margin은 feasible한 weight vector를 조금 더 strict하게 정해주는 역할이다. 즉, feasible region을 plane에서 margin 보다 더 멀리 떨어진 위치로 정의하고, 이 region안에 존재하는 vector를  "generously feasible"한 weight vecotr로 정의하는 것이다. 즉, 이제는 노란색 vector가 margin보다 더 조금 떨어져 있기 때문에 더 이상 "feasible"한 vector가 아니므로 perceptron algorithm을 사용하여 이 벡터를 옮기는 것이 가능해지는 것이다.</p>
<p>이런 가정하에, 이 알고리듬이 converge한다는 것이 증명가능하다고 하는데, 구체적인 증명과정은 강의에 설명되어있지는 않고, 간단한 아이디어만 서술되어있다. 그 아이디어는 크게 세 개인데, perceptron이 feasible region에 존재하지 않는 weight vector를 update하고, update마다 missclassified vector와 feasible vector사이의 distnace가 감소되는 방향으로 update가 될 것이다. 또한 이 거리는 매 번 최소한 input vector의 lenght의 제곱근만큼은 감소한다는 것이다. 따라서 유한한 숫자의 iteration안에 weight vector가 반드시 feasible region안에 위치하게 된다는 것이다. 물론 이 모든 것은 그러한 feasible region이 존재하는 경우에만 동작하는 것은 당연할 것이다.</p>
<h3 id="what-perceptrons-cant-do">What perceptrons can't do</h3>
<p>하지만 perceptron은 너무나도 명확한 한계점이 존재한다. input vector가 binary이기 때문에 모든 input을 binary feature로 바꾸어야한다는 점도 문제이지만, 가장 큰 문제는 linearly separable하지 않은 dataset들은 learning할 수가 없다는 것이다. 엄청나게 간단한 예를 살펴보도록하자. xor은 binary 연산의 가장 기본적인 연산 중 하나이다. 두 값이 같으면 0, 다르면 1을 return하는 것인데, 이를 2차원 평면에 포함하면 아래와 같은 상황이 되어버린다.</p>
<p><img src="/images/post/40-9.png" width="300"></p>
<p>초록색 label이 된 점들이 output이 0인 점들, 빨간색 점들은 ouput이 1인 점들이다. 당연하게도, 이 점들을 구분할 수 있는 '단 하나의' plane은 존재하지 않는다. 단순히 이 결과만 보더라도 perceptron이 얼마나 제한적인 상황에 대해서만 동작하는지 분명하게 알 수 있다. 또한 perceptron의 decision making은 summation으로 이루어지기 때문에, 만약 n 차원 벡터의 패턴이 아래와 같으면 구분이 불가능한 것이다</p>
<p><img src="/images/post/40-10.png" width="300"></p>
<p>pattern A는 점들의 set이 1, 1, 2로 존재해야하고, pattern B는 2, 2로 존재해야하는데 둘 다 합이 4이기 때문에 perceptron으로는 이를 구분하는 것이 불가능하다.</p>
<p>이렇듯 perceptron은 그 한계가 너무나 명확하다. 그러나 이는 single layer perceptron에 한정된 문제이지 neural network 전체의 문제는 아니다. 이를 해결하는 방법은 생각보다 간단한데, 바로 hidden unit을 learning하는 것이다. multiple hidden layer는 neural network가 더 이상 linear하지 않고 non-linear하게 해주는 역할을 하는데, non-linear해지기 때문에 learning하기가 힘들어지지만, 만약 learning이 가능하다면 그 만큼 powerful해지는 것이다. 그렇다면 이런 net을 learning하는 것은 가능할까? 결론부터 얘기하자면 엄청나게 어렵다. 때문에 이에 대한 연구가 활발히 이루어지고 있으며 꽤 성공적인 결과들이 존재한다. 또한 hidden layer의 weights를 learning하는 것은 feature를 learning하는 것과 같아지기 때문에 더 이상 feature에 대한 문제도 없어지고, 여러모로 hidden unit을 learning하면 그 한계를 깰 수 있는 network가 될 수 있는 것이다.</p>

<h3>Coursera Neural Networks for Machine Learning</h3>
<p>다른 요약글들 보기 (<a href="http://SanghyukChun.github.io/blog/categories/cousera-nn/">카테고리로 이동</a>)</p>
<ul>
	<li>Lecture 1: <a href="http://SanghyukChun.github.io/39">Introduction</a></li>
	<li>Lecture 2: <a href="http://SanghyukChun.github.io/40">The Perceptron learning procedure</a></li>
	<li>Lecture 3: <a href="http://SanghyukChun.github.io/42">The backpropagation learning proccedure</a></li>
	<li>Lecture 4: <a href="http://SanghyukChun.github.io/43">Learning feature vectors for words</a></li>
	<li>Lecture 5: <a href="http://SanghyukChun.github.io/43">Object recognition with neural nets</a></li>
	<li>Lecture 6: Optimization: How to make the learning go faster</li>
	<li>Lecture 7: Recurrent neural networks</li>
	<li>Lecture 8: More recurrent neural networks</li>
	<li>Lecture 9: Ways to make neural networks generalize better</li>
	<li>Lecture 10: Combining multiple neural networks to improve generalization</li>
	<li>Lecture 11: Hopfield nets and Boltzmann machines</li>
	<li>Lecture 12: Restricted Boltzmann machines (RBMs)</li>
	<li>Lecture 13: Stacking RBMs to make Deep Belief Nets</li>
	<li>Lecture 14: Deep neural nets with generative pre-training</li>
	<li>Lecture 15: Modeling hierarchical structure with neural nets</li>
	<li>Lecture 16: Recent applications of deep neural nets</li>
</ul>
]]></content>
  </entry>
  
</feed>
