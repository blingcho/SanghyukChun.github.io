
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>빅데이터 이야기: 데이터 수집에서 분석까지 - README</title>
  <meta name="author" content="Sanghyuk Chun">

  
  <meta name="description" content="Big Data기술이란 무엇이며 왜 중요한지 그리고 앞으로 어떻게 진행이 될 것인가에 대한 내 생각을 간략히 적은 포스트">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://SanghyukChun.github.io/21">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/layout480.css" media="only screen and (max-width : 500px)" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="README" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
	<script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/bootstrap.js" type="text/javascript"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">



<script>
$(function() {
	$('.tip').attr('data-toggle','tooltip');
	$('.tip').attr('data-placement','top');
	$('.tip').tooltip();
});
</script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42711199-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  
  <div id="main">
  	<header role="banner"><hgroup>
  <h1><a id="blog-title" href="/">README</a>
  
    <span>&nbsp;&nbsp; SanghyukChun's Blog</span>
  
  </h1>
</hgroup>

</header>
  	<nav role="navigation"><ul class="main-navigation list-inline">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="http://sanghyuk.kaist.ac.kr/aboutMe/">About Me</a></li>
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
</ul>

</nav>
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">빅데이터 이야기: 데이터 수집에서 분석까지</h1>
    
    
      <p class="meta text-right mB50">
        








  


<time datetime="2013-11-19T18:06:00+09:00" pubdate data-updated="true">Nov 19<span>th</span>, 2013</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>빅데이터란 말 그대로 데이터의 양이 엄청나게 많은 것을 의미한다. 이때 빅데이터라고 불릴 정도로 데이터의 양이 많으려면 <a class="red tip" title="Peta Byte">PB</a> 정도의 데이터가 필요하다. 우리에게 친숙한 TB 단위는 빅데이터라고 언급하기에는 좀 작은 편이다. 이 PB라는 단위가 도대체 얼마나 큰 단위이냐하면.. 그야말로 어마어마하다. 1PB는 1,000TB이고, 1,000TB면 1,000,000GB이다. 이는 <a class="red tip" title="정확하게 말하면 Computer world에서는 10진법이 아니라 2진법을 사용하기 때문에 1000씩 곱해지는 것이 아니라 1024씩 곱해져야한다. 그러니깐 1024*1024*1024=1073741824MB가 된다.">1,000,000,000MB</a>라는 도대체 감도 오지 않을 정도로 거대한 값이 된다. 조금 친숙한 단위로 바꾸어서 생각해보자. 일반적으로 3분 남짓한 고음질 MP3 파일이 약 10MB정도 된다. 이를 1PB에 대해 동일한 비율로 계산해보면 300,000,000분 즉, 570년 이상의 재생 시간을 가지는 무지막지하게 거대한 음악파일이 된다. 이 정도면 조금 감이 잡히려나?</p>


<p>이제 데이터가 중요한 것은 누구나 알고 있다. <a href="http://forumblog.org/2012/02/the-2012-top-10-emerging-technologies/">세계 경제 포럼 2012년 Global Emerging Technology</a>에도 <a class="red tip" title="본문에는 Informatics for adding value to information라고 적혀있는데, 사실 Big Data라는 말은 그 출처가 불분명한 모호한 용어이다. 사실 이는 단순히 데이터가 많이 있음을 의미하는 말이며, 그 안에서 의미를 분석하는 기술은 informatics, data mining등으로 부른다. 이 글에서는 빅데이터를 앞에서 정의한대로 데이터의 양이 많음으로 정의하고, 빅데이터를 수집하는 방법과 분석하는 방법에 대해 설명할 것이다.">데이터 분석이 당당히 1위를 차지하고 있다.</a> 그러나 실제 그 중요한 데이터를 활용하는 사람들은 많지 않다. 데이터를 활용해 비즈니스 정보를 도출해내는 것이 기술적으로 굉장히 어렵고 고난이도의 도전을 요구하기 떄문이다. 구체적으로 말하자면 크게 두 가지 측면에서 문제가 된다. 하나는 그 많은 데이터를 어디에, 그리고 어떻게 저장할 것이냐라는 문제, 두 번째는 그렇게 모은 데이터를 어떻게 분석하고, 어떻게 더 빠르고 정확하게 분석하느냐라는 이슈가 있다. 지금 흔히 빅데이터라고 불리는 기술은 사실 빅데이터 저장 기술, 그리고 빅데이터 분석 기술 이렇게 크게 두 가지가 혼용되서 언급이 되고 있는 것이다. 이 글에서는 Big data storage technology와 Big data analysis technology란 무엇이고, 내가 연구 혹은 개발했던 경험들에 기반하여 내 개인적인 코멘트를 할 생각이다.</p>


<h3>Big Data Storage</h3>


<p>데이터 저장은 두 가지 측면에서 Challenge하다. 먼저, 들어오는 데이터가 너무 많은 경우에는 이 데이터를 저장하는 행위 자체가 어려울 수 있다. 또한 저장한 데이터의 분석을 용이하게 하기 위해서 어떤 Data structure를 가져갈 것인지에 대해서도 고민이 필요하. 둘 다 쉬운 문제는 아니며 최근 관련 연구가 활발하게 진행되고 있는 분야이다.</p>


<p>데이터가 엄청나게 많아져서 계속 저장해야하는 양 자체가 너무 늘어나게 되면, 그 데이터를 아무 preprocessing없이 저장하는 일 조차 엄청나게 어렵다. Facebook을 예를 들어보자. 현재 Facebook을 사용하는 유저는 세계적으로 10억명이 넘는다. 이 사람들 중에서 동시 접속을 10%만 한다고 생각해도 1억 명이고 이 사람들이 Timeline에서 like나 comment 혹은 post를 평균 1분에 한 번씩 한다고 해도 자그마치 1분에 1억 번의 traffic을 감내해야한다. 이게 얼마나 큰 값이냐하면, 만약 한 Packet당 크기를 편의상 1kByte라고 한다고 하면 매분 1천억Byte, 혹은 100TB의 Packet이 Facebook Data center로 흘러들어오는 것이다. 이렇게 되면 Server side에서 logic처리만 하더라도 전체 리소스가 부족한데 거기에 로깅까지 하려면 정말 엔지니어 입장에서는 그야말로 미쳐버릴 노릇이 되어버린다.</p>


<p>이렇게 Real-Time으로 어마어마한 데이터를 Capture하고 Storing하는 것이 가장 어려운 이유는, 실제 Disk에 작성을 할 때 Disk의 Bandwidth가 Network Bandwidth보다 훨씬 작기 때문이다. 네트워크가 maximum으로 들어온다고 가정했을 때 보통 <a class="red tip" title="1 Giga bit per s 즉, Byte로 환산하면 약 1-200 MB/s가 된다">1G</a> 정도를 상한선으로 잡으니 우리도 네트워크 인풋이 1Gbps라고 가정해보자. 1Gbps는 125MBps와 같은 값이니 1초에 125MB의 데이터가 들어오는 셈이다. 반면 일반적인 HDD의 쓰기 속도는 100MB/s가 되지 않는다. 결국 초당 1G의 data가 들어오게 된다면 하나의 하드디스크로만 사용하여 데이터를 저장하는 것이 어렵다. 이는 하드웨어의 한계이기 때문에, 더 좋은 하드웨어를 사용하거나 (예를 들어 SSD는 HDD보다 읽기 쓰기 속도가 훨씬 빠르다), 소프트웨어로 하드웨어를 여러 개 사용해 Scalability를 높이도록 설계하는 방법 밖에 없다. 당연히 아직 하드웨어를 업그레이드하는 것은 매우 비싸고, 데이터 속도가 더 빨라지면 다시 하드웨의 한계에 언젠가 부딪힌다는 문제가 있다. 물론 돈만 있다면 가장 간단한 해결방안이다. 그보다 더 일반적인 해결방안은 소프트웨어를 사용해 Scalability를 높이는 것이다. Multi-threading Programming을 통해 연산해야하는 계산량을 분산하고 굉장히 latency가 큰 disk I/O를 따로 처리할 수 있는 것이다. Multi Machine으로 확장하는 가장 쉬운 방법은 Map-Reduce를 사용하는 것이다. Map-Reduce는 functional language의 map operation과 reduce operation에서 따온 이름인데, 실제 functional language에서 사용하듯 operation을 여러 개의 작은 operation으로 나누어 각각의 머신에서 처리하고 다시 이 작은 operation들을 한 머신에서 취합하는 방식이다. 물론 실제로 이를 적용하기에는 많은 문제점이 있다. Overhead가 어디이며 얼마나 많은 데이터를 처리할 수 있을 것인가, multi-threading program은 보통 1개의 머신에서 작동하도록 설계가 되는데 더 분산 설계를 많이 고려해서 multiple machine에서도 동작할 수 있도록 설계를 할 수 있는가, 만약 각각의 연산 unit이 한 번에 처리할 수 있는 capacity가 달라서 load balancing이 성능 뿐 아니라 corectness에 또한 중요한 요소가 되는 상황에 과연 적절한 load balancing 설계가 가능한가 등의 문제가 생길 수 있을 것이다. 모두 절대 간단한 질문이 아니며 System에 대한 조예가 깊어야 해결할 수 있는 문제가 많다. 대부분의 경우 데이터를 계속 기록하다가 이렇게 하드웨어의 한계에 도달하는 경우 이를 확장하지 못해 더 이상 기록하는 것을 포기하거나 아니면 일부만 기록하는 경우가 허다하다.</p>


<p>단순히 데이터를 저장만 하는 것도 어렵지만 사실 데이터를 어떤 format으로 저장하느냐 역시 중요하다. 아무 의미 없어보이는 불규칙한 데이터를 분석하는 것과 이미 대략적으로 entry를 가지고 있고 분류가 되어있는 데이터를 분석하는 것은 큰 차이가 있다. 예를 들어서 &#8216;ㅇㅇㅇ 고객은 ㅁㅁ대학교에 재학 중인 대학생이며 한달 평균 지출액은 약 10만원 정도이며 이와 비슷한 다른 고객들은 대략 5만원을 사용하는 것을 고려해보았을 때 ㅇㅇㅇ 고객은 우리가 중요하게 생각해야하는 고객이다&#8217; 라는 raw text data를 저장하는 것과, {이름: ㅇㅇㅇ, 직업: 대학생, 직업_세부사항: ㅁㅁ대학교, 한달 지출액: 10만원} 의 key-value format으로 저장하는 것이 분석하기가 훨씬 편할 것이다. 여러 format을 사용할 수 있으나, 대표적으로 떠올릴 수 있는 형태는 예시로도 들었던 key-value storage일 것이다. 만약 우리가 분석해야하는 데이터가 정형화되어있고, 분석 역시 일부 데이터에서만 하게 된다면 key-value storage는 매우 좋은 선택이 될 것이다. 그러나 데이터 logging이라는 특성을 고려해본다면 항상 key-value가 좋기만 한 것은 아니다. logging은 상황에 따라 format이 바뀔 수 있다. 예를 들어서 {이름: ㄴㄴㄴ, 직업: 회사원, 한달 지출액: 20만원, 주 관심 카테고리: 차량} 등의 형태로 형태가 변화할 수도 있다. (이 경우는 주 관심 카테고리가 추가되었다) 만약 MySQL 등의 strict한 key-value storage라면 매번 entry를 추가해야한다. 만약 갑자기 로깅 skeme을 변경하겠다는 결정이 내려지면 MySQL을 사용하고 있던 서비스는 새로운 DB를 생성해야만 할 것이다. 이런 문제점을 방지하기 위해서 NoSQL이라는 것이 등장했고 MongoDB, Redis, Cassandra 등이 이에 속한다. 자세한 내용은 나중에 한번쯤 다뤄보도록 하겠다. NoSQL을 사용하면 SQL보다 유연하게 formatting을 할 수 있고 조금 더 분산환경에 적합하다. 아무튼 생각보다 데이터를 formatting하는 것이 어렵다. 가장 큰 이유는 데이터를 기록하기 시작할 때 부터 어떤 분석이 필요할 것이라고 예측하는 것이 쉽지 않기 떄문이다. 구글이 검색어 로그를 수집할 때 해당 검색어가 독감 지도가 되고 대선 지표가 될 것이라고 예측할 수 있었을까? 아마 아닐 것이다. 빅데이터의 가장 큰 아름다움은, 아무 의미없고 연관성 없어보이는 여러 사실들이 데이터를 통해서 얽히고 섥혀 한 순간에 모든 사실을 데이터가 꿰뚫는 순간인 것이다. 이런 순간을 미리 예측한다는 것은 거의 불가능에 가깝다. 이 분야는 내 주요 관심분야도 아니고, 내가 많이 해본 적은 없지만, 내가 알기로는 점점 strict한 format은 줄어들고 보다 유연하고 쉽게 바꾸기 쉬운 형태의 format으로 옮겨가고 있는 추세로 알고 있다. 그만큼 데이터가 어떤 방향으로 변할지 예측하는 것이 어렵다는 것이다.</p>


<p>우리는 이제 사방에 데이터가 넘쳐나는 환경에 살고 있어서 데이터라는 것을 얕잡아보기 쉽지만, 이 데이터의 양이 무지막지해지면 데이터를 저장하고 적절한 formatting을 하는 것만으로도 수 많은 기술적 challenge를 요구한다. 하지만 사실 우리가 관심있는 부분은 데이터를 저정하는 것이 아니라 데이터를 분석하는 것이다. 다음 paragraph부터는 실제 데이터를 분석하는 방법들과 예시들에 대해 얘기해보겠다.</p>


<h3>Big Data Analysis</h3>


<p>&#8216;구슬이 서말이어도 꿰어야 보배다&#8217; 빅데이터 분석과 가장 잘 어울리는 속담이 아닐까? 아무리 데이터를 많이 가지고 있어도 그 데이터를 분석하지 못한다면 아무런 의미가 없다. 데이터를 분석하는 여러가지 방법이 존재하지만, 이 글에서는 주로 내가 공부하고 있는 Machine Learning을 중심으로 설명하려고 한다. 다른 방법들에 대해서는 내가 잘 알지 못하고 데이터가 많은 경우에 잘 동작하지 않는 등 제한된 조건에서만 동작하는 방법이 많기 때문이다.</p>


<p>그러면 Machine Learning이란 무엇인가? 마치 사람이 새로운 학습 정보를 받아들여 자신의 행동을 개선하듯, 머신이 데이터를 통해 decision making을 더 개선해나가는 과정을 의미한다. <a href="http://ko.wikipedia.org/wiki/%EA%B8%B0%EA%B3%84_%ED%95%99%EC%8A%B5" taget="new">위키</a>를 참고해서 말하자면 머신러닝은 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발하는 분야를 말한다. 더 자세한 내용은 <a href="/3">이전에 내가 정리한 글</a>을 참고하길 바란다. (참고로, Data mining이라는 용어도 존재하는데, 내가 앞으로 설명하려는 내용과 거의 일치한다. 사실 Data Mining은 데이터에서부터 의미를 캐내는-mining하는-모든 것을 통틀어서 말하는 것이며, 대부분의 경우 Machine Learning Technology를 사용해서 분석을 하는 경우가 많다. 때문에 이 글에서는 딱히 그 둘을 구분하지 않고 혼용해서 적도록 하겠다.) 그렇다면 머신러닝이 데이터 분석에 어떤 식으로 기여할 수 있을까? 머신러닝을 사용하면 데이터의 패턴을 파악하는 것이 가능해진다. 다시 말해서 내가 알고 있는 정보를 사용해서 내가 모르는 정보를 얻을 수 있다는 의미이다. 간단한 예를 들어보자, 만약에 아래와 같은 데이터가 있다고 가정해보자.</p>


<p><img src="/images/post/14-1.png" width="400"></p>

<p>음.. 쉽게 생각해서 가로축은 내가 게임에서 사용한 돈의 액수를 의미하고, 세로축을 그 게임에서 내가 가지고 있는 좋은 아이템의 개수라고 생각해보자. 아마 돈을 많이 쓸 수록 좋은 아이템을 많이 가지게 될 것이다. 그렇다면 내가 돈을 11만큼 썼을 때 내가 얼마나 많은 아이템을 얻을 수 있을까? 위의 데이터를 토대로 추정해보자면 아마 약 11에 근접한 값을 얻게 될 것이다. 머신러닝은 이런 방식으로 주어진 정보만을 토대로 아직 알고있지 못한 정보를 추정하게 된다. 자 이제 대략적인 설명은 충분한 것 같다. 그렇다면 실제 이렇게 머신러닝을 사용해서 데이터를 분석하고 있는 예시는 무엇이 있을까?</p>


<p></p>

<p>미국에 Netflix라는 기업이 있다. 이 기업에서 제공하는 주요 서비스는 영화와 관련된 서비스 들이다. 시작은 1997년 시작한 DVD 대여 사업에서부터 시작했지만, 지금은 북미에서 스트리밍되는 대부분의 영화를 독식하고 있는 어마어마하게 거대한 기업이다. 실제로 지금 미국에서 발생하는 트래픽의 25%가 Netflix에 의해서 생겨난 트래픽이라고 하니, 이 기업이 얼마나 사람들에게 영향을 미치고 있는지 알 수 있을 것이다. 이 기업이 거대하게 성장하게 된 배경에는 &#8216;추천&#8217;이라는 시스템이 자리잡고 있다. 이 추천 문제는 사실 Machine Learning에서 상당히 중요하게 다뤄지는 문제 중에 하나이다. 추천이라는 것을 사용자의 다른 정보들을 사용하여, 아직 밝혀지지 않은 사용자의 기호를 추정하는 문제로 생각하면 Machine Learning 기법을 사용하여 문제를 해결하는 것이 가능하기 때문이다. Netflix는 이런 접근 방식을 통해 실제 Big Data와 Machine Learning을 사용한 가장 성공적인 사례로 손꼽히는 기업이다. Netflix에서는 영화를 대여하거나 시청하게 되면 자동으로 관련되거나 사용자가 관심있어할만한 영화를 자동으로 추천해준다. 특히 Netflix에서는 영화를 scoring하는 것이 가능한데, 과거에 내가 점수를 매겼던 history를 기반으로 하여 새로운 영화에 내가 몇 점을 매길 것인지를 꽤 정확한 확률로 추천해준다. 내가 해리포터와 마법사의 돌, 해리포터와 비밀의 방, 그리고 해리포터와 아즈카반의 죄수라는 영화를 재미있게 봤다면 내가 해리포터와 불의 잔이라는 영화를 좋아할 가능성이 높다고 추천해주고, 이런 추천을 통해 사용자들의 추가적인 과금을 유도하는 형식이다. 이런 방식의 추천 시스템은 아마존 등에도 적용이 되어있으며 마찬가지로 매우 효과적인 결과를 얻고 있다고 한다. 이런 추천 시스템을 구축하기 위해서 Netflix는 엄청나게 복잡하고 많은 머신러닝 기법들을 사용한다. 이 시스템은 2006년 Netflix prize라는 이름으로 추천 시스템의 성능을 향상시키는 대회가 열렸는데, 이 대회에서 우승을 했던 시스템이 기반이 되어 만들어졌다. Netflix prize에 대해서는 조만간 글을 쓸 예정이므로 여기에서는 자세한 언급은 피하도록 하겠다. 마찬가지로 이 대회에서 우승을 한 알고리듬을 자세히 설명하는 것도 다른 글에서 다룰 수 있도록 하겠다. 중요한 것은 Netflix에서 상당히 높은 수준으로 추천이 되는 영화들이 사람이 인위적으로 작성한 리스트에 따라서 추천이 되거나 하는 것이 아니라, 온전히 Machine Learning Technology를 사용하여 추천을 하고 있다는 것이다. Netflix는 흩뿌려져 있는 것 처럼 보이는 데이터를 수집해서 그 데이터에서 의미있는 결과를 도출하고 그 결과를 통해 실제로 돈을 벌 수 있다는 것을 보여주는 아주 좋은 예시이다. (한국에서 <a href="http://watcha.net">왓챠</a>라는 유사한 서비스가 있다. 카이스트 선배님이 CEO로 계신 회사인데, 이 서비스도 상당히 좋은 서비스이니 관심있다면 한 번쯤 이용해보는 것도 재미있을 것이다.)</p>


<p>오바마 대통령의 재선 캠프에 있었던 데이터 분석팀 역시 빅데이터를 잘 활용한 좋은 예시로 손꼽힌다. 미국은 정말 많은 인종과 사람들이 존재하는 나라이다. 그리고 국토도 <a title="미국 9,826,675제곱킬로미터, 남한 99,720제곱킬로미터" class="red tip">남한의 98배가 넘을 정도로</a> 워낙 방대하기 때문에 한정된 시간동안 많은 사람들을 대상으로 하는 대선운동을 하는 것이 쉽지 않다. 우리나라에서 대선을 하는 동안에도 어느 지역에 어떤 자원을 투자하느냐가 이슈가 되는데, 하물며 우리보다 거의 100배나 거대한 미국에서는 어떠하겠는가? 우리나라도 지역별로 선호하는 후보나 당이 분명하게 구분이 되는 것처럼 미국도 지역별로 공화당 혹은 민주당 중에서 더 선호되는 당이 다르다. 하지만 남한 만큼 거대한 주가 51개 주 중 37개에 달하는 만큼, 우리나라처럼 지방 하나가 거의 동일한 색채를 띄고 있지 않다. 또한 우리나라는 인구 밀집도가 특정 지역이나 도시에 몰려있는 반면, 미국은 인구 밀집도가 많이 낮은 편이다. 때문에 직접 선거 운동을 할 수 있는 지역은 극히 제한된다. 오바마 선거 운동팀은 그 동안 근사적으로만 접근하던 모든 데이터를 수치화하고 그 값을 바탕으로 효율적인 자원분배를 이뤄냈다. 오바마 캠프의 데이터 분석팀이 가장 먼저 한 일은 현재 자세히 분류되어있지 않은 유권자들을 투표성향, 성별, 인종 등으로 나누어 새로운 유권자 명부를 작성한 것이다. 이렇게 작성된 명부를 바탕으로 하여 micro targeting이 이루어졌다. 강한 민주당 지지자이며 투표를 할 사람들, 강한 민주당 지지자이지만 투표를 하지 않을 사람들, 약한 민주당 지지자, 약한 공화당 지지자, 강한 공화당 지지자&#8230; 등의 분류를 하고, 각 분류별로 각기 다른 전략을 세워 유권자를 끌어모았다. TV광고도 단순히 사람들이 많이 볼 것으로 예상되는 시간에 편성하는 것이 아니라, 지역별로 사람별로 적당하다고 생각되는 채널에 광고를 편성하였다. 이전에는 사람들이 많이 보는 뉴스나 스포츠 경기에 광고를 하는 방식으로 홍보를 했다면, 이제는 특정 지역의 특정 계층의 사람들에게 타겟 광고를 하는 방식으로 바뀐 것이다. 예를 들어서 캘리포니아의 30대 여성들을 공략하기 위해 해당 계층이 가장 많이 보는 프로그램에 광고를 내보내는 것이다. 이는 선거 자금 모금 운동에도 동일하게 적용되었는데, 2012년 5월 조지 클루니의 자택에서 열린 선거 자금 모금 운동이나, 그로부터 한 달 뒤에 세라 제시카 파커(섹스 앤 더 시티의 출연자 중 하나)의 집에서 벌인 모금 운동 모두 40대 여성들을 겨냥한 데이터 팀의 분석 결과로부터 도출된 전략이었다. 또한 전화 선거 운동을 할 때에도 데이터 분석을 통해 사람들을 분류하고, 오바마를 지지할 가능성이 없는 사람들은 과감히 버리고 오바마를 지지할 가능성이 존재하거나, 오바마를 지지하지만 투표를 하지 않는 사람들을 중심으로 전화를 걸어서 맷 롬니 진영보다 훨씬 효율적으로 선거운동을 할 수 있었다. 이 밖에도 선거 운동을 하는 사람들을 위한 소프트웨어나 지속적인 모의 투표, 트래픽 폭주 상황에 대비한 Plan B 수립 등 데이터 팀이 오바마 캠프에 미친 영향은 지대하였다. 결국 오바마 캠프는 &#8216;데이터의 승리&#8217;라고 불릴 정도로 성공적인 데이터 분석 사례로 손꼽히게 되었다.</p>


<p>이렇듯 Machine Learning은 데이터를 분석하는 방법 중에서 가장 많이 쓰이고 가장 각광받는 방법이다. 하지만 이것은 어디까지나 접근 방법에 대한 문제이고, 이런 알고리듬을 구현하고 적용하기 위해서 필요로 하는 기술들은 정말 많다. 특히 가장 필요로 하는 기술 중 하나는 parallel programming 혹은 distributed programming인데, 쉽게 생각하면 한 연산을 하나의 머신에서 처리하는 것이 아니라 여러 개의 분산된 머신에서 병렬적으로 이를 처리하는 방식이다. 앞서 설명했던 것과 같이 이런 기술이 필요한 이유는 간단하다. 머신 하나의 연산 처리 속도가 우리가 요구하는 연산 처리 속도보다 훨씬 느리기 때문에 software를 사용해 hardware의 기능을 확장해서 사용하는 것이다. 데이터 분석을 위해 현재까지 가장 많이 쓰이는 기술을 꼽자면 Hadoop과 Map-Reduce를 꼽을 수 있을 것이다. Map-Reduce는 앞에서 잠깐 언급했듯 연산을 여러 개의 분산되어있는 머신에게 분할해서 각자 연산을 따로 하게 하고, 그 결과를 다시 합쳐주는 방식이다. 현재 Google에서 개발한 Google Map-Reduce가 가장 많이 쓰이고 있다. 하둡은 일종의 파일시스템인데, 오픈 소스이기 때문에 많은 개발자들이 즐겨 사용하고 있다. 하둡 분산 파일시스템이 만족하는 요구사항이 몇 가지가 있는데, 분산 환경에서는 여러 개의 컴퓨터가 연합하여 연산을 수행하기 떄문에, 이 중 몇 개의 머신이 고장이 나더라도 전체 시스템에 문제가 생기지 않도록 빠른 복구를 요구하고, 자료 자체는 저장이 된 이후 (일반적으로) 다른 머신으로 옮겨가지 않기 때문에 데이터가 옮겨지는 것 보다 연산이 옮겨가는 것이 더 빠르게 설계하는 등의 요구사항을 만족하고 있다. 자세한 내용은 <a href="http://ko.wikipedia.org/wiki/%ED%95%98%EB%91%A1">하둡 위키</a>를 참고하길 바란다.</p>


<p>데이터 분석은 데이터가 존재하는 모든 곳에서 적용가능한 발전 가능성이 무궁무진한 기술이라고 할 수 있다. Netflix라는 기업에서부터 미국 대선에 이르기 까지 실제로 이를 요구하는 기업이나 단체도 매우 많으며 또한 좋은 결과를 달성하고 있다. 이 밖에도 정말 많은 예시들이 있지만 이미 충분히 글이 길어진 것 같아서 이 쯤에서 줄이도록 하겠다.</p>


<p>이렇게 간략하게나마 빅데이터를 수집하는 방법과 분석하는 방법에 대해서 다루어보았다. 생각보다 글이 길어지기는 했지만, 내가 알고 있는 빅데이터에 대한 개념과 실제 적용을 할 때 생기는 문제점들 그리고 실제 해당 기술들을 적용해 성공적으로 운영하고 있는 예제들도 간략하게나마 살펴보았다. 분명 데이터는 미래에 점점 더 중요한 자원이 될 것이며, 이 자원을 확보하기 위한, 그리고 확보한 자원에서 정보를 뽑아내기 위한 싸움이 치열하게 벌어질 것이다. Machine Learning을 연구하고 있는 사람 중 하나로써 새로 맞이하게 될 데이터 시대에서 큰 역할을 할 수 있기를 희망한다.</p>

</div>

<hr>
  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Sanghyuk Chun</span></span>

      








  


<time datetime="2013-11-19T18:06:00+09:00" pubdate data-updated="true">Nov 19<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/big-data/'>Big-Data</a>, <a class='category' href='/blog/categories/machine-learning/'>Machine-Learning</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://SanghyukChun.github.io/21/" data-via="SanghyukChun" data-counturl="http://SanghyukChun.github.io/21/" >Tweet</a>
  
  
  
    <div class="fb-like" data-send="true" data-width="380" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/26/" title="Previous Post: 게임은 정말 사회악인가? 한국 게임업계는 정말 반성할 것이 없는가?">&laquo; 게임은 정말 사회악인가? 한국 게임업계는 정말 반성할 것이 없는가?</a>
      
      
        <a class="basic-alignment right" href="/27/" title="Next Post: 캐시버타이징, 당신이 지갑을 열어야 하는 101가지 이유">캐시버타이징, 당신이 지갑을 열어야 하는 101가지 이유 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/64/">Machine Learning 스터디 (8) Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a>
      </li>
    
      <li class="post">
        <a href="/86/">블룸버그 폰 인터뷰 후기</a>
      </li>
    
      <li class="post">
        <a href="/85/">2015년 02월 27일 새벽 5시 반</a>
      </li>
    
      <li class="post">
        <a href="/82/">블로그에 Disqus 설치</a>
      </li>
    
      <li class="post">
        <a href="/81/">맥 요세미티 업데이트 이후 Homebrew 문제점 Troubleshooting</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/SanghyukChun">@SanghyukChun</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'SanghyukChun',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Sanghyuk Chun -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'sanghyukchun';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://SanghyukChun.github.io/21/';
        var disqus_url = 'http://SanghyukChun.github.io/21/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=182012898639519&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
