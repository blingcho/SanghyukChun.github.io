<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[README]]></title>
  <link href="http://SanghyukChun.github.io/atom.xml" rel="self"/>
  <link href="http://SanghyukChun.github.io/"/>
  <updated>2015-06-14T03:50:57+09:00</updated>
  <id>http://SanghyukChun.github.io/</id>
  <author>
    <name><![CDATA[Sanghyuk Chun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (14) EM algorithm]]></title>
    <link href="http://SanghyukChun.github.io/70/"/>
    <updated>2015-06-14T03:50:00+09:00</updated>
    <id>http://SanghyukChun.github.io/70</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p><a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm">EM 알고리즘</a>은 <a href="https://en.wikipedia.org/wiki/Latent_variable">latent variable</a>이 존재하는 probabilistic model의 maximum likelihood 혹은 maximum a posterior 문제를 풀기 위한 알고리즘 중 하나이다. 굉장히 많은 probabilistic 모델을 풀기 위해 널리 사용되는 알고리즘 중 하나이며, iterative한 알고리즘 중 하나이다. Clustering에서 다뤘던 GMM은 물론이고, HMM, RBM 등의 문제를 해결하는데 있어서도 사용되는 알고리즘이다. 이 글에서는 EM 알고리즘이 무엇인지, latent variable이 존재하는 probabilistic model은 무엇이며 어떤 장점이 있는지를 다룰 것이며, EM 알고리즘의 의미와 더 나아가 이 알고리즘이 어떻게 MLE나 MAP문제를 해결하는지에 대해 다룰 것이다.</p>


<h5>Probabilistic model having latent variable</h5>


<p>EM 알고리즘에 대해 다루기 전에 먼저 latent variable을 가지고 있는 probabilistic model에 대해 설명하도록 하겠다. Latent variable은 우리가 본래 가지고 있는 random variable이 아닌, 우리가 임의로 설정한 hidden variable을 의미한다. 예를 들어, 아래 그림과 같은 Grapical model을 고려해보자. 이때 우리가 관측할 수 있는 random variable은 paramter \(\theta\)로 parameterized 되어있는 \(\mathbf X\) 하나이고, \(\mathbf Z\)은 우리가 관측할 수 없는 hidden variable이라고 해보자.</p>


<p><img src="http://SanghyukChun.github.io/images/post/70-1.png" width="200"></p>

<p>만약 위의 grapical model에서 \(\mathbf X\)의 maximum likelihood를 계산하고 싶다면 어떻게 해야할까? 먼저 \(\mathbf X\)의 maximum likelihood는 다음과 같이 표현된다.</p>


<p>\[\max_{\theta} p(\mathbf X | \theta) = \sum_{\mathbf Z} p(\mathbf X,Z | \theta). \]</p>


<p>문제를 조금 더 간단하게 하기 위하여 위의 식에서 \(\mathbf Z\)는 discrete variable이라고 정의하였다. 이 문제에서 우리가 가정할 것이 하나있다. 바로 marginal distribution \(p(\mathbf X | \theta)\)를 직접 계산하는 것이 매우 까다롭다는 것이다. 이때, \(\mathbf Z\)는 우리 마음대로 정할 수 있는 latent variable이기 때문에, joint distribution \(p(\mathbf X,Z | \theta)\)가 marginal distribution보다 쉬운 \(\mathbf Z\)를 잡는 것이 가능하다.</p>


<h5>Decomposition of log-likelihood</h5>


<p>만약 우리가 latent variable \(\mathbf Z\)의 marginal distribution을 \(q(\mathbf Z)\)라고 정의한다면, 앞에서 설명한 log-likelihood를 다음과 같이 decompose할 수 있다.</p>


<p>\[\ln p(\mathbf X | \theta) = \mathcal L(q,\theta) + ~\mbox{KL}(q\|p),\]
이때, \(\mathcal L(q,\theta)\)와 \(\mbox{KL}(q\|p)\)는 다음과 같이 정의된다. \[\mathcal L(q,\theta) = \sum_{\mathbf Z} q(\mathbf Z) \ln \frac{p(\mathbf X, \mathbf Z | \theta)}{q(\mathbf Z)} ~\mbox{and}~ \mbox{KL}(q\|p) = - \sum_{\mathbf Z} q(\mathbf Z) \ln \frac{p(\mathbf Z | \mathbf X, \theta)}{q(\mathbf Z)}. \]</p>


<p>위의 식에서 \(\mathcal L(q,\theta)\)는 hidden variable \(\mathbf Z\)의 marginal distribution \(q(\mathbf Z)\)의 functional이고, \(\mbox{KL}(q\|p)\)는 \(q,p\)의 KL divergence를 의미한다. 이렇게 log-likelihood를 decompose하게 되면, 한 쪽에는 random variable \(\mathbf X, \mathbf Z\)의 joint distribution, 그리고 또 한 쪽은 conditional distribution으로 표현이 된다는 것을 알 수 있다. 또한 KL divergence의 특성에서부터 재미있는 사실을 하나 더 유추할 수 있는데, 바로 KL divergence가 반드시 0보다 크거나 같기 때문에 \(\mathcal L(q,\theta)\)이 곧 log-likelihood의 lower bound가 된다는 사실이다. 이를 그림으로 나타내면 아래 그림의 오른쪽 그림과 같다. (일단 \(theta^{\mbox{old}}, theta^{\mbox{new}}\)는 무시하자)</p>


<p><img src="http://SanghyukChun.github.io/images/post/70-2.png" width="500"></p>

<h5>EM algorithm</h5>


<p>위와 같은 사실로부터 lower bound가 maximum이 되도록하는 \(\theta\)와 \(q(\mathbf Z)\)의 값을 찾고, 그에 해당하는 log-likelihood의 값을 찾는 알고리즘을 설계하는 것이 가능할 것이다. 만약 \(\theta\)와 \(q(\mathbf Z)\)를 jointly optimize하는 문제가 어려운 문제라면 이 문제를 해결하는 가장 간단한 방법은 둘 중 한 variable을 고정해두고 나머지를 update한 다음, 나머지 variable을 같은 방식으로 update하는 alternating method일 것이다. EM 알고리즘은 이런 아이디어에서부터 시작하게 된다. EM 알고리즘은 E-step과 M-step 두 가지 단계로 구성된다. 각각의 step에서는 앞서 설명한 방법처럼 \(\theta\)와 \(q(\mathbf Z)\)를 번갈아가면서 한 쪽은 고정한채 나머지를 update한다. 이런 alternating update method는 한 번에 수렴하지 않기 때문에, EM 알고리즘은 E-step과 M-step을 알고리즘이 수렴할 때 까지 반복하는 iterative 알고리즘이 된다.</p>


<p>현재 우리가 가지고 있는 parater \(\theta\)의 값을 \(\theta^{\mbox{old}}\)라고 정의해보자. EM 알고리즘의 E-step은 먼저 \(\theta^{\mbox{old}}\) 값을 고정해두고 \(\mathcal L(q,\theta)\)의 값을 최대로 만드는 \(q(\mathbf Z)\)의 값을 찾는 과정이다. 이 과정은 매우 간단하게 계산 수 있는데, 그 이유는 log-likelihood \(\ln p(\mathbf X | \theta^{\mbox{old}})\)의 값이 \(q(\mathbf Z)\) 값과 전혀 관계가 없기 때문에, 항상 \(\mathcal L(q,\theta)\)를 최대로 만드는 조건은 KL divergence가 0이 되는 상황이기 때문이다. KL divergence는 \(q(\mathbf Z) = p(\mathbf Z | \mathbf X, \theta^{\mbox{old}})\) 인 상황에서 0이 되기 때문에, \(q(\mathbf Z)\)에 posterior distribution \(p(\mathbf Z | \mathbf X, \theta^{\mbox{old}})\)을 대입하는 것으로 해결할 수 있다. 따라서 E-step은 언제나 KL-divergence를 0으로 만들고, lower bound와 likelihood의 값을 일치시키는 과정이 된다.</p>


<p>E-step에서 \(\theta^{\mbox{old}}\)을 고정하고 \(q(\mathbf Z)\)에 대한 optimization 문제를 풀었으므로 M-step에서는 그 반대로, \(q(\mathbf Z)\)를 고정하고 log-likelihood를 가장 크게 만드는 새 paramter \(\theta^{\mbox{new}}\)을 찾는 optimization 문제를 푸는 단계가 된다. E-step에서는 update하는 variable과 log-likelihood가 서로 무관했기 때문에 log-likelihood가 증가하지 않았지만, M-step에서는 \(\theta\)가 log-likelihood에 직접 영향을 미치기 때문에 log-likelihood 자체가 증가하게 된다. 또한 M-step에서 \(\theta^{\mbox{old}}\)가 \(\theta^{\mbox{new}}\)로 바뀌었기 때문에 E-step에서 구했던 \(p(\mathbf Z)\)로는 더 이상 KL-divergence가 0이 되지 않는다. 따라서 다시 E-step을 진행시켜 KL-divergence를 0으로 만들고, log-likelihood의 값을 M-step을 통해 키우는 과정을 계속 반복해야만한다.</p>


<p>위에 나왔던 그림에서 왼쪽이 E-step을 의미하고, 오른쪽 그림이 M-step을 의미한다. E-step을 의미하는 왼쪽 그림에서 KL divergence는 0이 되고, lower bound인 functional과 log-likelihood의 값이 같아진다. 오른쪽 그림은 M-step을 표현하고 있으며, \(\theta\)가 update되면서 log-likelihood의 값이 증가하게 되지만, 더 이상 KL divergence의 값이 0이 아니게 된다. 이 과정을 더 이상 값이 변화하지 않을 때 까지 충분히 많이 돌리게 되면 이 값은 log-likelihood의 어떤 값으로 수렴하게 될 것이다. 그리고 매 step마다 항상 optimal한 값으로 진행하기 때문에 이 값은 log-likelihood의 local optimum으로 수렴하게 된다는 사실까지 알 수 있다. EM algorithm은 아래와 같은 그림으로 표현할 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/70-3.png" width="500"></p>

<p>각 curve는 \(\theta\) 값이 고정이 되어있을 때 \(q(\mathbf Z)\)에 대한 lower bound \(\mathcal L(q,\theta)\)의 값을 의미한다. 매 E-step마다 고정된 \(\theta\)에 대해 \(p(\mathbf Z)\)를 풀게 되는데, 이는 곧 log-likelihood와 curve의 접점을 찾는 과정과 같다. 또한 M-step에서는 \(\theta\) 값 자체를 현재 값보다 더 좋은 지점으로 update시켜서 curve 자체를 이동시키는 것이다. 이런 과정을 계속 반복하면 알고리즘은 언젠가 local optimum으로 수렴하게 될 것이다. Local optimum에 수렴한다는 성질은 얼핏보면 나빠보일 수도 있지만, 이 글의 도입부에서 latent variable이 introduce되는 이유 자체가 원래 log-likelihood를 계산하는 것이 불가능에 가깝기 때문이었다는 사실을 돌이켜본다면, latent variable을 잘 잡기만 한다면 반드시 local optimum으로 수렴하는 EM 알고리즘은 매우 훌륭한 알고리즘이라는 사실을 알 수 있다. 즉, 아예 문제를 풀지 못하는 것 보다는 local optimum으로 수렴하는 것이 훨씬 좋다.</p>


<h5>Pratical issues</h5>


<p>대부분의 probabilistic model의 MLE 혹은 MAP는 EM 알고리즘을 사용하면 구할 수 있다. 그러나 EM 알고리즘이 항상 잘 동작하는 것은 아닌데, E-step 혹은 M-step의 optimization 문제를 푸는 것이 어려운 상황이 그러하다. E-step은 posterior를 계산하는 과정이므로 크게 문제가 되는 경우는 많지 않지만, M-step은 \(\theta\)에 대한 optimization 문제를 풀어야하는 과정인데, 이 과정에서 문제가 발생하는 경우가 많다. 예를 들어 모든 \(\theta\)를 한 번에 jointly optimize하는 것이 어려워 또 다른 alternative method를 사용해야할 수 도 있다. 그렇게 되면 iterative 알고리즘 안에 nested iterative 알고리즘이 발생하게 되어 전체 알고리즘의 수렴 속도가 매우 느려지게 된다. 가장 단순하게 이 문제를 해결하는 방법으로는 nested iterative 알고리즘을 완전히 푸는 것이 아니라, 수렴여부와 관계없이 iteration을 조금만 돌리고 다시 E-step을 구하고, 다시 M-step을 정확히 푸는 대신 iteration을 몇 번만 돌리는 등의 방식이 있을 것이다. 일반적인 경우에는 이런 방식이 수렴하지 않지만, 몇몇 경우에는 이런 방식이 local optimum에 수렴한다는 것이 증명되어있다. 가장 대표적인 예가 RBM을 푸는 Contrastive Divergence이다. 이에 대한 더 자세한 설명은 추후에 Deep learning에 대해 다루는 글에서 더 자세히 다루도록 하겠다.</p>


<h5>정리</h5>


<p>EM 알고리즘은 latent variable이 존재하는 probabilistic model의 maximum likelihood 혹은 maximum a posterior 문제를 풀기 위한 알고리즘 중 가장 대표적인 알고리즘이다. 본문에서는 MLE를 계산하는 과정만 다뤘지만, MAP도 비슷한 방식으로 구할 수 있다. Latent variable을 쉽게 잡기만한다면, 아무리 풀기 어려운 문제일지라도 구하고자 하는 문제의 local optimum에 수렴한다는 좋은 성질을 가지고 있기 때문에 매우 다양한 모델에서 이 알고리즘을 사용해 문제를 해결하고는 한다. 그러나 간혹 특히 M-step의 optimization을 푸는 과정에서 시간이 너무 오래 걸리는 문제가 발생하는 경우가 생길 수 있는데, 이런 경우 몇 가지 휴리스틱을 사용해 문제를 해결하기도 한다.</p>




<h5>변경 이력</h5>


<ul>
<li>2015년 6월 14일: 글 등록</li>
</ul>


<h5>Reference</h5>


<ul>
<li>Bishop, Christopher M. Pattern recognition and machine learning. Vol. 4. No. 4. New York: springer, 2006. Chapter 9</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (13) Clustering (K-means, Gaussian Mixture Model)]]></title>
    <link href="http://SanghyukChun.github.io/69/"/>
    <updated>2015-03-25T03:20:00+09:00</updated>
    <id>http://SanghyukChun.github.io/69</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p><a href="57-4-ClassML">첫 번째 글</a>에서 설명했던 것 처럼 Machine Learning은 크게 Supervised Learning, Unsupervised Learning 그리고 Reinforcement Learning으로 구분된다. 앞서 이미 그 중 <a href="http://SanghyukChun.github.io/64">Supervised Learning</a>을 간략하게 다룬 글이 있었고, 이 글에서는 그 중 Unsupervised Learning의 가장 대표적인 예시인 Clustering 대해 다룰 것이며 가장 대표적이고 간단한 두 가지 알고리즘에 대해서 역시 다룰 것이다.</p>


<h5>What is Clustering?</h5>


<p><a href="http://en.wikipedia.org/wiki/Cluster_analysis">Clustering</a>은 <a href="http://en.wikipedia.org/wiki/Unsupervised_learning">Unsupervised Learning</a>의 일종으로, label 데이터 없이 주어진 데이터들을 가장 잘 설명하는 cluster를 찾는 문제이다. 왜 클러스터링이 필요할까? Classification을 하기 위해서는 데이터와 각각의 데이터의 label이 필요하지만, 실제로는 데이터는 존재하지만 그 데이터의 label이나 category가 무엇인지 알 수 없는 경우가 많기 때문에 classfication이 아닌 다른 방법을 통해 데이터들을 설명해야하는 경우가 발생한다. 아래 그림은 클러스터링이 어떤 것인지 잘 보여주는 그림이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/69-1.png" width="500"></p>

<p>우리에게 처음 주어진 것은 왼쪽 파란 데이터이다. 각각의 데이터에 대한 정보는 아무 것도 없는 상태에서 주어진 데이터들을 가장 잘 설명하는 클러스터를 찾아내는 것이 클러스터링의 목적이다. 따라서 클러스터링은 대부분 Optimization 문제를 푸는 경우가 많다. 이는 클러스터링 뿐 아니라 다른 많은 unsupervised learning에서도 역시 마찬가지이다.</p>


<p><a href="http://SanghyukChun.github.io/57">첫 번째 글</a>과 <a href="http://SanghyukChun.github.io/64">이전 글</a>에서 머신러닝 문제는 먼저 주어진 데이터에 대한 가정을 하고, 해당 가정을 만족하는 best hypothesis를 찾는 문제라고 언급한 적이 있다. Clustering 문제 역시 Machine Learning 문제이므로 데이터에 대한 가정을 먼저 해야하고, best hypothesis를 찾는 과정을 거친다. 따라서 각각의 서로 다른 clustering algorithm들은 서로 다른 assumption을 가지고 있으며, 해당 assumption을 가장 잘 만족하는 function parameter를 계산하는 과정이다. 앞으로 설명하게 될 알고리즘들에 대한 설명을 읽을 때 데이터에 대해 어떤 가정을 하였는지 꼼꼼히 확인하면서 읽으면 알고리즘을 이해하기 한결 수월할 것이다.</p>


<h5>K-means</h5>


<p>클러스터를 정의하는 방법에는 여러 가지가 있을 수 있지만, 가장 간단한 정의 중 하나는 클러스터 내부에 속한 데이터들이 서로 &#8216;가깝다&#8217;라고 정의하고, &#8216;가장 가까운&#8217; 내부 거리를 가지는 클러스터를 고르는 것이다. <a href="http://en.wikipedia.org/wiki/K-means_clustering">K-means</a>는 같은 클러스터에 속한 데이터는 서로 &#8216;가깝다&#8217; 라고 가정한다. 이때 각각의 클러스터마다 &#8216;중심&#8217;이 하나씩 존재하고, 각각의 데이터가 그 중심과 &#8216;얼마나 가까운가&#8217;를 cost로 정의한다. K-means는 이렇게 정의된 cost를 가장 줄이는 클러스터를 찾는 알고리즘이다. 수식으로 적으면 다음과 같다.</p>


<p>$$ \min_{b,w} \sum_i^n \sum_j^k w_{ij} \| x_i - b_j \|_2^2 \text{ s.t. } \sum_j w_{ij} = 1, \forall j$$</p>


<p>데이터는 \(n\)개 있으며 클러스터는 \(k\)개 있다고 가정했다. 이때, \(b_j\)는 \(j\) 번째 클러스터의 &#8216;중심&#8217;을 의미하며, \(w_{ij}\)는 \(i\) 번째 데이터가 \(j\) 번째 클러스터에 속하면 1, 아니면 0을 가지는 binary variable이다. 또한 뒤에 붙는 조건은 반드시 각 데이터 별로 한 개의 클러스터에 assign이 되어야한다는 constraint이다.</p>


<p>이 문제는 풀기 쉬운 문제가 아니다. Binary variable \(w_{ij}\) 때문에, 모든 cluster 조합을 하나하나 확인해야만 optimal한 값을 구할 수 있다. 즉, jointly optimize하는 것이 매우 어렵다. 그러나 재미있게도 \(b\)와 \(w\) 둘 중 하나를 고정하고 나머지 하나를 update하는 것은 매우 간단하다. 나머지 값이 고정되었을 때 \(b_j\)의 optimal값은 \(j\) 번째 클러스터의 &#8216;mean&#8217;을 계산하는 것이다 (이 때문에 &#8216;\(k\)&#8217; 개의 &#8216;mean&#8217;을 찾는다고 해서 k-means 알고리즘이다). \(w_{ij}\)의 optimal 값은 모든 데이터 i에 대해, 각각 모든 클러스터 중에서 \(x_i - b_j\)가 가장 작은 클러스터에 assign하는 것이 optimal한 solution이다. 이렇듯 만약 다른 변수 하나를 정확하게 알고 있다고 생각하면 아주 간단한 방법으로 alternative optimization이 가능하다. 사실 이 개념은 예전에 적은 <a href="http://SanghyukChun.github.io/63">convex optimization</a>글에서 잠깐 언급했던 coordinate descent 방법과 거의 유사하다. K-means 알고리즘은 이렇게 \(b\)와 \(w\)를 alternative하게 계속 update하면서 \(b\)와 \(w\)가 더 이상 바뀌지 않을 때 까지 계산을 반복하는 알고리즘이다. 안타깝게도 K-means는 global optimum에 수렴하지 않고 local한 optimum에 수렴하므로 initialization에 매우매우 취약하다는 단점이 존재한다.</p>


<p>또한 여담으로 K-means objective function에 사용한 \(\ell_2\) norm의 제곱이 outlier 혹은 noise에 매우 취약하기 때문에 조금 더 outlier에 덜 sensitive한 &#8216;robust한&#8217; norm을 사용하는 방법도 존재한다. 예를 들어 \(\ell_2\) norm의 제곱을 \(\ell_1\) norm으로 바꾸면 &#8216;mean&#8217; 대신에 &#8216;median&#8217;을 찾는 문제로 바뀌게 된다. 이를 <a href="http://en.wikipedia.org/wiki/K-medians_clustering">k-median</a>이라고 부른다. 그 밖에도 k-means의 robustness를 개선하기 위한 다양한 방법들이 개발이 되어있지만 이 글에서는 다루지 않도록 하겠다.</p>


<h5>Gaussian Mixture Model</h5>


<p>K-means algorithm의 key idea는 &#8216;alternative update&#8217;이다. 즉, coordinate wise로 다른 변수들을 고정한 채로 &#8216;alternative&#8217;하게 변수들을 update함으로써 jointly optimization을 할 수 없는 문제를 푸는 것이다. 비록 그 결과가 global하지 않은 local에 converge하더라도, 찾지 못하는 것보다는 훨씬 낫기 때문에 실제로 이런 방법이 많이 쓰인다. 이번 섹션에서는 이런 방법을 사용하는 또 다른 알고리즘을 하나 소개하도록 하겠다.</p>


<p>Gaussian Mixture Model, Mixture of Gaussian, GMM, 혹은 MoG는 데이터가 &#8216;Gaussian&#8217;의 &#8216;Mixture&#8217;로 구성이 되어있다고 가정한다. 보통 GMM이라고 많이 부르며, 이 글에서 다루는 GMM은 가장 optimal한 GMM을 찾는 알고리즘을 의미한다. 즉, 데이터가 \(k\)개의 gaussian으로 구성되어있다고 했을 때, 가장 데이터를 잘 설명하는 \(k\)개의 평균과 covariance를 찾는 알고리즘이다. 아래 그림은 3개의 gaussian으로 구성되어있다고 가정하고 그 gaussian 분포들을 찾은 결과이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/69-2.png" width="500"></p>

<p>모든 machine learning 문제는 &#8216;performance measure&#8217;를 가진다고 예전에 얘기한 적이 있다. GMM의 performance measure는 log likelihood function이다. 즉, 주어진 paramter에 대해 데이터 X의 확률을 가장 크게 만드는 parameter를 찾는 것이 목표가 된다. log likelihood는 \(\ln p(X|\theta)\)로 정의가 된다. 우리가 찾아야하는 parameter \(\theta\)는 각각의 gaussian의 평균 \(\mu_j\), covariance \(\Sigma_j\), 그리고 마지막으로 각각의 데이터가 각각의 gaussian에 속할 확률 \(\pi_j\)로 구성된다. 따라서 주어진 \(\mu_j, \Sigma_j\)에 대한 \(x_i\)의 multinomial gaussian distribution을 \(N(x_i|\mu_j, \Sigma_j)\)라고 정의한다면 log likelihood function은 다음과 같이 기술할 수 있다.</p>


<p>$$ \ln p(X|\pi, \mu, \Sigma) = \sum_i^n \ln \sum_j^k \pi_j N (x_i | \mu_j, \Sigma_j) $$</p>


<p>그러나 역시 이 문제도 jointly update가 매우매우 어려운 문제이다. 그러나 K-means와 비슷하게도 \(\pi\)를 고정하고 \(\mu, \Sigma\)를 계산하는 것은 쉬우며, 그 반대 역시 쉽다. 따라서 비슷하게 alternative update를 통해 문제를 해결하는 알고리즘을 어렵지 않게 디자인 할 수 있다. 역시 이 알고리즘도 global로 수렴하지 않고 local로만 수렴하게 된다. GMM을 풀기 위해서 사용되는 알고리즘 중 가장 유명한 알고리즘으로는 <a href="http://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm">&#8216;EM&#8217; 알고리즘</a>이 존재한다. 이 알고리즘에 대해서는 <a href="http://SanghyukChun.github.io/70">다음 글</a>에서 더 자세하게 설명하도록 하고, 이 글에서는 EM 알고리즘이라는 것을 알고 있는 상태에서 어떻게 각 step을 해결할 수 있는지에 대해서만 다루도록 하겠다. E-step에서는 현재 주어진 \(\mu, \Sigma, \pi\)들을 사용해 가장 &#8216;expectation&#8217;이 높은 latent variable의 값을 찾아내며, M-step에서는 새로 estimate된 latent variable을 사용해 그 값을 maximize하는 \(\mu, \Sigma, \pi\)를 찾는다. EM 알고리즘은 E-step과 M-step이 계속 번갈아 진행되며, 더 이상 값이 변하지 않을 때 까지 반복된다. K-means를 이런 관점으로 바라보게 된다면, cluster information \(w_{ij}\)를 update하는 과정이 E-step, \(b\)를 update하는 과정을 M-step이라고 할 수 있다. (그러나 K-means을 푸는 알고리즘은 엄밀하게 말하면 EM 알고리즘이 아니다)</p>


<p>사실 엄밀하게 설명하면 GMM을 푸는 EM에서 E-step 때 update하는 것은 정확하게 \(\pi\)와 같은 것은 아니다. EM으로 이 문제를 풀기 위해서 우리는 새로운 &#8216;latent&#8217; variable을 introduce해야한다. latent variable은 쉽게 생각하면 graphical model에서 hidden variable에 해당하는 값이다. 다음에 EM 알고리즘에 대해 자세히 다룰 때 다시 설명하겠지만, 이렇게 latent variable을 설정하는 이유는 어떤 특정 variable의 marginal distribution을 optimize하는 것은 어려울 때, latent variable을 사용해 그 variable과 latent variable의 joint distribution을 다루는 것은 간단할 수 있기 때문이다. GMM에서는 latent variable \(z\)를 introduce하게 된다. \(z\)는 \(k\)-ary variable로, \(z\)의 \(j\) 번째 dimension인 \(z_j\)는 Binary random variable이며, \(p(z_j=1) = pi_j, \) where \(\sum_j z_j = 1\) and \(\sum_j \pi_j = 1\) 이라는 조건을 가지고 있다. \(z\)의 marginal probability는 \(p(z) = \prod_j \pi_j^{z_j}\)로 어렵지 않게 계산할 수 있으며, 비슷하게 주어진 데이터 \(x\)에 대한 conditional distribution 역시 간단하게 다음과 같이 표현된다. \(p(x|z) = \prod_j N(x|\mu_j, \Sigma_j)^{z_j}\).</p>


<p>따라서 앞선 식들로부터 joint distribution을 얻을 수 있고, 그 값을 marginalize해 다음과 같은 결과를 얻을 수 있다.</p>


<p>$$ p(x) = \sum_z p(x,z) = \sum_z p(z)p(x|z) = \sum_j \pi_j N(x|\mu_j, \Sigma_j) $$</p>


<p>정리하자면, 각각의 data point \(x_i\) in GMM의 graphical representation은 다음과 같이 표현할 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/69-3.png" width="300"></p>

<p>위의 결과들을 토대로 이제 간단하게 EM algorithm을 돌릴 수 있다. 먼저 E step에서는 \(p(z_j = 1|x)\)를 계산할 것이다. 각 데이터에 대해 \(j\) 번째 클러스터에 속할 확률, 혹은 posterior를 계산하는 과정이다. 이 값은 Bayes rule을 통해 간단하게 다음과 같이 계산할 수 있다.</p>


<p>$$ p(z_j = 1|x) = \frac{p(z_j=1)p(x|z_j=1)}{\sum_j^k p(z_j=1)p(x|z_j=1)} = \frac{\pi_j N(x|\mu_j, \Sigma_j)}{\sum_j^k \pi_j N(x|\mu_j \Sigma_j)} $$</p>


<p>다음으로 \(z\)를 fix했을 때 다음과 같이 나머지 paramter를 계산할 수 있다.</p>


<p>$$ \mu_j = \frac{1}{\sum_i p(z_j=1|x)} \sum_i p(z_{ij}=1|x) x_i$$</p>


<p>$$ \Sigma_j = \frac{1}{\sum_i p(z_j=1|x)} \sum_i p(z_{ij}=1|x) (x_i-\mu_j) (x_i-\mu_j)^\top$$</p>


<p>$$ \pi_j = \frac{\sum_i p(z_j=1|x)}{N}$$</p>


<p>정리하자면, GMM을 풀기 위한 EM 알고리즘은, 먼저 각각의 데이터가 어느 클러스터에 속할지에 대한 정보를 update해 (\(z\)를 업데이트 하여) expectation을 계산하고, 다음으로 업데이트 된 정보들을 사용해 나머지 값들로 가장 log likelihood를 최대화하는 parameter들을 (\(\mu, \Sigma, \pi\)를) 찾아낸다. 알고리즘을 돌리면 아래처럼 iteration이 지날 때 마다 점점 좋은 값을 찾아준다. (출처: <a href="http://kipl.tistory.com/64">Geometry & Recognition :: Gaussian Mixture Model & K-means</a>)</p>


<p><img src="http://SanghyukChun.github.io/images/post/69-4.gif" width="500"></p>

<p>EM 알고리즘에 대한 심도있는 이해 없이 이 글을 이해하는 것은 조금 어려울 수 있다. 이 글이 잘 이해가 되지 않는다면 먼저 EM 알고리즘에 대해 설명한 <a href="http://SanghyukChun.github.io/70">다음 글</a>을 읽어본 다음 다시 읽어보기를 권한다.</p>


<h5>정리</h5>


<p>Clustering은 unsupervised learning 분야에서 가장 활발히 연구되는 분야 중 하나이다. 이 글에서는 여러 종류의 클러스터링 알고리즘 중에서 optimization function을 (1) 거리 기반으로 세우고 그것을 푸는 알고리즘과 (2) 확률과 확률분포를 기반으로 세우고 그것을 푸는 알고리즘을 소개하였다. 특히 GMM은 다음 글에서 다룰 주제인 EM algorithm과 밀접하게 관련되는 내용이므로 한 번 쯤은 책이나 렉쳐노트를 정독하는 것을 권한다.</p>




<h5>변경 이력</h5>


<ul>
<li>2015년 3월 25일: 글 등록</li>
<li>2015년 6월 14일: EM 알고리즘 링크 추가 및 설명 변경</li>
</ul>


<h5>Reference</h5>


<ul>
<li>Bishop, Christopher M. Pattern recognition and machine learning. Vol. 4. No. 4. New York: springer, 2006. Chapter 9</li>
<li><a href="http://kipl.tistory.com/64">Geometry &amp; Recognition :: Gaussian Mixture Model &amp; K-means</a></li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (8) Classification Introduction (Decision Tree, Naïve Bayes, KNN)]]></title>
    <link href="http://SanghyukChun.github.io/64/"/>
    <updated>2015-03-25T02:10:00+09:00</updated>
    <id>http://SanghyukChun.github.io/64</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p><a href="http://SanghyukChun.github.io/57#57-4-ClassML">첫 번째 글</a>에서 설명했던 것 처럼 Machine Learning은 크게 Supervised Learning, Unsupervised Learning 그리고 Reinforcement Learning으로 구분된다. 이 글에서는 그 중 Supervised Learning의 가장 대표적인 예시인 Classification에 대해 다룰 것이며 가장 대표적이고 간단한 세 가지 알고리즘에 대해서 역시 다룰 것이다.</p>


<h5>What is Classification?</h5>


<p><a href="http://en.wikipedia.org/wiki/Statistical_classification">Classification</a>은 <a href="http://en.wikipedia.org/wiki/Supervised_learning">Supervised Learning</a>의 일종으로, 기존에 존재하는 데이터와 category와의 관계를 learning하여 새로 관측된 데이터의 category를 판별하는 문제이다. 스팸 필터를 예로 들어들어보자. 스팸 필터의 데이터는 이메일이고, category, 혹은 label, class는 spam메일인지 일반 메일인지를 판별하는 것이 될 것이다. 스팸필터는 먼저 스팸 메일, 그리고 일반 메일을 learning을 한 이후, 새로운 데이터 (혹은 메일)이 input으로 들어왔을 때 해당 메일이 스팸인지 일반 메일인지 판별하는 문제를 풀어야하며, 이런 문제를 classification이라고 한다.</p>


<p><a href="http://SanghyukChun.github.io/57">첫 번째 글</a>에서 머신러닝 문제는 먼저 주어진 데이터에 대한 가정을 하고, 해당 가정을 만족하는 best hypothesis를 찾는 문제라고 언급한 적이 있다. Classification 문제 역시 Machine Learning 문제이므로 데이터에 대한 가정을 먼저 해야하고, best hypothesis를 찾는 과정을 거친다. 따라서 각각의 서로 다른 classification algorithm들은 서로 다른 assumption을 가지고 있으며, 해당 assumption을 가장 잘 만족하는 function parameter를 계산하는 과정이다. 앞으로 설명하게 될 알고리즘들에 대한 설명을 읽을 때 데이터에 대해 어떤 가정을 하였는지 꼼꼼히 확인하면서 읽으면 알고리즘을 이해하기 한결 수월할 것이다.</p>


<h5>Decision Tree</h5>


<p><a href="http://en.wikipedia.org/wiki/Decision_tree">Decision Tree</a>는 가장 단순한 classifier 중 하나이다. 이 Decision Tree의 구조는 매우 단순하다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/64-1.png" width="600"></p>

<p>위의 그림은 오늘 외출을 할까 말까를 결정하는 decision tree이다. 이렇듯 decision tree는 tree구조를 가지고 있으며, root에서부터 적절한 node를 선택하면서 진행하다가 최종 결정을 내리게 되는 model이다. Decision tree의 가장 좋은 점은 단순하다는 점이다. 누구나 쉽게 이해할 수 있고, 그렇기 때문에 쉽게 디버깅할 수 있다. 예를 들어 위의 예시에서 습도가 높아도 나갈만하다는 생각이 든다면 맨 왼쪽의 No를 Yes로 바꾸기만 하면 간단하게 로직을 바꿀 수 있다. 그러나 다른 모델들은 그런 점들이 비교적 어렵다. Machine Learning에서 말하는 decision tree는 <a href="http://en.wikipedia.org/wiki/Decision_tree_learning">decision tree learning</a>으로, 일일이 node마다 로직을 사람이 써넣어 만드는 것을 의미하는게 아니라, node 개수, depth, 각각의 node에서 내려야하는 결정 등을 데이터를 통해 learning하는 algorithm들을 사용해 만든 decision tree를 의미한다.</p>


<p>많이 쓰이는 알고리즘들로는 <a href="http://en.wikipedia.org/wiki/ID3_algorithm">ID3</a>, <a href="http://en.wikipedia.org/wiki/C4.5_algorithm">C4.5</a>, <a href="http://en.wikipedia.org/wiki/Predictive_analytics#Classification_and_regression_trees">CART</a>, <a href="http://en.wikipedia.org/wiki/CHAID">CHAID</a>, <a href="http://en.wikipedia.org/wiki/Multivariate_adaptive_regression_splines">MARS</a> 등이 있으며, 보통 C4.5를 가장 많이 사용한다.</p>


<p>C4.5는 ID3의 몇 가지 문제점들을 개선한 알고리즘으로, 그 기본 개념은 ID3와 크게 다르지 않다. 추후 이 글 혹은 다른 글에 ID3 알고리즘에 대한 내용을 추가하도록 하겠다.</p>


<h5>Regression Tree and Ensemble method</h5>


<p>Decision tree는 output value가 반드시 binary여야한다는 제약조건이 있기 때문에 스팸 필터 등에서는 사용할 수 있지만, 실제 모든 데이터가 binary만을 output으로 가지지 않으므로 모든 데이터에 사용하려면 변형이 필요하다. <a href="http://en.wikipedia.org/wiki/Decision_tree_learning#Types">Regression tree</a>는 binary가 아니라 real value를 output으로 가지는 모델로, learning하는 방법은 크게 다르지 않다고 한다.</p>


<p>가끔은 하나의 decision tree를 사용하는 것이 아니라 한 번에 여러 개의 decision tree들을 만들어서 각각의 decision tree들이 내리는 결정을 종합적으로 판단하여 (ensemble) 결정을 내리기도 한다. <a href="http://en.wikipedia.org/wiki/Bootstrap_aggregating">Bagging decision tree</a>, <a href="http://en.wikipedia.org/wiki/Random_forest">random forest</a>등이 이에 속한다. 이런 식으로 여러 개의 classifier를 사용해 decision을 내리는 방법을 ensemble method라고 하는데, industry에서는 machine learning algorithm의 성능을 높이기 위해서 여러 개의 알고리즘들을 ensemble method를 사용하여 한 번에 같이 사용하기도 한다. 대표적인 예로 <a href="http://en.wikipedia.org/wiki/AdaBoost">AdaBoost</a> 등이 있다.</p>


<p>Ensemble method에 대해서는 나중에 따로 다시 설명할 예정이므로 그 글을 참고하면 좋을 것 같다. (링크는 추후 추가 예정)</p>


<h5>Naïve Bayes</h5>


<p><a href="http://en.wikipedia.org/wiki/Naive_Bayes_classifier">Naïve Bayes Classifier</a>는 <a href="58-1-Bayes">Bayesian rule</a>에 근거한 classifier이다. Naïve Bayes는 일종의 확률 모델로, 약간의 가정을 통해 문제를 간단하게 푸는 방법을 제안한다. 만약 데이터의 feature가 3개 있고, 각각이 binary라고 해보자. 예를 들어 남자인지 여자인지, 성인인지 아닌지, 키가 큰지 작인지 등의 feature를 사용해 사람을 구분해야한다고 생각해보자. 이 경우 적어도 8개의 데이터는 있어야 모든 경우의 수를 설명할 수 있게 된다. 그런데 보통 데이터를 설명하는 feature의 개수는 이보다 훨씬 많은 경우가 많다. 예를 들어 feature가 10개 정도 있고 각각이 binary라면, 제대로 모든 데이터를 설명하기 위해서는 \(2^{10}\), 약 1000개 이상의 데이터가 필요하다. 즉, 필요한 데이터의 개수가 feature 혹은 데이터의 dimension에 exponential하다. 이런 경우 그냥 Bayes rule을 사용해 분류를 하게 되면 overfitting이 되거나 데이터 자체가 부족해 제대로 된 classification을 하기 어려울 수 있다. Naïve bayes는 이런 문제를 해결하기 위해 새로운 가정을 하나 하게 된다. 바로 모든 feature들이 i.i.d.하다는 것이다. i.i.d는 independent and identically distributed의 준말로, 모든 feature들이 서로 independent하며, 같은 분포를 가진다는 의미이다. 당연히 실제로는 feature들이 서로 긴밀하게 관련되어있고 다른 분포를 가질 것이므로 이 가정은 틀린 가정이 될 수 있다. 그러나 만약 모든 feature가 i.i.d.하다고 가정하게 된다면 우리가 필요한 최소한의 데이터 개수는 feature의 개수에 exponential하게 필요한게 아니라 linear하게 필요하게 된다. 간단한 가정으로 모델의 complexity를 크게 줄일 수 있는 것이다. 때문에 Naïve Bayes 뿐 아니라 많은 모델에서 실제 데이터가 그런 분포를 보이지 않더라도 그 데이터의 분포를 특정한 형태로 가정하여 문제를 간단하게 만드는 기술을 사용한다.</p>


<p>조금 더 엄밀하게 수식을 사용해 설명을 해보자. 우리가 가지고 있는 input data 를 \(x = (x_1, \ldots, x_n)\)이라고 가정해보자. 즉 우리는 총 \(n\)개의 feature를 가지고 있다고 가정해보자 (보통 \(n\)은 데이터의 개수를 의미하지만, wikipedia의 notation을 따라가기 위하여 이 글에서도 dimension을 나타내기 위해 \(n\)을 사용하였다). 그리고 Class의 개수는 \(k\)라고 해보자. 우리의 목표는 \(p(C|x_1, \ldots, x_n) = p(C|x)\)를 구하는 것이다. 즉, 1부터 \(k\)까지의 class 중에서 가장 확률이 높은 class를 찾아내어 이를 사용해 classification을 하겠다는 것이다. Bayes rule을 알고 있으므로 이 식을 bayes rule을 사용해 전개하는 것은 간단하다.</p>


<p>$$ p(C|x) = \frac{p(C) p(x|C)}{p(x)} $$</p>


<p>이 때 분모에 있는 데이터의 확률은 normalize term이기 때문에 모든 값을 계산하고 나서 한 번에 계산하면 되므로 우리는 \(p(x,C) = p(C) p(x|C)\), 다시 말해 prior와 likelihood를 계산해야만한다. 그러나 이 값은 joint probability이므로 데이터에서부터 이 값을 알아내기 위해서는 &#8216;엄청나게 많은&#8217; 데이터가 필요하다. 구체적으로는 앞서 말한 것 처럼 dimension에 exponential하게 많은 데이터 개수를 필요로 한다. 그러나 만약 우리가 x가 모두 indepent하다고 가정한다면 간단하게 다음과 같은 식으로 나타낼 수 있다.</p>


<p>$$ p(C) p(x_1, \ldots, x_n | C) = p(C) p(x_1|C) p(x_2|C) \ldots = p(C) \prod p(x_i|C)$$</p>


<p>따라서 normalize term을 \(Z\)로 표현한다면, 우리가 구하고자 하는 최종 posterior는 \(p(C|x) = \frac{1}{Z} p(C)\prod p(x_i|C)\)로 나타낼 수 있게 된다.</p>


<h5>KNN</h5>


<p><a href="http://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">K-Nearest Neighbors algorithm (KNN)</a>은 구현하기 어렵지 않으면서도 비교적 나쁘지 않은 성능을 내는 Classification Algorithm 중 하나이다. KNN은 가까운 데이터는 같은 label일 가능성이 크다고 가정하고 새로운 데이터가 들어오면, 그 데이터와 가장 가까운 k개의 데이터를 training set에서 뽑는다. 뽑은 k개의 데이터들의 label을 관측하고 그 중 가장 많은 label을 새로운 데이터의 label로 assign하는 알고리즘이다 (이런 방식을 majority voting이라고 한다). 이때 &#8216;가까움&#8217;은 Euclidean distance로 측정해도 되고, 다른 metric이나 measure를 사용해도 된다. 이때 distance 혹은 similarity를 측정하기 위해서 반드시 metric을 사용해야하는 것은 아니다. 즉, metric의 세 가지 성질을 만족하지 않는 measure일지라도 두 데이터가 얼마나 &#8216;비슷하냐&#8217;를 measure할 수 있는 measure라면 KNN에 적용할 수 있다. 아래 그림은 KNN이 어떻게 동작하는지 알 수 있는 간단한 예시이다. 아래 그림을 보면 k를 3으로 골랐을 때 초록색 데이터의 label은 빨강이 되고, k를 5로 골랐을 때는 파란색이 됨을 알 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/64-2.png" width="500"></p>

<p>KNN은 구현하기에도 매우 간단하고 (새로 들어온 점과 나머지 점들간의 distance를 측정한 후 sorting하기만 하면 된다) 성능도 보통 크게 나쁘지 않은 값을 보이기 때문에 간단하게 개발할 필요가 있는 경우에 많이 사용하게 된다. 사실 대부분의 머신러닝 툴박스들은 KNN의 다양한 variation까지 built-in function으로 지원한다. Matlab의 knnclassify가 대표적인 예. 또한 KNN은 <a href="http://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm#Properties">유용한 성질들</a>이 많이 있다. 예를 들어 만약 데이터의 개수가 거의 무한하게 있다면, KNN classifier의 error는 bayes error rate의 두 배로 bound가 된다는 특성이 있다. 즉, 데이터가 엄청나게 많다면, KNN은 상당히 좋은 error bound를 가지게 된다는 것이다. 즉, 단순한 휴리스틱 알고리즘이 아니라 엄밀하게 수학적으로 우수한 알고리즘임을 증명할 수 있는 알고리즘이라는 뜻이다. 또한 distance를 마음대로 바꿀 수 있기 때문에 KNN은 변형하기에도 간단한 편이므로 데이터에 대한 가정을 모델에 반영하여 변형하기에 간편하다는 장점이 있다.</p>


<h5>정리</h5>


<p>가장 간단하게 적용할 수 있는 세 가지 classification algorithm에 대해 훑어보았다. 개인적으로 KNN은 정말 직관적일뿐 아니라 잘 동작하는 알고리즘이기 때문에, 개인적으로 어떤 문제를 해결해야할 때 가장 먼저 이 데이터가 어느 정도 잘 분류되는지 테스트하는 용도로 애용한다. 중요한 점은, 각각의 classification algorithm이 풀려고 하는 &#8216;문제&#8217; 혹은 model은 서로 다른 가정을 가지고 있으며, 그 가정에 따라 문제를 푸는 방법이 아주 많이 바뀐다는 것이다. 즉, 어떤 새로운 classification algorithm을 만들어야 할 때는 (이는 classification 뿐 아니라 모든 알고리즘을 만들어야 할 때도 마찬가지인데) 먼저 어떤 문제를 풀어야하는지 문제를 정의해야하며, 문제를 정의하기 위해 어떤 모델을 가정해야한다는 것이다. 예를 들어 Naïve Bayes는 데이터의 각각의 feature들이 서로 i.i.d하다는 가정을 하고 있고, KNN은 &#8216;가까운&#8217; 데이터와 내가 같은 label을 가지고 있을 확률이 높다는 가정을 하고 있다. 이렇듯 Machine learning algorithm을 개발하는 일에서 가장 중요한 것은 좋은 문제를 먼저 정의하는 것에서부터 시작하는 것이 아닐까 생각한다.</p>




<h5>변경 이력</h5>


<ul>
<li>2015년 3월 25일: 글 등록</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[블룸버그 폰 인터뷰 후기]]></title>
    <link href="http://SanghyukChun.github.io/86/"/>
    <updated>2015-03-14T03:57:00+09:00</updated>
    <id>http://SanghyukChun.github.io/86</id>
		<content type="html"><![CDATA[<p>운이 좋게도, 교수님의 추천을 받아 블룸버그 software internship을 지원하게 되었다. 지원은 작년 12월에 하였고, 인터뷰는 1월 말부터 시간을 계속 조율하다가 오늘에서야 phone interview를 보게 되었다. 블룸버그가 뉴욕에 있다보니 현지 시간으로 2시에 면접인데 나는 새벽 3시.. 그나마 섬머타임이 실행되서 3시였지 안그랬으면 4시였다. 늦은 시간이지만 잠깐 시간을 내서 이 여운이 사라지기 전에 기록을 남겨볼까 한다.</p>


<p>먼저 phone interview는 생각보다도 더 어렵다. 일단 전화라는게 상대방의 말을 명료하게 전달해주지 못하는게 문제가 된다. 안그래도 긴장해서 영어가 잘 안들리는 상황에서 전화 연결 상황까지 안좋으니 더더더 긴장할 수 밖에 없었다. 하지만 이런 상황에도 못알아들었으면 당당하게 다시 말해달라고 하면 인터뷰어가 친절하게 대답해주니까 너무 겁먹을 필요는 없더라. 그리고 내가 phone interview에서 코딩을 위해 사용한 <a href="https://www.hackerrank.com/">HackerRank</a>라는 녀석이 구글 독스처럼 서로 글씨를 적으면 바로바로 상대방이 볼 수 있는 방식이라 말을 하면서 동시에 타이핑을 하는 것으로 충분히 내 부족한 영어를 메꿀 수도 있었다.</p>


<p>맨 처음 전화를 받고나서는 내 resume를 기반으로 몇 가지 질문들이 들어왔다. 너 이런 연구했는데 이거에 대해서 간단하게 설명할 수 있니? 여기에서 한 work은 어떤 work이니? 이 회사에서 일할 때 어떤 일들을 했니? 등의 질문들이었는데 아무래도 내 영어가 길지 못해 충분히 설명하지 못한게 아쉬운 요소였다. 시간을 재본건 아닌데 대충 10분 정도 레쥬메 스캔을 한 것 같다.</p>


<p>레쥬메 스캔이 끝나자마자 바로 코딩 문제로 넘어갔다. 여러 언어를 사용할 수 있는 것 같던데, 나는 Python을 사용해서 코딩을 했다. 내가 가장 멋진 코드를 쓸 수 있는건 (당연히 MATLAB을 제외하면) Ruby이지만, 내가 Ruby를 손에 안잡은지 너무 오래되었기 때문에 그나마 최근에도 가끔 사용하는 Python을 쓰기로 했다. C나 JAVA보다는 Python이 내 장점을 어필하기에 그나마 조금 나을 것 같아서. 그리고 사실 C랑 자바도 까먹었다. 질문은 두 가지 였는데, 하나는 여러 개의 list를 intersection하는 function을 짜라는 문제였고, 또 하나는 캐시를 구현하는거였다. 첫 번째 문제를 듣자마자 그간 코딩을 게을리한 것을 후회하게 되더라. 분명 어렵지 않은 문제인데 갑자기 코딩을 하려니 좋은 방법이 잘 떠오르지 않더라. 구글링을 하면 간단하게 해결할 수 있는 문제지만 그럴 수 있는 상황은 아니니까. 두 번째 문제는 듣자마자 OS에서 배웠던 내용이라 기뻐했는데 막상 어떤 데이터스트럭쳐를 사용해서 어떻게 빠르게 할 수 있는지 설명하려니까 그냥 딕셔너리를 써서 sorting한다는 대답 밖에 할 수 없었다.</p>


<p>첫 번째 문제를 정확하게 기술해보면 Input list들은 [ [1,2,3,&#8230;], [2,3,4,&#8230;], [5,6,7,&#8230;], &#8230; ] 처럼 생긴 list of list로 들어오고, output은 그 list들의 intersection을 구하는 문제였다. 내가 제안한 방법은 functional language 처럼 문제를 푸는 방법이었다. 먼저 두 개의 list를 비교하는 function을 만들고, 그것을 reduce했다. 대략 아래와 같은 느낌</p>


<figure class='code'><div class="highlight"><table><tr> <td class='code'><pre><code class=''><span class='line'>f = lambda x,y : [a for a in x if a in y]
</span><span class='line'>print reduce(f,L)</span></code></pre></td></tr></table></div></figure>


<p>코드 퀄리티는 아주 만족한다. 처음에 문제를 듣자마자 그냥 for loop으로 일단 돌아가게만 다 풀어버릴까 고민도 했었는데 그래도 그것보다는 이게 훨씬 아름답고 functional한 철학에도 맞고 여러모로 내가 추구하는 이상적인 코드에 가깝다. 문제는 여기까지 가는데에 시간이 너무 오래걸렸다는 것. 처음에 열심히 헤메느라 점수 다 까먹었을 것 같다. List comprehension을 사용하면 Lambda를 금방 정의할 수 있는데 그 생각을 못해서 for loop으로 naive한 것을 먼저 만들고 그걸 lambda로 넣으려고 하고 막 그랬는데.. 암튼 좀 헤메다가 위 처럼 문제를 해결했다. 그런데 저 List comprehension도 내가 naive way라면서 일단 element wise로 다 비교해보자고 하면서 넣은거라 interviewer가 내가 코딩을 끝내자마자 바로 이 방법을 더 좋게 만들 수 없는지 물어보더라. Sorting이 되어있냐고 물어보고, 되어있지 않다고 하길래 일단 각각을 sorting했다고 가정하고 filter를 사용해서 개선할 수 있다고 하고 내가 코드를 적으려고 했는데 시간이 부족하다면서 (이미 여기에서부터 15분 남음) 스킵하고 넘어갔다. 내가 적고 싶었던 솔루션은 아래와 같았다. 진짜 잘 동작하는지모르고, complexity가 진짜 더 낮은지 생각해봐야함. 근데 아마 O(n)이 O(log n)이 되어서 더 빠를거임.</p>


<figure class='code'><div class="highlight"><table><tr> <td class='code'><pre><code class=''><span class='line'>for l in L:
</span><span class='line'>  l = sort(l)
</span><span class='line'>f = lambda x,y : [a for a in x if a in filter(lambda b : b &gt;= a, y)]
</span><span class='line'>print reduce(f,L)</span></code></pre></td></tr></table></div></figure>


<p>사실 for loop쓴 sorting도 한 줄에 쓸 수 있을 것 같지만 귀찮으니까 넘어가야지. 으 딱 15초만 더 줬으면 바로 타이핑해서 보여줬을텐데. 시간이 많이 부족하다그래서 그냥 넘어갔다.</p>


<p>두 번째 문제는 input이 어떻게 생겼는지 물어보다가 대답이 내가 원하는 대답이 아니라 그냥 내가 stream을 새로 정의했다. S = [1,2,3,4,1,2,1,4,2,1,&#8230;] 같은 list로 들어온다고 가정하고, 내가 할 일은 이 리스트를 앞에서부터 읽으면서 캐쉬에 넣다가, 캐쉬 메모리가 모자라면 가장 오래 전에 마지막으로 사용된 element를 drop하는 algorithm을 짜는거였다. 이런 초 쉬운걸 기억이 안나서&#8230; 일단 내 대답은 dictionary를 만드는거였다. 참고로 이 문제는 시간이 없어서 말로 때움. 스트림별로 key를 가지는 dictionary를 만들고 value는 키에 해당하는 스트림이 들어왔을 때의 시간 값을 넣는다. 그리고 메모리가 모자라면 dictionary를 보고 가장 오래된 시간을 쓰는 녀석을 지워낸다.. 가 내 솔루션이었는데, 가장 오래된 녀석을 찾는게 log라서 그걸 더 빠르게 할 수 없냐는 질문이 들어왔음. (구체적으로 log라고 한건 아니고, 그때그때 찾는게 비싸니까 더 빠르게 할 수 없냐는 질문) 내가 기억하는 O(1)짜리 data structure가 큐랑 스택 밖에 없어서 그걸 사용해서 막 삽질을 하다가 결국 시간도 모자라고해서 거기에서 멈췄다. 솔직히 이건 시간 더 줬어도 내가 명석하게 해결하지 못했을 듯 ㅠㅠ 이런거 안한지 너무 오래됐다..</p>


<p>마지막에 다 끝나고 질문있냐 물어봐서 블룸버그에서 어떤 언어를 쓰냐 물어봤더니 팀마다 다르단다. 본인은 팀에서 C++랑 Javascript를 사용한다고. 파이썬이나 루비를 사용하는 팀도 있다고 한다. 사실 내가 지금 software internship으로 들어가게 되면 도대체 어떤 position으로 들어가게 되는건지 알 수가 없어서 (pure developer인지 researcher인지 어느 정도 level로 코딩하는지..) 내가 어떤 언어를 쓰게 될지는 모르겠지만, 최소한 내가 가서 고를 수 있는 일말의 여지가 있다면 내가 최대한 잘 할 수 있는 팀으로 배정되면 된다는 결론을 내릴 수 있었다. 뭐 될지는 모르겠지만. 결과는 2~3주 뒤에 나온다고 했으니 또 막 메일 왔다갔다하다보면 한 달 예상해본다. Optimal case라면 2주 뒤인 3월 말에 ICML 리뷰를 보고 결과도 대충 알 수 있을거고 블룸버그 결과도 같이 나오는 셈이다. 이번에는 좀 좋은 결과가 있었으면 좋겠는데..</p>


<p>사실 크게 별 생각안하고 코딩하면서 떨지만 않게 적당히 인터넷에서 <a href="https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions">코딩 인터뷰 관련 글</a>이나 <a href="http://www.bogotobogo.com/python/python_interview_questions.php">문제들</a> 푸는 정도로 몸풀고 인터뷰를 봤는데 굉장히 좋은 경험이 되었다. 영어로 official software engineer job recuiting phone interview라니, 정말 중요한 경험인데 굉장히 어린 나이에 운좋게 경험할 수 있었다. 무엇보다 학위를 마치고 장래에 미국에서 job을 구할 생각을 하고 있는 상황에서 이런 좋은 회사와 phone interview 과정을 겪어보는 것만으로도 진짜 좋은 경험이 되었다. 가서 일을 해보면 훨씬 더 좋은 경험이 될 것 같지만, 그건 내가 결정하는게 아니니 일단은 두고 봐야겠지.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015년 02월 27일 새벽 5시 반]]></title>
    <link href="http://SanghyukChun.github.io/85/"/>
    <updated>2015-02-27T05:34:00+09:00</updated>
    <id>http://SanghyukChun.github.io/85</id>
		<content type="html"><![CDATA[<p>2월 6일. 드디어 짧게 보면 반 년 넘게, 길게 보면 1년이 넘게 진행해온 연구로 논문을 제출했다. 제출한 학회는 ICML. 처음으로 쓰는 논문이고, 처음으로 내가 1저자가 되어 제출하는 논문인데 처음부터 너무 좋은 학회에 제출하게 되었다. 여러모로 운이 좋았다. Author feedback period는 3월 말이나 되어야하고, 최종 decision notification은 4월 25일이다. 만약 accept이 된다면 7월에 프랑스 Lille에서 내 연구를 수 많은 사람들 앞에서 발표하게 된다. 아직 결과가 나오려면 2달 가까이 남았기 때문에 연구에 대한 압박감은 많이 사라졌다. 다만, 추가적으로 더 해보고 싶은 것들이 있어 추가 실험이나 앞으로 시도해볼 분야의 review paper를 읽어야 하는데, 쉽사리 의욕이 나지 않는다.</p>


<p>Paper를 제출하고, 약 2주 반 정도의 휴가를 다녀왔다. 원래는 블로그에 ML study 포스트도 하루에 한 개씩 올리고, 책도 많이 읽고 Machine Learning 공부를 처음부터 천천히 할 수 있는 가장 좋은 시기라고 생각했었는데, 중간에 설 연휴도 있었고 잠깐 외국도 다녀오고 하니까 그럴 수 있는 시간이 하나도 없었다. 아마 머신러닝 공부, 그리고 관련 포스팅은 전부 학기 중에 수업도 들으면서 동시에 진행하게 될 것 같다.</p>


<p>쉬는 것에도 관성이 있는 것 같다. 어제 다시 학교로 돌아왔는데 아직까지 하루 종일 일이 손에 잡히지 않는다.</p>


<p>1월부터 2월초까지는 논문을 쓰는 것에 내 모든 역량을 쏟아부었다. 그래서 그런지 나에게는 이번 겨울이 너무나 짧게 느껴진다. 논문 쓰느라 한참 바쁘게 지내고 잠깐 외국다녀오니 겨울이 끝나있었다. 마찬가지로 2015년도 너무 급작스럽게 찾아왔다. 벌써 3월을 눈 앞에 두고있다니. 남들은 연말에 하거나 연초에 하는 2015년 계획을 오늘에서야 세우게 되었다. 사실 올해 목표 예년과 크게 다르지 않다. 올해 목표는 딱 두 가지인데, 하나는 체중 감량이고 또 하나는 제2외국어 공부이다. 체중감량은 워낙 오래전부터 내세우던 목표이고 제대로 성공한 적이 한 번도 없기 때문에 이번에는 정말 제대로 해봐야겠다. 혼자 계속 운동하다가 정체기가 오는 것 같으면 바로 PT를 받아볼 생각이다. 바로 PT를 받기에는 학교 헬스장이 워낙 시설이 좋아서 돈이 조금 아깝다. 그리고 내가 운동이나 식이요법을 &#8216;몰라서&#8217; 못하는게 아니라 귀찮거나 의지가 부족해서 안하는 것이기 때문에 의지가 부족해졌다고 느낄 때 쯤에 PT를 받아야겠다. 제2외국어공부는 여러가지를 생각해보았으나 역시 내가 빠른 시간에 금방 배울 수 있는 언어는 일본어이다. 오늘 저녁 먹기 전에 학원에 가서 상담받고 등록해야겠다.</p>


<p>한 번 연구를 해보니까 자신감이 생기기도 하지만 반대로 내가 이런 작업을 또 해낼 수 있을까 두렵기도 하다. 다행히 지금 나는 해야 할 일이 명확하니 내가 해야 할 일에 최선을 다해야겠다.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[블로그에 Disqus 설치]]></title>
    <link href="http://SanghyukChun.github.io/82/"/>
    <updated>2014-12-13T04:58:00+09:00</updated>
    <id>http://SanghyukChun.github.io/82</id>
		<content type="html"><![CDATA[<p>예전부터 블로그 댓글 기능을 제대로 만들어야겠다는 생각을 늘 하고 있었는데, 갑자기 삘이 꽂혀서 disqus를 설치했다. 아예 생각난 김에 트윗이나 라이크 버튼도 기능 테스트를 더 해볼까 싶었는데 그건 그냥 귀찮아서 스킵하기로 했다.</p>


<p>사용 방법은 심플하다. <a href="http://www.disqus.com">http://www.disqus.com</a> 에 접속해서 아이디 만들고, 새로 disqus 하나 만든 다음에, 옥토프레스 _config.yml에 disqus short name만 넣어주면 된다.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[맥 요세미티 업데이트 이후 Homebrew 문제점 troubleshooting]]></title>
    <link href="http://SanghyukChun.github.io/81/"/>
    <updated>2014-11-30T03:24:00+09:00</updated>
    <id>http://SanghyukChun.github.io/81</id>
		<content type="html"><![CDATA[<p>나는 맥 OS 장비가 두 개 있다. 하나는 연구실에서 사용하는 아이맥이고 또 하나는 연구실 밖에서 사용하는 맥북프로이다. 이번 요세미티 업데이트는 프리뷰 때 부터 기대를 많이 했기에 나오자마자 바로 두 머신 모두 요세미티 설치를 했다. 그리고 그게 내가 이 글을 쓰게 된 시발점이 되었다.</p>


<p>Homebrew는 맥에서 가장 많이 사용하는 패키지 관리 프로그램 중 하나로, 간단히 생각하면 ubuntu의 apt-get과 같은 역할을 (더 fancy하게!) 해준다. 그런데 문제는 이 녀석이 ruby base로 돌아가고, ruby path가 하드코딩되어있는데, 요세미티는 system ruby의 버전을 강제로 업그레이드시켜버리기 때문에 brew의 모든 명령이 깨진다는 것. 참고로 이건 예전 버전의 homebrew에서나 그렇고, 새로 나온 버전은 아무 문제가 없다.</p>


<p>가장 간단한 해결책은 임시로 brew.rb 파일에 있는 path를 current ruby로 바꿔준 다음 brew를 최신 버전으로 다시 내려받는 것이다. 하지만 늘 인생은 쉽지 않지. 쉬운 길을 눈 앞에 두고 돌아가기 마련인데, 두 머신 모두 (약간의 시간 차이를 두고 한 일이지만) brew를 삭제하고, 다시 설치한다음 rvm으로 ruby 버전을 다시 다운로드 받는&#8230; 삽질을 했다.</p>


<p>그런데 이번에 rvm으로 루비 버전을 먼저 내려받다가, brew가 깨져있는 상황에서 실수로 지금 이미 있는 루비조차 날려버리는 최악의 실수를 해버렸다. 다시 말해 ruby 를 입력해도 아무 반응이 없고, rvm list는 비어있는 최악의 상황. 먼저 rvm install 2.0.0 을 실행했는데, 컴파일이 거의 한 시간 정도의 긴 시간이 지나도 끝나지를 않아 찾아보니 xcode 버전이 낮으면 그럴 수 있다더라. 다시 내 xcode를 보니 5버전.. 최신은 6버전이다. 바로 xcode부터 재설치를 했다. 근데 xcode가 보통 무거워야지.. 설치하는데 시간이 꽤 걸렸다.</p>


<p>xcode 재설치를 끝내고 homebrew를 설치하려고 보니 ruby 명령어를 실행해야하는터라, 강제로 system ruby path에 들어가 system ruby로 실행을 시켰다. brew를 제대로 지우지 않은 상황이라면 시키는대로 하면 된다. 설치 후에는 brew doctor 한 번 돌려줘야한다. 꼬여있는 dependency를 정리해야하기 때문.</p>


<p>이제 rvm install 2.0.0, rvm install 1.9.3, rvm install 2.1.5 모두 잘 실행된다. (라고 적었지만 사실 1.9.3은 gcc48설치하는게 너무 오래 걸려서 아직 끝은 안난게 함정&#8230;)</p>


<p>Gitlab도 그렇고, 지금 쓰고 있는 Octopress도 그렇고, 많은 웹에서 쓰는 프레임워크 혹은 어플리케이션들이 rails 기반, 루비 기반인 경우가 많아 이런 문제가 왕왕 생기고는 하는데, 당황하지 않고 천천히 찾아보면 해결하는게 크게 어렵지는 않다. 루비는 sudo user로 설치하는게 아니다보니까 더 쉬운 듯. 가장 중요한건 인내심을 가지는 것. 너무 이상할 정도로 오래걸리는건 생각해볼 필요가 있지만, 대부분의 경우 생각보다 시간이 훨씬 오래 걸린다.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitlab을 깔자]]></title>
    <link href="http://SanghyukChun.github.io/80/"/>
    <updated>2014-11-20T03:05:00+09:00</updated>
    <id>http://SanghyukChun.github.io/80</id>
		<content type="html"><![CDATA[<p>버전관리의 중요성은 몇 번을 강조해도 부족하지 않다. 버전관리를 하기 위한 여러 도구들이 존재하지만, 난 분산 버전 관리 (DVCS) 를 좋아한다. Mercurial 로 처음 버전관리를 공부했고, 지금은 주로 Github에 소스를 올리기 때문에 git 을 많이 쓰고 있다. 콘솔에서는 큰 차이가 있지만, 정작 둘 다 <a href="http://www.sourcetreeapp.com/">SourceTree</a>로만 관리하기 때문에.. 예전에는 맥버전만 있었지만, 이제는 윈도우 버전도 생겨서 다른 사람들도 용이하게 쓸 수 있다. 이런 이유로 최근에는 거의 모든 레포지토리를 git 레포지토리로 만들게 되는데, 연구실에서 내가 쓰고 있는 논문이나 프로젝트용 코드 같은 경우는 공개된 레포지토리로 올려도 곤란하고, 연구실 단위로 관리를 해야할 필요를 느껴서 <a href="https://about.gitlab.com/">GitLab</a>이라는 놈을 깔아보기로 헀다.</p>


<p>Gitlab을 한 마디로 요약하자면 &#8216;개인용 github&#8217; 라고 할 수 있다. 코드를 훑어보니 rails 기반에 nginx를 서버로 사용하고 있어서 내가 친숙한 환경이기도 해서 좋더라. 늘 깔아야지 깔아야지했는데 이게 생각보다 설치가 머리가 아파서.. 나중에 시간이 넉넉해지면 설치하려 했으나 어쩌다보니 갑작스럽게 설치를 하게 되었다.</p>


<p>내 설치환경은 Ubuntu 14.04, <a href="https://about.gitlab.com/downloads/">다운로드 페이지</a>에서 ubuntu 14.04를 선택하는 아래와 같은 명령어를 실행하면 알아서 옴니버스 버전을 깔아준다고 한다.</p>


<figure class='code'><div class="highlight"><table><tr> <td class='code'><pre><code class=''><span class='line'>wget https://downloads-packages.s3.amazonaws.com/ubuntu-14.04/gitlab_7.4.3-omnibus.5.1.0.ci-1_amd64.deb
</span><span class='line'>sudo apt-get install openssh-server
</span><span class='line'>sudo apt-get install postfix # Select 'Internet Site', using sendmail instead also works, exim has problems
</span><span class='line'>sudo dpkg -i gitlab_7.4.3-omnibus.5.1.0.ci-1_amd64.deb</span></code></pre></td></tr></table></div></figure>


<p>난 openssh-server, postfix는 깔려있으니 생략했다.</p>


<p>다음으로는 <code>sudo vim /etc/gitlab/gitlab.rb</code> 를 실행해 <code>gitlab.rb</code> 를 수정해야한다. 다시 한 번 말하지만, gitlab은 rails로 돌아가기 떄문에 rails setting 을 해줘야한다. 원래 레일즈 프로젝트의 설정을 바꾸기 위해서는 yml 파일이나 다른 rb 파일들을 직접 수정해주어야하는데, gitlab 옴니버스 버전에서는 친절하게 이 루비 파일 하나만 바꾸면, 알아서 yml 등을 generate해준다. 아 편하고 좋다! 라고 생각했지만 이것이 그 모든 재앙의 시작이었다..</p>


<p>편하게 해주려고 만든 ruby setting 파일이 왜 문제가 되었느냐, 사실 이 대부분은 문제가 생기지 않는다. 예를 들어서 <code>www.example.com</code> 이라는 도메인을 가지고 있고, gitlab 의 접속 경로를 <code>gitlab.example.com</code> 으로 사용한다면 옴니버스 버전을 바로 사용하면 된다. 하지만 내가 사용하는 서버는 학교 도메인에서 서브도메인을 받아서 사용하기 때문에 <code>sanghyuk.kaist.ac.kr</code> 이런 식의 도메인을 가지고 있다. 따라서 위와 같은 경로를 취하게 되면 <code>gitlab.sanghyuk.kaist.ac.kr</code> 이라는 기괴한 경로가 생기게 되고, 당연하지만 이런 경로는 허용되지 않는다. 따라서 <code>sanghyuk.kaist.ac.kr/gitlab</code> 같은 relative domain을 사용해야한다. nginx에서 이런 서브 도메인을 루트로 삼는 것은 규칙에 위반되지만 사용하는 것이 가능하긴하다. rails에서도 root url을 relative url로 바꾸고 하면 돌릴 수 있지만.. 이건 내가 rails파일을 직접 바꿀 때 얘기였다.</p>


<p>옴니버스 버전에서 이런저런 삽질을 하다가 찾아낸 이슈.. <a href="https://gitlab.com/gitlab-org/omnibus-gitlab/issues/238">옴니버전에서는 Relative URL root를 지원할 계획이 없다</a> 아&#8230; <code>gitlab.rb</code> 에서 삽질을 하고 있었는데 다 쓸데 없는 짓에 불과했던 것이다.</p>


<p>그래서 relative url은 포기하고 다른 쪽으로 알아보니 포트를 바꿔서 접속을 하는 방법이 있더라. 이건 그나마 훨씬 할 만 헀다. <code>/etc/gitlab/gitlab.rb</code> 에서 다음과 같이 설정해준다.</p>


<figure class='code'><div class="highlight"><table><tr> <td class='code'><pre><code class=''><span class='line'>external_url = 'http://sanghyuk.kaist.ac.kr:1234'</span></code></pre></td></tr></table></div></figure>


<p>아 참고로, 내가 깐 버전은 = 을 안쓰면 에러가 나서 내가 = 을 따로 넣어줬다. 옴니버스 버전별로 다른 모양</p>


<p>이렇게 하고 <code>sudo gitlab-ctl reconfigure</code> 을 실행시켜서 yml 등을 자동으로 generate시키기만 하면 문제 해결! &#8230; 이 아니었다. 아예 접속 자체가 되지를 않아서 이제 여기에서 다시 삽질을 시작했는데, 먼저 netstat으로 포트는 열려있나 봤다. 안타깝게도 아예 포트가 열려있지도 않았다. 돌아버리겠는건 <code>gitlab-ctl status</code> 에서는 잘 실행되는 것으로 나오는 것.</p>


<p>이제 또 한참 삽질을 하다가, 아예 nginx 조차 돌아가는 것 같지 않아서 nginx 세팅을 수동으로 뜯어고치기로 결정했다. 이게 상당히 위험한 짓인데, 나중에 내가 생각없이 또 reconfigure를 때리면 내가 고친 파일들이 새로운 파일들로 덮어씌일 것이기 때문이다. 때문에 이렇게 설정을 시작한다면 reconfigure 대신 <code>gitlab-ctl restart</code> 로 configure 파일을 다시 생성시키지 말고 레일즈랑 nginx 등만 내렸다가 올려야한다. 이제 세팅을 바꿔보자.</p>


<p>가장 먼저 nginx 설정을 찾아봤다. <code>/var/opt/gitlab/nginx/conf/gitlab-http.conf</code> 에 설정 파일이 있는데, listen과 server name이 엉망으로 되어있더라. 당연히 nginx가 설정이 잘못되었으니 서버에 접속도 못하고 포트도 안열려 있던 것. 이 둘을 제대로 바꿔주고 restart를 했다.</p>


<p>드디어 &#8216;페이지를 찾을 수 없습니다&#8217; 창말고 다른 창을 볼 수 있었다. 그러나 여기에서 또 502 에러가 발생했는데, 아마도 내부 rails가 제대로 올라오지 않은 모양인가보다. 그래서 혹시 레일즈 세팅도 이상한가 싶어서 yml 파일을 찾아봤다.</p>


<p><code>/var/opt/gitlab/gitlab-rails/etc/gitlab.yml</code> 을 열어봤더니 여기도 host랑 port가 엉망이었다. 이 부분을 바꿔주고 나서 다시 <code>sudo gitlab-ctl restart</code></p>


<p>아 드디어 잘 실행된다. 기존에 쓰던 다른 레포지토리를 추가해주기 위해서 <a href="http://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%A0%80%EC%9E%A5%EC%86%8C">remote</a>를 해주려고 보니 ssh key를 생성해서 넣어줘야 하더라. 이건 <a href="http://git-scm.com/book/ko/v1/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0">이 글</a>을 보면 된다. 이건 예전에 다 등록해뒀던거라서 금방금방했다. 조금 가지고 놀아보니 아직까지는 매우 만족스럽다.</p>


<p>이렇게 일단 주먹구구식으로 깃랩을 돌리는 것에는 성공했지만, 아직 reconfigure를 함부로 하면 안된다. 내가 바꾼 <code>/var/opt/gitlab/gitlab-rails/etc/gitlab.yml</code>, <code>/var/opt/gitlab/nginx/conf/gitlab-http.conf</code> 는 <code>gitlab-ctl reconfigure</code> 를 할 때 자동으로 generate 되는 파일이다. 따라서 내가 바꾼 설정이 저장이 되지 않기 때문에 함부로 reconfigure를 했다가는&#8230; 나중에 시간이 나면 이 부분을 gitlab.rb 만 바꿔서 수정할 수 있는지 알아보자.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[새로운 front framework Webplate에 대한 소견]]></title>
    <link href="http://SanghyukChun.github.io/79/"/>
    <updated>2014-10-10T02:30:00+09:00</updated>
    <id>http://SanghyukChun.github.io/79</id>
		<content type="html"><![CDATA[<p>얼마전 <a href="http://getwebplate.com/">Webplate</a>라는 front-end framework를 접하게 되었는데 상당히 좋은 인상을 받아서 블로그에 소개 겸 사용 소감을 남겨보려 한다.</p>


<p>그 동안 내가 웹을 개발하면서 느꼈던 가장 불편한 점은, 디자이너가 없이는 내가 할 수 있는 것들이 상당히 제한된다는 것이었다. 그러던 와중에 <a href="http://getbootstrap.com/">twitter bootstrap</a>을 알게 되었고, 덕분에 상당히 많은 웹 페이지들을 만들 수 있었다. 이 블로그도 그렇고, 내 aboutMe 페이지도 그렇고 홈페이지도 그렇고 요즘 만들고 있는 연구실 홈페이지도 그렇고.</p>


<p>하지만 bootstrap을 사용하면서 불편한 점이 없는건 아니었다. Bootstrap은 매우 훌륭한 디자인 가이드를 제공하고 있기는 하지만, 결국 기본적인 웹 frame조차 내가 처음부터 html 코딩을 해야하는 점은 매우 귀찮은 일이 아닐 수 없었다. 지금은 이것에 어느 정도 익숙해지고 내가 내 나름의 template을 가지게 되었지만 그 이전에는 html부터 코딩을 하는 것이 여간 귀찮은 일이 아니었다. 특히 aboutMe만들 때 생각하면&#8230; 정말 끝없이 고치고 또 고쳤던 기억이 난다.</p>


<p>그러던 와중 webplate를 보게 되었는데, 처음 본 순간 정말 센세이션이었다. 마침 <a href="https://github.com/chrishumboldt/webplate">github</a>도 있길래 fork해서 한 10분 정도 둘러봤는데,</p>


<ol>
<li>Twitter Bootstrap과 비교를 하지 않을 수 없는데, 사실 Webplate에서 가능한건 Bootstrap에서도 다 가능할 뿐 아니라 자유도 역시 Bootstrap이 더 좋다. 하지만 Bootstrap에서는 내가 다 구현을 했어야했던 것들이 Webplate에서는 구현이 되어있다는 것이 좋은 듯. 
한 마디로 Bootstrap은 style에 대한 기본 base느낌이라면 Webplate는 진짜 front framework다</li>
<li>비록 내가 따로 설정을 해줘야하지만, example project에서 기본 글씨체를 Lato로 강제해서 참 좋다. Open Sans 애리얼 헬베티카 꺼졍&#8230;</li>
<li>다시 framework에 대한 얘기인데, pre태그 에서 코드 이쁘게 보여주는 기능을 class로 부르기만 하면 되게 구현이 되어있어서 짱짱 편하다. 내가 라이브러리 찾아서 부를 수도 있지만 귀찮으니까&#8230; </li>
<li>기본적으로 필요한 대부분의 라이브러리가 포함되어있다. response.js를 포함해서! 때문에 반응형으로 만들기도 편하고 호환에 대한 두려움 없이 작업을 하는게 가능하지만 ie에서 완전 호환이 되는지 잘 모르겠다. (아마 되겠지)</li>
<li>이 framework 자체가 vertical UI를 강제하고 있다. 최근 핫한 UI이기는 하지만 (stripe UI같은거) 다른 모양을 원하는 경우에는, 특히 상단 바가 아니라 좌측에 메뉴를 넣고 싶은 경우라면 이 framework을 쓰는게 아니라 따로 만들어야할 것 같다. (하지만 요즘 모든 웹은 다 기본이 vertical UI..)</li>
<li>Service, Product 등의 introduction page를 간단하게 만들 생각이라면 이보다 더 Cool한 web framework는 없어보인다. (전시회 소개나 festival page로도 좋을 것 같네) 그 이외에 어떤 곳에서 이 framework를 사용할 수 있을지 아직은 잘 모르겠다. Vertical UI를 쓸 수 있는 곳이라면 전부 쓸 수 있을 것 같기는 하다.</li>
</ol>


<p>한 마디로 간단하게 만들 수 있는 웹은 이 녀석으로 대략 커버가 가능하다는 점, 그리고 반응형에 대한 이슈를 내가 따로 고민할 필요가 없다는 점이 너무 마음에 들었다. <a href="http://getwebplate.com/documentation">Document</a>링크를 첨부할테니 관심있는 사람들은 한 번 읽어봤으면 좋겠다. 최근 이걸 사용해 따로 개발할 웹이 없어서 정작 내가 사용해볼 수가 없다는게 아쉽기는하다.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[모바일 시대 Platform에 대한 고찰]]></title>
    <link href="http://SanghyukChun.github.io/77/"/>
    <updated>2014-10-10T02:27:00+09:00</updated>
    <id>http://SanghyukChun.github.io/77</id>
		<content type="html"><![CDATA[<p>얼마 전 MS에서 윈도우10의 preview를 발표하였다. <a href="http://www.bloter.net/archives/208421">블로터 기사</a>를 참고하면 알 수 있 듯, 아직 테크니컬 프리뷰 단계이기는 하지만 MS가 어떤 철학을 가지고 이런 운영체제를 디자인했는가는 어렵지 않게 예상할 수 있다. 스마트폰과 태블릿 데스크톱 그리고 콘솔 등에 이르는 수 많은 isolate 되어있는 기기들을 통합으로 관리할 수 있는 하나의 거대한 통합 플랫폼을 만들어내겠다라는 의지가 바로 그것이다. <a class="red tip" title="소문에 의하면 95,98 버전 확인을 windows 9가 포함이 되었느냐 아니냐로 하기 떄문이라고.">왜 8다음에 10이냐는 이슈는 넘어가고</a> 과연 MS의 이런 행보가 어떤 파장을 일으킬 수 있을지에 대해 생각해보고 싶어졌다.</p>


<h5>모바일 모바일 모바일</h5>


<p>그래 바야흐로 모바일의 시대가 도래하였다고 해도 과언이 아니다. 내 블로그에 붙여놓은 google analytics를 보니까 내 블로그는 PC가 약 75%, 모바일이 약 18%, 그리고 태블릿이 약 7% 정도의 접속률을 보이고 있다. 즉, 내 블로그를 읽는 사람들의 행동 양식만 보고 비교를 하자면 아직은 PC로 웹을 보는 사람들이 모바일이나 태블릿 (합쳐서 모바일이라 하자) 으로 웹을 보는 사람들에 비해 약 5배 정도 많다. 그러나 이것은 내 블로그가 특수한 환경에 처한 것이고 (대부분의 유입이 구글 검색이고 키워드가 머신러닝이니까..) 실제 전체 웹을 보게 되면 상황이 많이 달라진다. StatCounter의 <a href="http://gs.statcounter.com/#all-comparison-ww-monthly-201309-201409">global stats page</a>를 참고해보면 모바일의 비중이 거의 30% 가까이를 차지하고 있으며, 태블릿까지 포함하면 약 37~8% 정도에 육박한다는 사실을 알 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/77-1.png" width="500"></p>

<p>이 속도가 엄청나게 빠르게 증가하고 있다는 사실이 바로 그것인데, 불과 1년 사이에 모바일 뷰가 17%에서 거의 30%까지 증가한 것이다. 거의 75% 가까이 증가한 셈이다. 지역을 한국으로 좁혀서 보게 되면 (<a href="http://gs.statcounter.com/#all-comparison-KR-monthly-201309-201409">링크</a>) 우리는 상대적으로 태블릿의 점유율은 엄청 낮은 대신, 모바일의 비중이 매우 높다는 것을 알 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/77-2.png" width="500"></p>

<p>그리고 어느 정도 1년 동안의 변화 정도가 일정한 것을 알 수 있다. 경험적으로 비춰보았을 때, PC를 거의 사용하지 않고 모바일로만 보는 사람들이 그만큼 많아졌다는 뜻이 아닐까라고 생각된다.</p>


<p>그리고 또 이렇게 general하게 전체 웹 view만 보는 것이 아니라 큰 서비스로 시선을 돌리면 또 얘기가 달라진다. <a href="http://www.nasmedia.co.kr/">나스미디어</a>의 <a href="http://lib.nasmedia.co.kr/file/534f5d4242381">2014년 NPR (Netizen Profile Research)</a> 에 의하면, PC 인터넷 이용자의 스마트폰 이용률이 현재 88.1%에 육박하며 이는 전년 대비 11.5% 상승한 결과라고 한다. 그리고 사실 정말 재미있는 지표는 11쪽에 있는 SNS 접속 디바이스인데, 싸이, 미투, 구글플러스와 같은 마이너한 서비스는 제외하고 (심지어 미투데이는 올해 서비스를 종로했다 ㅠㅠ) 아래에서 볼 수 있듯 모바일의 비중이 매우 높다는 것을 알 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/77-3.png" width="600"></p>

<p>즉, 이제 모바일은 절대로 무시할 수 없는 현실이라는 것을 데이터가 보여주고 있는 것이다.</p>


<p></p>

<h5>모바일 사용자, PC 사용자</h5>


<p>그런데 내 생각에 저런 수치들이 제대로 반영하지 못하는 하나의 현실이 더 있다. 바로 극명하게 다른 PC 사용자와 모바일 사용자들의 성향이다. 모바일 사용자는 처음 몇 번의 시도 후 제대로 동작하지 않는 것 같다고 느끼면 그냥 서비스에서 이탈해버리고 다시 돌아오지 않는 경우가 많다. 즉, 이탈률이 매우 높다. 따라서 이탈을 하지 않도록 사용자에게 빠르게 지속적으로 동작을 유도해야한다. 또한 PC에 비해 모바일의 화면이 더 작아 너무 많은 정보를 한 번에 받는 것에 대해 부담을 느낀다. 마지막으로 그 둘의 역할이 많이 분리가 되었다. 간단한 검색이나 기사 읽기 등 &#8216;이건 내가 모바일로도 할 수 있겠다&#8217; 하는 일들이라면 모바일에서 처리하는 유저의 비중이 높은 반면, 복잡한 멀티프로세싱을 해야하는 경우라면 PC가 더 사용률이 높다. 다시 말해, PC와 모바일은 비슷해보일지 몰라도 자세히 보면 완전히 다른 성향을 가지고 있는 별개의 플랫폼이다. 즉, 어떤 서비스를 개발했을 때, 완전히 다른 두 개의 플랫폼에서 이 서비스를 동시에 지원할지 말아야할지 염두해두어야하며, 만약 동시에 지원하는 경우 이 작업을 꼭 PC앞에서 해야하는 강력한 motive 가 있는게 아니라면 많은 사람들은 모바일로 그 서비스를 접근하려 할 것이라는 말이다. 그게 웹이되었거나 앱이 되었거나.</p>


<h5>Mobile First</h5>


<p>Start up 쪽에서 흔히 많이 하는 말 중에 Lean Start up 이라거나, Mobile first 등의 용어가 있다. [Mobile first: <a href="http://www.lukew.com/ff/entry.asp?933">링크1</a>, <a href="http://study.gnuboard.org/wiki/read/studygroup/rwd/Mobile-First-and-RWD">링크2</a>, <a href="http://h30458.www3.hp.com/kr/ko/discover-performance/it-execs/2012/oct/1243352.html">링크3</a>], [Lean Startup: <a href="http://theleanstartup.com/">링크1</a>, <a href="http://www.jimmyrim.com/153">링크2</a>, <a href="http://platum.kr/archives/tag/%EB%A6%B0%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85">링크3</a>]</p>


<p>Mobile first는 간단히 얘기하면 처음 시작점을 무조건 모바일에 맞춰서 시작을 하라는 의미이다. 이유는 (1) 모바일이 점점 거대해지고 있으며 (2) 모바일 개발에만 치중하면서 적은 리소스를 한 곳에 집중할 수 있을 뿐더라 (3) 모바일에 포함되는 많은 기술들이 (GPS, Multi-touch UI 등) 기존 웹에서 사용되는 javascript 기반의 PC-based Web보다 더 많은 사용자 경험을 줄 수 있기 때문이라는 것이다. 내 생각에도 지금 같은 서비스를 사용하더라도 많은 사람들이 mobile로 그 서비스를 access하는 경우가 점점 늘어나고 있으며, 만약 모바일과 웹이 있을 때 하나를 선택하라고 했을 때 모바일로 접속을 하는 사람들이 많아지고 있는 지금, 웹을 먼저 개발하기 보다는 모바일에 먼저 치중한 이후 나중에 웹으로 확장을 하는 편이 더 좋다고 생각된다. (때에 따라서는 PC 지원을 아예 하지 않는 경우도 존재한다) 하지만 Mobile first를 할 때 주의해야할 점들이 몇 가지가 있는데, 가장 중요한 것은 품질관리이다. 모바일은 아주 빠르게 변화하는 곳이기 떄문에 더 빠른 업데이트와 대응이 필수적인데, 자칫잘못했다가는 제품의 품질이 떨어지고 앱의 평점과 리뷰가 부정적인 방향으로 바뀔 수 있기 때문이다. 또한 현재 모바일 앱의 특성상 나쁜 리뷰와 별점은 추가적인 앱 다운로드에 악영향을 미친다. 따라서 이 <a href="http://h30458.www3.hp.com/kr/ko/discover-performance/it-execs/2012/oct/1243352.html">Mobile first: 링크3</a>에서 제안하는 방법은 애자일 프로세스이다. 기존의 느린 의사결정 방식으로 모바일 애플리케이션을 대해서는 안된다는 의미이다. 더 빠르고 더 기민하게 움직여야만한다. 그리고 난 그런 흐름 속에서 Mobile first가 Lean startup과의 시너지를 도모할 수 있다고 본다. 하지만 애자일을 도입해도 근본적인 제약조건이 존재하는데, (1) 작은 화면, (2) 네트워크 품질 (3) 기기의 성능 이 그것이다. 이 부분에 대해서는 뒤에 더 자세히 다뤄보도록하자.</p>


<p>Lean startup은 일종의 프로덕트 개발 방법론 중 하나인데, 애자일한 개발, 완성되지 않은 프로토타입의 시장 진출, 고객과의 긴밀한 피드백루프 구축 등으로 구성이 되어있다. 기본적인 아이디어는 waterfall 식의 느린 의사결정으로 회사를 운영하거나, 제품을 개발하지 말고, 최대한 lean하게, 혹은 애자일하게 일단 빨리 빨리 무엇을 만들어보고 시장의 반응을 보고 버리거나 다른 식으로 develop을 하라는 얘기이다. 때문에 방금 전에 언급했던 Mobile first와 상당한 시너지를 일으킬 수 있는데 기본적으로 애자일 방법론을 기반으로 하기 때문에 위에서 언급했던 빠른 대응이나 지속적인 배포를 하기에 매우 용이하며, 프로토타입 단계에서 시장에 대한 가설을 테스트할 때에도 모바일에서 먼저 가설을 테스트해보고 더 크기를 키워도 되겠다는 결정을 내리고 나서 웹이나 다른 플랫폼으로의 확장을 결정하라는 것이다. 린스타트업에 대해 파고들어가기 시작하면 너무나 많은 얘기를 해야하기 때문에 깊은 얘기는 가급적 피하도록 하겠지만, 분명 린스타트업은 모바일퍼스트와 궁합이 잘 맞는 조합임에 분명하다.</p>


<p>모바일퍼스트니, 린스타트업이니 하는 거창한 얘기를 하지 않더라도 내가 어떤 서비스를 만든다고 하면 이제는 항상 모바일에 대한 생각을 하지 않을 수 없다. 이 서비스를 지금은 모바일에서 지원할 예정이 없더라도 추후 모바일에서도 지원할지, 아니면 모바일에서만 지원할지 나중에 웹으로 확장을 할 것인지. 네이티브 앱으로 만들 것인지 아니면 웹으로 만들어서 모바일 뷰를 따로 만들 것인지. 모바일 뷰를 따로 만들 것인지 아니면 반응형으로 만들어서 하나의 통합 url로 관리를 하게 할 것인지. 이 모든 것들을 반드시 처음에 한 번 쯤은 생각을 해야만 한다.</p>


<h5>모바일의 제약조건</h5>


<p>그런데 모바일이 만능 키인 것은 아니다. 모바일은 근본적으로 하드웨어에서부터 기인하는 여러 문제점들을 떠안고 있기 때문이다. (1) 작은 화면 (2) 모바일 네트워크 (3) 기기의 성능이 그것이었다.</p>


<p>먼저 작은 화면은 UI적인 측면에서 엄청난 변혁을 일으켰다. 기존의 PC-based 서비스들은 (웹 기반인 경우) 처음 보이는 웹에 굉장히 많은 정보들을 넣고 사용자가 그 정보들을 알아서 고르게하는 방식을 선택했었다면, 모바일로 넘어오고 나서는 그 화면의 크기가 어마어마하게 줄었기 때문에 (간단하게 생각해보면 22인치 모니터에서 5.5인치 아이폰6플러스는 화면의 크기가 16배 차이가 난다.) 처음 보여주는 정보의 양도 제한적일 수밖에 없고 또한 UI 역시 2차원적인 UI가 아니라 스크롤이 들어가는 1차원 세로형 UI가 강제 된다. 때문에 모바일에 익숙하지 않은 상태에서 UX를 web을 만들듯 디자인을 하게 되면 사용자 입장에서는 별로 좋지 못한 UX를 경험할 수 밖에 없는 것이다. 하지만 화면이 작기 때문에 채워야하는 정보의 양도 적고, 내가 어떤 정보를 보여줘야 더 효율적일지 더 고민할 수 있는 여지가 있기 때문에 오히려 작은 화면이 더 좋은 서비스를 개발하는데에 도움이 된다는 주장도 존재한다.</p>


<p>다음으로 모바일 네트워크의 문제는 LTE로 넘어오면서 거의 해결이 되었다. 하지만 아직도 다른 국가들을 봤을 때 3G 이상의 망이 이렇게 보급이 된 곳은 많이 없고, 또한 모바일 유저는 데이터 소모에 매우 민감하기 때문에 앱을 설계할 때 네트워크 리소스에 대한 고민을 해야할 필요가 여전히 존재한다.</p>


<p>마지막으로 기기의 성능 문제가 있다. 이건 꽤나 치명적인데, Web을 생각해보자. 웹은 서버에서 모든 로직이 실행되고 사용자 컴퓨터의 성능에 좌우되는 것은 랜더링을 하는 브라우져 뿐이었다. 즉, 동적으로 무언가를 생성하는 스크립트 등의 속도가 다소 느려질 수 있는 문제를 제외하면 대부분의 속도에 관련된 문제는 서버side에서 해결해야하는 경우가 대다수였다. 하지만 모바일로 넘어오면서 얘기가 완전히 달라졌는데, 먼저 PC보다 브라우져의 성능이 크게 저하되었고, 스마트폰의 여러 리소스를 사용하는 일은 그만큼 배터리 소모를 빠르게하고 스마트폰의 성능을 저하하는 요소가 되었기 때문에 상당히 많은 부분에서 희생을 해야한다. 물론 서비스를 한다는 것 부터가 이미 서버를 사용한다는 의미가 되기 때문에 크게 문제가 없을 수도 있지만, 이는 분명 PC에 비해 어마어마한 단점이다.</p>


<h5>결론1: 모바일을 대하는 우리의 자세</h5>


<p>이제 모바일은 절대로 무시할 수 없는 거대한 공룡이 되어가고 있다. 새로운 서비스를 시작할 때 거의 99.9% 이상 모바일퍼스트를 선택해야하며 이에 따라 필연적으로 애자일방법론, 더 나아가 린스타트업을 적용해야할 필요가 있다. 그러나 근본적으로 모바일의 제약조건이 존재한다는 점은 꽤나 치명적인데, 그만큼 한 서비스를 만들 때 처음부터 모바일에 모든 리소스를 부어가며 시작할 필요가 있다는 것이다. 그리고 모바일 이외의 환경으로 확장하는 것도 항상 염두를 하며 서비스 아키텍쳐 설계를 할 때 이에 대한 문제를 항상 생각을 할 필요가 있을 것이다.</p>


<h5>결론2: 통합 플랫폼을 만드려는 MS의 행보는 어떤 결과를 가져올까</h5>


<p>앞서 설명했듯 MS는 새로운 통합 플랫폼에 대한 원대한 야망을 가지고있다. 하지만 나는 이것이 별로 효과가 없을 것이라고 생각하는데, (1) 모바일과 웹을 동시에 지원하는 것이 아니라 어차피 모바일에만 집중해야하는데 두 개를 전부 고려해서 설계를 하면 리소스가 분산이 되기 쉽다. (2) 모바일과 PC의 사용자 성향은 극도로 다르기 때문에 PC에서 주었던 경험을 모바일에서 그대로 주는 것이 항상 능사는 아니다. (3) PC와 모바일 둘 다 이미 어느정도 정형화된 경험이 존재하는데, 그 경험을 깨어가면서까지 새로운 윈도우를 사용하게할 유인요소가 보이지 않는다. 결론적으로 서비스를 만드는 입장에서 결론적으로는 모바일과 PC는 함께 가져가야할지 모르지만, 처음 시작하는 단계에서부터 반드시 같이 가져가야하는 것은 아니기 때문에 나는 윈도우10 역시 좋은 평가를 받지 못할 것이라 생각된다.</p>




<h5>References</h5>


<ul>
<li>StatCounter <a href="http://gs.statcounter.com/#all-comparison-ww-monthly-201309-201409">global stats page</a></li>
<li><a href="http://www.nasmedia.co.kr/">나스미디어</a>의 <a href="http://lib.nasmedia.co.kr/file/534f5d4242381">2014년 NPR (Netizen Profile Research)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (7) Convex Optimization]]></title>
    <link href="http://SanghyukChun.github.io/63/"/>
    <updated>2014-09-10T06:28:00+09:00</updated>
    <id>http://SanghyukChun.github.io/63</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Machine learning 문제를 풀다보면 Objective function을 만들고 그 objective function을 optimize 해야하는 경우가 매우 빈번하게 발생한다. 간단히 생각해서 loss function을 minimize하는 것도 optimization이다. 그렇다면 그런 optimization은 도대체 어떻게 해야하는 것일까. 여러가지 방법이 있겠지만 이번 글에서는 간단한 optimization이라는 것에 대한 컨셉을 다루고, 그 중 특수 케이스인 convex optimization에 대해 다루도록 하겠다.</p>


<h5>Optimization</h5>


<p>대부분의 Optimization은 아래와 같은 식으로 표현할 수 있을 것이다.</p>


<p>$$ \min f(x) \text{ s.t. } g(x) = c $$</p>


<p>여기에서 \(f(x), g(x)\)는 함수이다. 어떤 함수의 optimum point, 즉 그것이 최소이거나 혹은 최대인 지점을 찾는 과정을 optimization이라고 한다고 생각하면 간단할 것이다. 엄청 간단하게 생각해보면 \(f(x)\)는 loss function이고, \(g(x)\)는 일종의 constriants로 생각하면 될 것 같다. Machine learning 문제를 풀다보면 이렇게 optimization을 해야하는 일이 아주 빈번하게 발생하는데, 안타깝게도 항상 이런 function들의 optimum point를 찾을 수 있는 것은 아니다. 가장 간단하게 생각했을 때 이런 point를 찾는 방법은 미분을 하고 그 값이 0이 되는 지점을 찾는 것인데, 안타깝게도 미분 자체가 되지 않는 함수가 존재할 수도 있으며, 미분값이 0이라고 해서 반드시 극점인 것은 아니기 때문이다. (saddle point를 생각해보자.) 따라서 대부분의 경우에 이런 방법으로 극점을 구하는 것은 불가능하며, 매우매우 특수한 일부 경우에 대해서 완전한 optimum을 찾는 것이 알려져 있다. 그리고 그 경우가 바로 convex optimization이다.</p>


<h5>Convex function</h5>


<p>Convex function은 convex한 function을 의미한다. 이때 convex는 한국어로 옮기면 볼록에 가까운데, convex function은 볼록 함수라고 번역할 수 있다. Convex가 무슨 의미인지 차근차근 알아보자. 먼저 <a href="http://en.wikipedia.org/wiki/Convex_set">convex set</a>에 대해 알아보자. 어떤 set이 convex하다는 것의 의미는 그 set에 존재하는 그 어떤 점을 잡아도 그 점들 사이에 있는 모든 점들 역시 그 set에 포함되는 set을 알컬어 convex set이라고 부른다. 따라서 convex한 set을 그림으로 그리게 되면 움푹하게 파인 지점 없이 약간 동글동글한 모양을 하고 있을 것이다. 그렇다면 이제 convex function을 정의해보자. Convex function은 domain이 convex set이며, 함수는 다음과 같은 성질을 만족해야한다.</p>


<p>$$ f(\lambda x_1 + (1-\lambda x_2) \leq \lambda f(x_1) + (1-\lambda) f(x_2)) \text{ for } \forall x_1, x_2 \in X, \forall \lambda \in [0,1] $$</p>


<p>즉, 아래와 같은 함수는 convex function이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-1.png" width="500"></p>

<p>Convex function이 좋은 이유는 반드시 optimal한 값이 하나 밖에 존재하지 않는다는 것이다. 여기에서 내가 optimal point가 하나라고 얘기하지 않은 이유는 아래와 같은 예가 있기 때문이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-2.png" width="500"></p>

<p>이 함수는 optimal한 값은 unique하게 존재하지만, 그 값을 가지는 point가 unique하지는 않다.</p>


<p>따라서 unique한 optimal point를 찾기 위해서는 하나의 조건이 더 필요한데, 바로 strictly convex라는 조건이다. 이 조건은 위의 식에서 = 이 빠진 형태이다. 즉 &le; 가 &lt; 으로 바뀌는 것이다.</p>


<p>이런 strictly convex function에 대해서 optimal point가 unique하게 존재한다는 것을 증명할 수 있으며, 증명과정은 크게 어렵지 않으니 <a href="http://math.stackexchange.com/questions/345865/strictly-convex-function-and-well-separated-minimum">링크</a> 등을 참고하면 될 것 같다. 아무튼 strictly convex function은 minimum point가 unique하게 존재하기 때문에, 이런 convex function에 대해서 우리는 어떤 optimization algorithm을 design할 수 있다.</p>


<h5>Convex Optimization</h5>


<p>Convex function \(f, g_1, g_2, &#8230;, g_m\)에 대해 아래와 같은 optimization 문제를 Convex optimization이라 정의한다.</p>


<p>$$ \min f(x) \text{ subject to } g_i (x) \leq 0, \text{ i = 1,&#8230;,m}$$</p>


<p>모든 함수들이 convex하기 때문에 이 optimization의 solution은 unique하며, 이런 optimization 문제를 풀 수 있는 방법은 아주아주 많이 존재한다.</p>


<p>이런 convex optimization의 subset으로 linear programming, quadratic programming, semidefinite programming 등이 존재한다. 이 글에서는 그런 특수한 경우는 다루지 않고, 일반적인 convex optimization에서 사용할 수 있는 알고리듬들을 다룰 예정이다. 크게 gradient descent method, newton method, 그리고 lagrange multiplier가 그것이다.</p>


<h5>Gradient Descent Method</h5>


<p><a href="http://en.wikipedia.org/wiki/Gradient_descent">Gradient Descent Method</a>는 미분 가능한 convex function의 optimum point를 찾는 가장 popular한 방법 중 하나이다. 장점이라면 많은 application에 implement하기 매우 간단하고, 모든 차원과 공간으로 확장할 수 있으며, 수렴성이 항상 보장된다는 것이지만, 속도가 느리다는 단점이 존재한다.</p>


<p>아이디어는 매우 간단하다. 어떤 산 위에 우리가 서있다고 가정해보고 우리가 알 수 있는 정보는 내 위치와 내 주변 위치들의 높이 차이밖에 없다고 가정해보자. 만약 내가 산의 가장 낮은 위치로 내려가야하는 상황이라면 어떻게 내려가면 낮은 위치에 도달할 수 있을까? 가장 간단한 방법은 가장 기울기가 가파른 방향을 골라서 내려가는 것이다. 그러다보면 언젠가는 기울기가 0이 되는 지점에 도달하게 될 것이고, 그 지점이 주변에서는 가장 낮은 지점이 될 것이다. 만약 산의 높이가 convex function이라면, 즉 가장 낮은 지점이 unique하다면, 그렇게 도달한 지점이 우리가 원했던 가장 optimal한 지점이라는 것을 알 수 있다. 즉, 이 알고리듬은 매 step마다 현재 위치에서의 가장 가파른 아래로 내려가는 기울기 \(-\nabla f(x^{(k)})\)를 계산하고, 그 방향으로 이동하고, 다시 기울기를 계산하는 방식의 iterative algorithm이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-3.png" width="500"></p>

<p>Algorithm description은 다음과 같다.</p>


<p>$$ x^{(k+1)} = x^{(k)} - \eta^{(k)} \nabla f(x^{(k)}) $$</p>


<p>이 때 \(x^{(k)}\) 는 k번 째 iteration에서의 x의 값이며 \(\nabla f(x^{(k)})\) 는 그 지점에서의 gradient 값이다. 이를 조금 더 알고리듬스럽게 기술해보면</p>


<ol>
    <li>set iteration counter k=0, and make an initail guess \(x_0\) for the minimum</li>
    <li>Compute \(-\nabla f(x^{(k)})\)</li>
    <li>Choose \(\eta^{(k)}\) by using some algorithm</li>
    <li>Update \(x^{(k+1)} = x^{(k)} - \eta^{(k)} \nabla f(x^{(k)}))\) and k = k+1</li>
    <li>Go to 2 until \(\nabla f(x^{(k)})) < \epsilon \)</li>
</ol>


<p>만약 function이 convex하다면, 이런 방법으로 x를 계속 update하다보면 적절한 \(\eta\)를 취했을 때 이 algorithm은 global unique optimum으로 수렴하게 된다. 이때 \(\eta\)를 Step size라고 일컫는데, 이 step size를 어떻게 설정하느냐에 따라 알고리듬의 performance가 좌우된다. 만약 step size가 너무 작다면 iteration을 너무 많이 돌아서 전체 performance자체가 저하될 것이다. 그렇다고 step size가 너무 크다면 minima에 converge하는 것이 아니라 그 주변에서 diverge를 할 수도 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-4.png" width="500"></p>

<p>Step size를 고르는 방법은 크게 fixed step size를 취하는 방법과 매번 optimal한 step size를 고르는 방법 두 가지가 존재한다. 먼저 fixed step size에 대해 살펴보자.</p>


<p>앞서 언급했듯, step size를 잘 잡는 것이 중요한데, 너무 큰 step size를 잡게 되면 algorithm이 diverge 하기 때문이다. 다행히도 우리는 어떤 적절한 step size \(\eta\)에 대해 algorithm이 strictly convex function f의 global unique optimum으로 수렴한다는 증명을 할 수 있다.</p>


<p>이 적절한 step size에 대해 설명을 하려면 먼저 L-Lipschitz function이라는 것을 정의해야하는데, 이는 다음과 같이 정의된다.</p>


<p>$$ \|\nabla f(x) - \nabla f(y) \|_2 \leq L \|x-y\|_2, \forall x,y \in R^n $$</p>


<p>만약 f가 L-Lipschitz function이고 어떤 optimum이 존재한다면 fixed step size \(\eta \leq \frac{2}{L}\) 을 취했을 때 gradient descent algorithm이 stationary point로 수렴하게 된다는 것을 증명할 수 있다. 증명은 이 <a href="http://users.ece.utexas.edu/~cmcaram/EE381V_2012F/Lecture_4_Scribe_Notes.final.pdf">렉쳐노트</a>를 참고하기를 바란다.</p>


<p>다음으로 step size를 계속 update하는 방식(이를 Line search라고 한다)을 살펴보자.</p>


<p>먼저 exact line search라는 것 부터 살펴보자. Exact line search의 algorithm은 다음과 같다</p>


<ol>
    <li>set iteration counter k=0, and make an initail guess \(x_0\) for the minimum</li>
    <li>Compute \(-\nabla f(x^{(k)})\)</li>
    <li>Choose \(\eta^{(k)} = argmin_\eta f(x^{(k)} - \eta \nabla f(x^{(k)}))\)</li>
    <li>Update \(x^{(k+1)} = x^{(k)} - \eta^{(k)} \nabla f(x^{(k)}))\) and k = k+1</li>
    <li>Go to 2 until \(\nabla f(x^{(k)})) < \epsilon \)</li>
</ol>


<p>이 알고리듬은 가장 optimal한 \(\eta\)를 매 순간 찾아준다. 하지만 이 알고리듬은 3번 과정 때문에 practical하지는 못하고, 이 알고리듬을 조금 더 practical하게 보완한 backtracking line search algorithm이 조금 더 많이 쓰인다.</p>


<p>For \(\alpha \in {0, 0.5}, \beta \in {0,1}\)</p>


<ol>
    <li>set iteration counter k=0, and make an initail guess \(x_0\) and choose initial \(\eta=1\)</li>
    <li>Compute \(-\nabla f(x^{(k)})\)</li>
    <li>Update \(\eta^{(k)} = \beta \eta^{(k)}\)</li>
    <li>Go to 2 until \(f(x^{(k)} - \eta^{(k)} \nabla f(x^{(k)}))) \leq f(x^{(k)}) - \alpha \eta^{(k)} \| \nabla f(x^{(k)})) \|^2 \)</li>
    <li>Update \(x^{(k+1)} = x^{(k)} - \eta^{(k)} \nabla f(x^{(k)}))\) and k = k+1</li>
    <li>Go to 1 until \(\nabla f(x^{(k)})) < \epsilon \)</li>
</ol>


<p>보통 \(\alpha\)는 0.01에서 0.3 사이의 값으로 선택하고 \(\beta\)의 값은 0.1에서 0.8 정도로 설정된다.</p>


<p>이론적으로는 line search 쪽이 convergence speed가 훨씬 빠르지만, 실제로는 이를 구하는 것보다 적당한 step size로 값을 고정해놓고 gradient descent를 취하는 방법이 더 쉽고, line search를 위해 update되는 step size에 소모되는 computation이 꽤 크기 때문에 practical하게는 적당한 step size를 고정하는 방법이 훨씬 더 많이 사용된다.</p>


<p>Gradient Descent를 약간 응용하여 변형한 알고리듬으로는 Coordinate Descent method, Steepest descent method 등이 존재한다.</p>


<p>간단하게 개념만 설명하자면, <a href="http://en.wikipedia.org/wiki/Coordinate_descent">Coordinate descent</a>는 각 좌표계 방향에서 한 방향씩으로만 번갈아가면서 gradient descent를 하는 것이다. 예를 들어 n차원 function이 있는 경우, 첫번째 차원에 대해 gradient descent를 계산하고 두번째 세번째.. n번째 차원에 대해 이 과정을 반복한다. 그리고 이 과정을 전체 함수가 converge할 때 까지 반복한다. 이 방법이 좋은 이유는 함수가 비록 convex하지 않더라도, 어떤 특수한 경우에 대해 이 방법을 사용해 optimal point를 얻을 수 있기 때문이다.</p>


<p> <br/>
<img src="http://SanghyukChun.github.io/images/post/63-5.jpg" width="500"></p>

<p><a href="http://en.wikipedia.org/wiki/Method_of_steepest_descent">Steepest descent</a>는 간단히 생각하면 norm을 적절한 norm으로 바꿔 더 빠르게 converge를 시키는 방법이다. 이 방법은 saddle point가 존재하는 경우에 유용하게 사용할 수 있다고 한다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-6.gif" width="500"></p>

<h5>Newton&#8217;s Method</h5>


<p>Gradient descent는 기울기 정보 즉, 미분을 한 번만 한 값만을 사용하는데 만약 우리가 두 번 미분한 값을 사용할 수 있다면 훨씬 훨씬 빠른 수렴속도를 보이는 알고리듬을 디자인할 수 있을 것이다. <a href="http://en.wikipedia.org/wiki/Newton's_method">Newton&#8217;s method</a>는 Gradient Descent의 2nd derivative version으로 훨씬 수렴성이 빠르다는 장점을 가지고 있지만, Hessian Matrix를 계산해야하기 떄문에 computation과 memory측면에서 expensive하다는 단점을 가지고 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-7.gif" width="500"></p>

<p>2번 미분 가능한 strongly convex function f에 대해 Newton step은 다음과 같이 기술된다.</p>


<p>$$ \triangle x_{nt} (x) = -\nabla^2 f(x)^{-1} \nabla f(x) $$</p>


<p>이 newton step에 대해 newton&#8217;s method 알고리듬은 다음과 같이 쓸 수 있다.</p>


<ol>
    <li>initialize</li>
    <li>Compute the newton step \(\triangle x = -\nabla^2 f(x)^{-1} \nabla f(x)\)</li>
    <li>Choose step size \(\eta\)</li>
    <li>Update \(x^+ = x + \eta \triangle x_{nt} (x) \)</li>
    <li>Go to 2 until converge</li>
</ol>


<p>이 알고리듬을 깊게 파고들어가면 할 얘기가 정말 많아지므로 일단 convergence 조건이나, step size를 고르는 방법 등에 대해서는 생략하도록 하겠다. 하지만 이 알고리듬에 대해 크게 두 가지 얘기는 꼭 하고 넘어가야할 것 같은데, 하나는 convergence speed, 그리고 하나는 computation이다.</p>


<p>먼저 이 알고리듬은 매우 빠르게 수렴한다. 실제 convergence rate를 증명했을 때 gradient descent보다 빠르게 수렴할 뿐더러, 실제 practical하게도 (Hessian을 계산할 수 있다면) 아래와 같은 convergence phase를 보인다</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-8.png" width="500"></p>

<p>즉 처음에는 linear하게 converge하는 것처럼 보이지만, 시간이 지나면 순식간에 quadratic으로 수렴한다. 생각해보면, newton method는 기울기 뿐 아니라, 기울기의 기울기 정보도 같이 사용하기 때문에, 처음에 기울기가 크게 변하지 않을 때는 빠르게 감소하다가, 갑자기 기울기의 크기가 변하기 시작하면 그에 맞춰서 적절한 newton step을 찾을 수 있기 때문에 아주 빠르게 수렴할 수 있다. 특히 saddle point에 대해 영향을 크게 받지 않기 때문에 gradient descent 보다는 훨씬 훨씬 빠르게 수렴한다.</p>


<p>하지만 Newton method의 근본적인 한계는 바로 Hessian을 계산해야한다는 점이다. 이 Hessian을 계산하는 것 자체도 매우 연산이 복잡할 뿐 아니라, gradient의 제곱 만큼의 공간이 필요하기 때문에 memory 역시 efficient하게 사용하기가 어렵다. 때문에 매우 복잡한 함수에 대해서는 newton method를 사용하기가 매우 힘들다. 예를 들어서 neural network에서 gradient descent method를 사용하면 chain rule을 통해 아주 쉽게 그 값을 계산할 수 있지만, second derivation으로 넘어가는 순간, computation을 해야할 양이 급격하게 증가하고, 안그래도 부족한 메모리가 더 부족하게 되기 때문에 neural network에서는 사용되지 않는 방법이다.</p>


<p>대략 요약하자면, 별 일이 없다면 gradient descent에서 fixed step size를 사용해 converge를 시키는 것이 practical하게는 가장 많이 쓰이고 있다. 하지만, 더 빠른 convergence speed가 필요하다면 line search나 steepest method, newton&#8217;s method를 한 번쯤은 고려해볼만 할 것이다.</p>


<h5>Lagrange Multiplier</h5>


<p>마지막으로 <a href="http://en.wikipedia.org/wiki/Lagrange_multiplier">Lagrange multiplier</a>에 대해 살펴보자. Lagrange Multiplier는 constrained optimization을 푸는 매우 popular한 방법 중 하나이다. 원리는 원래 constrained optimization과 같은 optimum point를 가지는 새로운 unconstrained optimization 문제를 만들어서 optimum point를 구하는 것이다. 즉, 다음과 같은 optimization 을 생각해보자</p>


<p>$$ \min f(x) \text{ s.t. } g(x) = c $$</p>


<p>그렇다면 이와 같은 극점을 가지는 다음과 새로운 optimization problem을 만드는 상수 \(\lambda\)가 존재한다.</p>


<p>$$ \min f(x) + \lambda (g(x) - c) $$</p>


<p>보통 c는 상수이기 때문에 극값에 영향을 주지 않으므로 많이 무시된다.</p>


<p>이 문제를 푸는 방법은 여러 개가 있지만, 어렵지 않은 문제인 경우 Lagrange function을 편미분해 0이 되는 값들을 모두 구해 \(\lambda\)를 계산해 대입해서 극값을 찾는 방법을 많이 취한다.</p>


<p>하지만 편미분을 구하기 어려운 경우도 존재하기 때문에 항상 그렇게 푸는 것은 아니고, 이런 문제를 잘 풀 수 있는 여러 알고리듬들이 존재하며, 최근 많이 쓰이는 알고리듬으로는 <a href="http://en.wikipedia.org/wiki/Augmented_Lagrangian_method">ALM</a> (Augumented Lagrange method)가 있다.</p>


<p>Lagrange Multiplier는 풀기 어려운 constrained optimization problem을 그보다 더 풀기 쉬운 unconstrained optimization problem으로 바꿔주기 때문에, 새로운 Lagrange function을 풀기 쉬운 경우에 많이 사용한다.</p>


<h5>Optimization for non-convex function (Local optimum)</h5>


<p>하지만 위에서 서술한 방법들은 오직 convex한 function에만 적용할 수 있는 방법들이므로 우리는 non convex한 함수들은 optimize할 수 없다.. 라고 말해야하지만, 사실 꼭 그렇지만은 않다. Convex function은 global optimum, 즉 해당 식을 만족하는 x를 반드시 찾을 수 있지만, 같은 방법을 적용했을 때 non-convex한 함수는 그럴 수 없다. 하지만 non-convex한 함수이더라도 local optimum 값을 찾을 수는 있다. 때문에 많은 경우에 optimization problem이 convex하지 않다고 하더라도 converge를 하는 것 만으로도 그 문제를 풀었다라고 얘기하는데, 이때, local하게 함수를 봤을 때 convex하다면 gradient descent 등의 방법을 사용해서 local optimum을 계산할 수 있다. 예를 들어서 Neural network에 많이 쓰이는 backpropagation algorithm은 사실 gradient descent method algorithm인데, 따라서 이 알고리듬의 결과는 항상 local optimum으로 converge한다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/63-9.jpg" width="500"></p>

<p>따라서 convex하지 않은 optimization일지라하더라도, 일단은 gradient descent 등의 방법을 통해 optimization을 할 수 있다면, local optimum을 구할 수 있다.</p>


<p>하지만 그럼에도 local한 optimum이 엄청나게 많은 경우에는 local optimum으로 converge하는 것이 문제가 되기 때문에 함수를 convex하게 relaxation 시켜서 optimization을 푸는 경우도 존재한다. 특히 원래 문제가 NP-hard인 경우, parameter를 골라야하는 경우 등에 convex relaxation을 많이하는 것 같다.</p>




<h5>변경 이력</h5>


<ul>
<li>2014년 9월 10일: 글 등록</li>
<li>2015년 2월 28일: 변경 이력 추가</li>
</ul>


<h5>Reference</h5>


<ul>
<li><a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Convex optimization</a> by Boyd</li>
<li><a href="http://stanford.edu/~boyd/cvxbook/bv_cvxslides.pdf">Lecture slides</a> by Boyd and Vandenberghe</li>
<li><a href="http://users.ece.utexas.edu/~cmcaram/EE381V.html">EE381V &ndash; Large Scale Optimization</a> The University of Texas at Austin</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (6) Information Theory]]></title>
    <link href="http://SanghyukChun.github.io/62/"/>
    <updated>2014-08-20T00:20:00+09:00</updated>
    <id>http://SanghyukChun.github.io/62</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Information Theory는 섀년이라는 걸출한 천재가 이룩해낸 매우 뛰어난 이론이다. 이 이론 덕분에 우리는 이렇게 인터넷도 할 수 있고, 무선통신도 할 수 있는 것이다. 이 이론 덕분에 불안정한 noisy한 channel에서도 유한한 시간 안에 우리가 전달하고 싶은 정보를 전부 전달할 수 있다는 것을 확신할 수 있고, 이론적인 한계값까지 도출이 가능한 엄청난 이론이다. Machine Learning에서도 이런 information theory 측면에서 문제를 바라보는 경우가 종종 있는데, Entropy, Mutual Information, KL-divergence 등이 그것이다. 이 글에서는 그런 Machine Learning의 관점에서 많이 쓰이는 기초적인 정보이론의 개념들을 짚고 넘어가볼까 한다.</p>


<h5>Entropy</h5>


<p>엔트로피는 &#8216;정보&#8217;의 단위라고 할 수 있다. 어떤 distibution p(x)에서 generate되는 discrete random variable x가 있다고 해보자. 이 random variable x가 전달할 수 있는 정보량은 어떻게 계산할 수 있을까. 여기에서 &#8216;정보&#8217;란 얼만큼의 bit가 있어야 x에 대한 정보를 완벽하게 얻을 수 있는가로 정의해보자. 예를 들어서 fair한 동전 던지기의 정보량은 1이다. 한 비트만 있으면 반드시 그 동전 던지기의 distribution을 서술할 수 있다. 그러나 만약 fair coin이 아니라면 한 면이 나올 확률이 다른 면이 나올 확률보다 상대적으로 더 크기 때문에 한 비트보다도 더 적은 정보를 사용해 값을 맞추는 것이 가능해진다. 이런 정보의 양을 <a href="http://en.wikipedia.org/wiki/Entropy_(information_theory)">Entropy</a>라는 것으로 정의하게 되는데, 간단하게 생각하면 열역학2법칙의 그 엔트로피와 동일하다. 즉, 엔트로피가 커질수록 불확실성이 높아지고 정보량은 더 많아진다. Entropy는 \(H(x) = - \sum_x p(x) log_2 p(x) \)로 정의가 되며, 만약 p(x)가 0으로 가면 \(\log_2 p(x)\)는 음의 무한으로 발산하지만, p(x)가 0이 되는 속도가 더 빠르기 때문에 엔트로피는 0이 된다.</p>


<p>그럼 왜 엔트로피는 이런 꼴을 하게 되는 것일까. 만약 우리가 전체 N개의 object들이 있고, 이 object들이 K개의 bin으로 나뉘어져있다고 해보자. 그리고 i번째 bin에 들어갈 수 있는 object의 개수를 \(n_i\)라고 했을 때, object들이 bin에 들어갈 수 있는 permutation의 개수는 \(W = \frac{N!}{\prod_i n_i!}\)와 같으며 이를 multiplicity라고 한다. 엔트로피란 이 multiplicity에 비례하는, 정확히는 log를 취한 값을 엔트로피라고 하게 된다. 즉 Entropy H는 multiplicity W에 대해 다음과 같이 표현된다.</p>


<p>\[H = \frac{1}{N}\ln W = \frac{1}{N}\ln N! - \frac{1}{N}\sum_i \ln n_i ! \]</p>


<p>이때 \(\lim N \to \infty \) 라고 해보자, 그러면 우리는 <a href="http://en.wikipedia.org/wiki/Stirling's_approximation">Stirling 근사</a>를 할 수 있는데 이는 \(\ln N! \simeq N \ln N - N\)으로 주어진다. 이를 대입해서 잘 정리해보면 아래와 같은 식을 얻을 수 있다.</p>


<p>\[H = -\lim_{N \to \infty} \sum_i \left( \frac{n_i}{N} \right) \ln \left( \frac{n_i}{N} \right) = - \sum_i p_i \ln p_i \]</p>


<p>이는 위에서 정의한 엔트로피의 값과 일치한다.</p>


<p>그런데 이 값은 discrete한 random variable에 대해 정의된 값이고 continous한 random variable x에 대해서는 <a href="http://en.wikipedia.org/wiki/Differential_entropy">differencial entropy</a>라는 정의할 수 있다. <a href="http://en.wikipedia.org/wiki/Mean_value_theorem">평균값 정리</a>에 의해서 우리는 다음을 만족하는 value \(x_i\)를 반드시 찾을 수 있다</p>


<p>\[ \int_{i\Delta}^{(i+1)\Delta} p(x) dx = p(x_i) \Delta\]</p>


<p>엔트로피는 discrete한 random variable에 대한 값이었는데, 위 식을 통해 continous variable x를 위의 식을 만족하는 \(x_i\)로 치환하는 방식으로 quantize할 수 있다. 또한 이런 경우 각 \(x_i\)를 관측할 확률이 \(p(x_i)\Delta\)로 계산되므로, 이렇게 했을 경우 엔트로피는 아래와 같이 계산할 수 있다.</p>


<p>\[H_\Delta = -\sum_i p(x_i) \Delta \ln ( p(x_i) \Delta ) = - \sum_i p(x_i) \Delta p(x_i) - \ln \Delta \]</p>


<p>이때, 오른쪽 term은 x에 대한 값이 아니니까 일단 먼저 무시하고, \(\lim \Delta \to 0\)를 취해보자. 이렇게 계산할 경우 아래 식이 얻어진다.</p>


<p>\[\lim_{\Delta \to 0} H_\Delta = \lim_{\Delta \to 0} -\sum_i p(x_i) \Delta \ln ( p(x_i) \Delta ) = -\int p(x) \ln p(x) dx\]</p>


<p>이때, 맨 오른쪽 term을 differencial entropy라고 정의한다. 즉, differencial entropy는 다음과 같이 정의된다.</p>


<p>\[H(x) = -\int p(x) \ln p(x) dx\]</p>


<p>마지막으로 random variable이 x,y 두 개가 있고 이 둘의 joint distribution p(x,y)가 있다고 해보자. 우리가 알고 있는 정보는 x의 value라고 했을 때 우리는 y의 information의 양을 계산할 수 있을까? 이를 <a href="http://en.wikipedia.org/wiki/Conditional_entropy">Conditional Entropy</a>라고 하는데 이때 y에 대해 필요한 additioanl information은 \(p(y|x)\)이며, x와 y의 확률은 p(x,y)이므로 Conditional Entropy는 아래와 같이 정의된다.</p>


<p>\[H(y|x) = - \int \int p(y,x) \ln p(y|x) dy dx\]</p>


<p>이 값은 다음과 같은 chain rule을 항상 만족시킨다.</p>


<p>\[H(x,y) = H(y|x) + H(x)\]</p>


<h5>KL divergence</h5>


<p>어떤 probability distribution p(x)와 p(y)가 있다고 했을 때 이 둘의 차이, 혹은 distance를 정의할 수는 없을까. 예를 들어 p(x)라는 우리가 모르는 unknown distribution이 있을 때, 우리가 추측한 \(p(\hat x)\)와 true distribution p(x)가 얼마나 차이나는지를 계산할 수 있는 방법은 없을까. 만약 우리가 q(x)를 사용해서 x를 transmitting하는 coding scheme을 construct했다고 해보자. 그리고 true distribution을 p(x)였다고 했을 때, q(x)를 사용하였을 때 얼마나 더 많은 정보량이 필요할 것인지 measure할 수 있을 것이다. 이를 <a href="http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Kullback-Leibler divergence</a> 혹은 KL divergence라고 하며 수식은 아래와 같다.</p>


<p>\[KL(p\|\|q) = - \int p(x) \ln q(x) - \left( -\int p(x) \ln p(x) dx \right) &#92;&#92; = -p(x) \ln \left[ \frac{q(x)}{p(x)} \right] dx \]</p>


<p>정확히 얘기하면 이 값은 &#8216;distance&#8217;가 될 수는 없다. 왜냐하면 distance, 혹은 metric은 symmetric해야하는데 KL divergence는 \(KL(p\|\|q) \neq KL(q\|\|p)\) 이기 때문이다.</p>


<p>KL divergence는 언제나 0 보다 크거나 같은데, 같은 경우는 오직 p(x)와 q(x)가 일치하는 경우 뿐이다. 이를 증명하기 위해서는 convexity 컨셉과 Jensen&#8217;s inequality를 도입하면 쉽게 증명이 가능하지만, 여기에서는 생갹하도록 하겠다.</p>


<p>중요한 점은, KL divergence는 두 distribution의 차이를 define할 수 있는 좋은 수단 중 하나라는 것이며, 다시 말해 원래 true distribution p(x)와 우리가 estimate한 q(x)가 얼마나 비슷한지를 measure할 수 있는 수단이라는 점이다.</p>


<h5>Mutual Information</h5>


<p><a href="http://en.wikipedia.org/wiki/Mutual_information">Mutual Information</a>은 두 random variable들이 얼마나 mutual dependence한지를 measure하는 방법을 의미한다. 만약 random variable x와 y가 independent하다면 joint distribution p(x,y) 는 p(x,y) = p(x)p(y) 로 주어지게 될 것이며, 만약 둘이 dependent한 경우에는 두 값이 달라질 것이다. 그렇다면 만약 true distribution을 p(x,y)라고 했을 때, 새롭게 우리가 x와 y가 independent하다고 estimate하고 구한 p(x)p(y)와의 KL-divergence를 구할 수 있지 않을까? 당연히 이 값은 x와 y가 independent할 때만 0이고 그 이외에는 항상 0보다 크다. 즉, 두 random variable이 얼마나 mutually dependent한가, 얼마나 Mutual하게 information을 많이 가지고 있느냐를 측정할 수 있는 도구가 되므로 이를 Mutual information이라 한다. 수식으로 표현해보면 아래와 같다.</p>


<p>\[I(x,y) = KL(p(x,y)\|\|p(x)p(y) &#92;&#92; = - \int \int p(x,y) \ln \left( \frac{p(x)p(y)}{p(x,y)} \right) dx dy\]</p>


<p>위의 값을 Mutual Information이라 하며, 이 값은 항상 다음과 같은 관계를 만족시킨다.</p>


<p>\[I(x,y) = H(x) - H(x|y) = H(y) - H(y|x)\]</p>


<h5>Machine Learning and Information Theory</h5>


<p>Entropy는 주어진 bin에 얼마나 비슷한 element들이 들어있는지를 측정하는 척도로 쓰일 수 있으며, decision tree를 learning하는 알고리듬 등에서도 사용할 수 있다. 또한 KL-divergence는 두 distribution과의 거리를 의미하므로, density estimation 관점에서 바라봤을 때 우리가 estimate하는 distribution과 원래 true distribution이 얼마나 유사한지, 우리가 얼마나 잘 density estimation을 했는지 evaluation을 하는 용도 등으로 쓰일 수 있다. 마지막으로 Mutual information을 Bayes perspective에서 바라보게 된다면, 만약 우리가 어떤 데이터 x의 prior p(x)를 관측하고, 새로운 데이터 y를 관측해 얻은 posterior distribution p(y|x)가 있다고 했을 때, Mutual information은 이전 관측 x를 통해 새로운 관측 y의 uncertainty가 얼마나 reduction 되는지를 의미하게 되는 것과 동일하다는 것을 알 수 있다.</p>


<p>정보이론 자체는 Machine Learning과 크게 관계가 없어보이지만, 그 개념들은 생각보다 꽤 많은 부분에서 사용되게 되므로 좀 간략하게 다루게 되었다.</p>


<p>추가: 정보이론이 어떻게 머신러닝에 유용하게 쓰일 수 있는가에 대한 lecture와 book link들 <a href="http://www.inference.phy.cam.ac.uk/itprnn_lectures/">[1]</a>, <a href="http://www.inference.phy.cam.ac.uk/mackay/itila/book.html">[2]</a></p>




<h5>변경 이력</h5>


<ul>
<li>2014년 8월 19일: 글 등록</li>
<li>2014년 10월 9일: 정보이론, 머신러닝 렉쳐 및 책 링크 등록</li>
<li>2015년 2월 28일: 변경 이력 추가</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (5) Decision Theory]]></title>
    <link href="http://SanghyukChun.github.io/61/"/>
    <updated>2014-08-19T18:13:00+09:00</updated>
    <id>http://SanghyukChun.github.io/61</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>그 어떤 좋은 알고리즘을 선택하더라도, 최종적으로 특정 문제에 대해 inference를 하기 위해서는 decision making을 해야만 한다. 그렇다면 decision은 어떻게 내릴 수 있을까? 라는 질문이 자연스럽게 들 수 있는데, decision theory는 어떻게 decision을 내릴지에 대해 다룬다. 내가 지금 결정한 parameter는 적당한 parameter인가? 예를 들어서 내가 임의의 데이터를 가장 잘 설명할 수 있는 1차함수를 그려야하는 상황이라고 했을 때, 나는 그 &#8216;가장 잘 설명할 수 있는&#8217; parameter를 어떻게 decide할 수 있을까, 어떻게 decision making을 할 수 있을까. 혹은 Classification problem에서 해당 data가 어떤 class에 속하는지 어떤 방식으로 decision을 내려야할까?</p>


<h5>Decision rule with prior only</h5>


<p>다시 <a href="58#58-1-Bayes">Bayes Rule</a>로 돌아가보자.</p>


<p>\[ p(C|X) = {p(X|C) p(C) \over p(X)} \]</p>


<p>이전 글에서 prior라는 것에 대해 언급했었다. 예를 들어 우리가 어떤 classification을 하는 상황이라 해보자. 만약 주어진 데이터가 class A인지 B인지 구분해야하는 상황이라고 가정을 해보자. 우리가 아는건 prior P(C) 밖에 모르는 상황이라고 해보자. 그렇다면 우리가 내릴 수 있는 가장 합리적인 판단은 무엇일까? 이 상황에서의 가정은 우리가 아는 정보는 오직 prior밖에 없으며, incorrect classification에 대한 cost는 모두 동일하다고 가정한다. 그렇다면 당연히 reasonable한 decision rule은 가장 높은 확률을 가지는 class를 선택하는 것일 것이다. 이유는 가장 확률이 높은 클래스를 C1이라 하면, 언제나 \(P(C1) > P(C2)\) 라는 사실을 알 수 있기 때문이다. 즉, 언제나 C1을 고르는 것이 가장 best하다. 그렇다면 여기에서 문제가 발생하는데, 만약 우리가 모든 decision을 동일하게 내리게 된다면 당연히 좋은 결과가 나올리가 없다는 점이다. 예를 들어 C1이 60%, C2가 40% 존재하는 상황이면, 언제나 error는 0.4가 될 것이며, 언제나 classification result는 C1이 될 것이기 때문이다. 그러나 일단 우리가 prior만 가지고 있다고 가정하고 있기 때문에 이런 상황에서는 언제나 이것이 best가 될 것이다. 그렇다면 이 이외의 다른 정보를 가지고 있다면 어떨까?</p>


<h5>Decision rule with Likelihood</h5>


<p>Observation, 혹은 Likelihood에 대한 정보를 가지고 있다면 분명 상황은 더 나아질 수 있다. 확률로 표시하자면 이 값은 \(P(X|C)\), 즉 주어진 클래스에 대해 관측되는 데이터가 된다. 그리고 당연하게도, 우리가 이 값을 가지고 있다면, Bayes rule에서부터 P(C|X), 혹은 posterior를 계산할 수 있게 된다. 즉, prior와 likelihood를 알고 있으므로, \(C = argmax P(C|X) = argmax {P(X|C) P(C) \over \sum_i P(X|C_i) P(C_i) } \) 를 통해 decision을 내릴 수 있게 된다. 그렇다면 이렇게 선택하는 경우 error는 어떻게 나타나게 될까? 여기에서 error는 classification이 틀린 경우를 의미한다 (number of misclassification). 일단 class가 2개 밖에 없다고 해보자. 그럼 error가 발생하는 경우는 단 두가지인데,</p>


<p>\[P(error|x) = \begin{cases} P(C1|X) \text{ if we decide C2} &#92;&#92; P(C2|X) \text{ if we decide C1} \end{cases} \]</p>


<p>이렇게 두 가지가 될 것이다. 즉, 우리가 P(C|X)를 maximize하는 C를 선택하는 decision rule을 가지고 있다면, P(error)는 간단하게 다음과 같이 계산된다</p>


<p>\[P(error) = \int P(error|X) P(X) dX \]</p>


<p>가 될 것이며, 이 결과를 최소화하는 decision making rule이 우리가 원하는 decision rule이 될 것이다. (당연히 우리는 결과의 error가 최소화되는 것을 원할테니까.) 결론만 놓고 얘기하자면 prior와 likelihood를 모두 알고 있다면 위와 같이 posterior를 maximize하는 것이 가장 이 값을 \(P(error|X) = min[P(C_1|X), &#8230;, P(C_k|X)]\) 로 최소화 시킬 수 있다. (이유는 조금 생각해보면 간단하게 알 수 있다.) 즉, 모든 class의 posterior를 계산하여 주어진 데이터에 대해 얻어질 확률이 가장 큰 class를 선택하는 것과 정확히 같다는 의미이다. (참고로 만약 prior에 대한 정보가 없어서 uniform한 prior를 가정하게 된다면 결국 likelihood만을 놓고 계산한 값과 정확히 일치하게 된다.)</p>


<h5>Loss function</h5>


<p>앞서 설명한 예제는 &#8220;misclassification number&#8221;를 minimize하는 예제였다. 그러나 실제 많은 application들에서 이런 방식 이외의 다른 approach를 요구하게 된다. 예를 들어서 값이 틀렸을 때 0과 1로 error를 정의하는 것이 아니라, 원래 target data와 우리가 계산한 estimated data의 차이의 제곱의 합들로 표현을 할 수도 있고, 제곱이 아니라 절대값의 합으로 표현할 수도 있다. 즉, 보다 더 generalized된 접근법이 필요한데, 가장 formal하게 많이 쓰이는 decision criteria 중 하나로 <a href="http://en.wikipedia.org/wiki/Loss_function">loss function</a> 혹은 cost function이 있다. Cost function은 여러가지로 정의할 수 있겠지만, 나는 Cost function을 이렇게 정의한다. 우리가 목표로 하는 가장 좋은 결과와 지금 내가 선택한 결과와의 차이. 즉, 내 결과가 optimal한 결과보다 좋지 않으면 않을수록 cost function은 커지고, 당연히 optimal한 결과를 가지게 됐을 때 Cost function의 값이 가장 작아질 것이다. 다만, 그 차이는 여러가지 방법으로 정의할 수 있는데, 앞서 misclassification number와 같은 binary한 차이가 될 수도 있고, 또 앞서 내가 예로 들었던 원래 값과 예상 값의 차이의 제곱의 합.. 등 굉장히 다양하게 cost function을 정의하는 것이 가능하다. 그리고 이런 함수는 true value가 변하지 않고, parameter에 따라 estimated value가 변하게 되므로, loss function은 parameter에 대한 함수로 나타나게 된다. 이때, Loss function은 \(L(\theta, \hat \theta(X))\)로 표기되며, 우리가 찾고자하는 true parameter를 \(\theta\), 주어진 data X에 대해 estimate한 parameter를 \(\hat \theta(X)\)라 하자. 우리의 목표는 가장 적절한 parameter \(\hat \theta(X)\)를 찾는 것이다.</p>


<h5>Minimize Bayes Risk</h5>


<p>자 다시 Decision rule로 돌아가보자. 우리가 minimize하고 싶은 것은 Loss function을 minimize하는 것이지만, 그 값 자체가 true value에 dependent하기 때문에 정확한 값을 구하는 것이 불가능하다. 따라서 주어진 데이터 X에 대해 expectation을 계산하여 이를 해결하게 된다. 주어진 데이터들에 대한 loss function의 expectation은 \(R = \int \int L (\theta, \hat \theta(x)) p(\theta, x) dx d \theta \) 로 표현이 되는데, 이 값은 사실 posterior의 risk, 혹은 conditional risk라고 알려진 \(R = \int L (\theta, \hat \theta(x)) p(\theta | x) d \theta \) 값을 minimize하는 것과 일치한다. Expected Loss, 혹은 Bayes risk를 전개해보면</p>


<p>\[R = \int \int L (\theta, \hat \theta(x)) p(\theta, x) dx d \theta &#92;&#92; = \int \int L (\theta, \hat \theta(x)) p(\theta | x) p(x) dx d \theta &#92;&#92; =  \int \left( \int L (\theta, \hat \theta(x)) p(\theta | x) d \theta \right) p(x)dx  \]</p>


<p>이때, \(\theta\)에 대한 적분 구간이 정확하게 conditional risk와 같으며, x에 대해 summation하는 것은 parameter에 영향을 주지 않으므로 둘이 동일함을 알 수 있다. 이렇게 구해진 expectation loss, Bayes risk (혹은 이와 같은 posterior risk, conditional risk) 를 minimization시키는 방법으로 \(\hat \theta\)를 estimate하는 estimator를 Bayes estimator라고 한다.</p>


<p>그러면 다양한 loss function들에 대해 이 Bayes risk와 Bayes estimator로 얻어지는 parameter를 계산해보자.</p>


<p>간단한 예로 zero-one loss의 expected loss를 구해보자. Zero-one loss는 아래와 같이 주어진다. 이 경우는 class를 구하는 것이므로 \(\theta\)가 아니라 \(C_k\)로 작성하였다.</p>


<p>\[L(C_k, \hat C_k(x)) = \begin{cases} 1 \text{ if } C_k = \hat C_k(x) &#92;&#92; 0 \text{ otherwise } \end{cases} \]</p>


<p>따라서 expectation loss 혹은 그와 동일한 conditional risk \(R = \sum_j L (C_j, \hat C_j(x) p(C_j | x) \) 는 (이 경우는 discrete하므로 integral이 아니라 summation이다.)</p>


<p>\[R = \sum_j L (C_j, \hat C_j(x) p(C_j | x) = \sum_{j \neq i} P(C_j | X) = 1-P(C_i|X) \]</p>


<p>와 같이 얻어지게 된다. 따라서 zero-one loss를 decision rule로 삼게 되면 아래와 같은 결과를 얻게 된다.</p>


<p>\[C_i = argmin R = argmin_{C_k} 1 - P(C_k|X) = argmax_{C_k} P(C_k|X) \]</p>


<p>즉, 0-1 loss를 사용하게 되면 Bayes estimator가 MAP (maximum a posterior)와 같아진다는 사실을 알 수 있다.</p>


<p>이번에는 다른 Loss function을 사용해서 bayes risk를 계산해보자. 만약 우리가 \(L (\theta, \hat \theta(x)) = (\theta - \hat \theta)^2 \) 이라 한다면 어떻게 될까. 먼저 conditional risk는 아래와 같다.</p>


<p>\[R = \int (\theta - \hat \theta)^2 p(\theta | x) d \theta p(x) \]</p>


<p>위의 식을 \(\hat \theta\)에 대해 미분해보면,</p>


<p>\[ \frac{\partial}{\partial \hat \theta} \left[ \int (\theta - \hat \theta)^2 ) p(\theta | x) d\theta \right] &#92;&#92; = \int \frac{\partial}{\partial \hat \theta} \left[ (\theta - \hat \theta)^2 ) p(\theta | x) d\theta \right] &#92;&#92; = -2 \int (\theta - \hat \theta) ) p(\theta | x) d\theta\]</p>


<p>이 derivation을 0으로 만드는 \(\hat \theta\)는 간단하게 \(\hat \theta = \int \theta p(\theta | x) d \theta = E[\theta|x]\)라는 결과를 얻게 된다. 즉, Bayes risk를 가장 minimize하는 \(\hat \theta\)는 주어진 데이터에 대한 parameter의 expectation인 \(E[\theta|x]\)라는 사실을 알 수 있다. 그리고 이를 다시 conditional risk에 대입을 해보면</p>


<p>\[R = \int (\theta - E[\theta|x]^2 p(\theta|x) d\theta = \sigma^2_{\theta|x}\]</p>


<p>즉, risk가 random variable의 variance와 정확히 같다는 것을 알 수 있다. 또한 따라서 Bayes risk가 절대로 0으로 수렴하지 않음도 알 수 있는데, 우리가 구한 결과에 따르면 이 값은 항상 \(\theta|x\)라는 random variable의 variance와 같기 때문에 이 값이 0이라는 얘기는 더 이상 \(\theta|x\)가 random variable이 아니라 deterministic하다는 의미가 되기 때문이다. 따라서 이 값은 항상 0이 아님을 알 수 있다.</p>


<h5>Inference and decision</h5>


<p>다시 Classification problem으로 돌아가보자. 이 classification은 크게 두 가지 step으로 나눌 수 가 있는데 하나가 inference stage이고, 또 하나가 decision stage이다. Inference stage에서는 training data를 사용하여 \(p(C_k|x)\)를 계산하기 위한 model을 learning한다. 그리고 그에 따르는 다음 step인 decision stage에서는 앞서 inference stage에서 계산한 posterior probability를 사용하여 실제 class assignment decision을 내리게 된다. 이런 과정 없이 단순하게 input x에 directly decision을 mapping하는 function을 생각할 수도 있는데, 이런 function은 discriminant function이라 한다.</p>


<p>이런 inference와 decision stage로 classification을 구분하는 approach를 취하게 되면 크게 두 가지 방법으로 decision problem을 접근하는 것이 가능해진다. <a href="http://en.wikipedia.org/wiki/Generative_model">Generative model</a>과 <a href="http://en.wikipedia.org/wiki/Discriminative_model">Discriminative model</a>이 바로 그것이다.</p>


<p>Generative model은 input에서부터 distribution을 직접적으로 혹은 간접적으로 얻어내고 output 역시 마찬가지 방법으로 얻어내게 된다. 조금 더 구체적으로 들어가보자. Generative model은 가장 먼저 inference problem, 정확히는 각각의 class 별로 가지게 되는 class conditional density \(p(x|C_k)\)를 결정하는 inference prblem을 풀게 된다. 또한 class prior probability \(p(C_k)\)도 infer를 하게 된다. 이 두 가지 정보를 사용하여 Bayes rule을 적용하여 posterior probability \(p(C_k|x)\)를 계산하게 된다.</p>


<p>\[ p(C_k|x) = {p(x|C_k) p(C_k) \over p(x)} \]</p>


<p>이때, \(p(x)\)는 단순히 normalize를 해주는 것으로 무시할 수 있다. (자세한건 <a href="58#58-1-Bayes">이전 글</a>에서 설명했으므로 생략.) 따라서 우리가 assume해야하는 값은 \(p(x|C_k)\), 그리고 \(p(C_k)\)인데, 결국 이 둘을 assume하는 것은 \(p(C_k, x)\)를 assume하는 것, 혹은 modeling하는 것과 같다. 즉, generative model은 joint probability를 modeling 하여 sample들을 해당 distribution으로 &#8216;generate&#8217; 한 결과를 사용하여 decision을 내리는 것이다.</p>


<p>이런 Generative model의 예로는 Gaussian Mixture Model (GMM), Hidden Markov Model (HMM), Naïve Bayes, Restricted Boltzmann Machine (RBM) 등이 존재한다.</p>


<p>이에 반해 Discriminative model 은 inference problem에서 posterior class probability \(p(C_k|x)\)를 직접 계산한다. 그리고 decision stage에서 이 posterior probability를 직접 사용하여 decision을 내리게 된다. 즉, 새로 들어온 input x에 대해 모든 class들의 posterior를 계산하여 가장 probability가 높은 class를 assign하는 방식으로 classification을 하게 된다. 위애서 길게 설명했던 Generative model과의 가장 큰 차이는 Generative model은 joint distribution \(p(x, C_k)\)를 계산하여 inference와 decision을 하는데에 반해 Discriminative model은 그것을 직접 계산하여 inference를 한다는 점이 다르다.</p>


<p>Discriminative model의 예는 Logistic regression, Linear discriminant analysis (LDA), Support Vector Machines (SVM), Boosting, Conditional Random Fields (CRF), Linear Regression, Neural Networks 등이 존재한다.</p>


<p>Generative model 과 Discriminative model의 차이점은 아래 그림에서 간단하게 정리되어있다. (<a href="http://sens.tistory.com/408">출처</a>)</p>


<p><img src="http://SanghyukChun.github.io/images/post/61-1.jpg" width="600"></p>

<p>즉 데이터 x와 그 데이터들의 class y가 주어졌을 때, Classification을 위해서 필요한 값은 결국 \(p(y|x)\)로 같지만, generative model은 먼저 \(p(x|y), p(y)\)를 modeling하고 이 값들을 learning한 이후에 \(p(y|x) \propto p(x|y) p(y)\)를 통해 데이터 x의 class y의 확률을 계산하게 된다. 반면 discriminative model은 model 자체가 \(p(y|x)\)를 바로 learning하기 때문에 이 값을 바로 사용하면 된다. 따라서 discriminative model은 어떤 식으로 class가 분포해 있는지 사전 정보를 알 필요가 전혀 없지만, generative model을 사용하기 위해서는 이 값을 내가 미리 assume해야만 한다. 간단하게 생각하면 SVM은 대표적인 discriminative model 중 하나인데, SVM의 그 어떤 과정도 주어진 class들이 특정 형태로 분포해야한다는 가정이 전혀 들어있지 않다. 반면 generative model 중 하나인 GMM은 모든 cluster들이, 혹은 class들이 Gaussian의 mixture 형태로 주어진다고 가정하게 된다. 즉, 이 경우는 데이터와 class의 joint probability를 계산하게 되는 것이다.</p>


<p>정리해보면 Generative model은 joint distribution에서부터 sample을 &#8216;generative&#8217;하는 반면, Discriminative model은 주어진 데이터 x에 대해서만 model을 구하게 된다. 따라서 일반적으로 generative model이 훨씬 더 flexible한 결과를 보인다. 그러나 joint distribution을 직접 계산하는 것은 매우 computation cost가 높은, 즉 complexity가 높은 작업인 경우가 대다수인 반면, posterior probability를 계산하는 것은 상대적으로 더 저렴한 경우가 많다. 그 뿐 아니라, joint distribution을 modeling  하는 것도 대부분 쉽지 않다. 주어진 데이터들이 어떤 joint distribution으로 분포했는지는 modeling을 하지 않고서는 알 수 없기 때문이다. 반면 \(p(y|x)\)는 우리가 관측하는 likelihood 등을 사용하여 바로 계산하는 것이 가능하기 때문에 대부분의 discriminant model은 아무래도 조금 더 데이터가 sparse하게 존재하는 경우라거나, 전체 우리가 그 joint distribution에 대해 감조차 잡을 수 없는 경우에 해야하는 classification에 적합한 결과를 내놓는 경우가 많다고 한다.</p>


<h5>Decision process</h5>


<p>정리하자면, 최종적으로 decision을 내리기 위해서는 (1) Find parameter by minimizing risk (2) Decision by Model 이라는 과정을 거치게 된다. 먼저 minimize risk는 위에서 서술한 bayes risk를 minimization하는 부분으로, 이 부분에서 우리는 parameter들을 learning하게 된다. 이때 Loss function을 어떻게 정의하냐에 따라 parameter의 값이 결정되게 되며, 나중에 다루겠지만, 단순히 loss function을 정의하는 것으로 끝나는 것이 아니라, 이 optimization 문제를 polynomial algorithm을 통해 계산해내어야한다. 실제로 많은 algorithm들이 global optimum으로 수렴하지 않고 local optimum만을 찾아주는 경우가 많다. 이렇게 parameter를 learning한 이후에는 parameter를 사용해 posterior를 계산하게 된다. 이때 Model에 따라 inference를 하는 방법이 달라지게 되는데 discriminative model은 parameter를 사용해 directly하게 posterior를 계산하게 되고, generative model은 joint distribution을 learning하여 posterior를 indirectly하게 유추하게 된다.</p>




<h5>변경 이력</h5>


<ul>
<li>2014년 8월 19일: 글 등록</li>
<li>2015년 2월 28일: 변경 이력 추가</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (4) Algorithm]]></title>
    <link href="http://SanghyukChun.github.io/60/"/>
    <updated>2014-08-10T21:17:00+09:00</updated>
    <id>http://SanghyukChun.github.io/60</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Machine Learning을 제대로 이해하기 위해서는 알고리즘에 대한 이해가 필수적이다. 어떤 알고리즘이 좋은 것이고 어떤 알고리즘이 나쁜 것인지에 대한 구분이 이뤄져야지만 향후 논의하게 될 많은 주제들에 대해 얘기하기 쉬워진다. 어떤 문제가 풀 수 있는 문제이고 어떤 문제가 풀 수 없는 문제인가? 풀 수 있다 없다는 어떻게 정의하는가? 등에 대해 이해해야만 머신러닝 알고리즘들에서 얘기하는 local optimum이나 compuation complexity 등에 대해 이해할 수 있을 것이다. (잘 모르는 개념이더라도 영화 이미테이션 게임을 봤다면 금방 이해할 수 있을 것이다)</p>


<p><a href="57">이전 글</a>에서 머신러닝에서 알고리즘이란 어떤 의미가 있는지를 얘기했었다. 쉽게 생각하면, 우리가 원하는 형태로 모델을 정의한 이후에 그 모델을 어떻게 learning할 것인가, 즉, 어떤 알고리즘을 사용하여 model을 learning할 것인가에 대한 얘기를 하기 위해서는 알고리즘에 대해 반드시 짚고 넘어가야만 한다. 알고리즘 부분에서 반드시 짚고 넘어가야할 부분은 (1) Big O notation (2) P and NP (3) Reduction (4) NP Complete (5) Approximation Algorithm 정도라고 생각하기에 이 글에서는 이 정도 내용을 다루도록 하겠다.</p>


<h5 id="60-1-bigO">Algorithm, Big O notation</h5>


<p>먼저 algorithm이란 무엇인지에 대해 생각해보자. 알고리즘이란 것의 정확한 정의는 <a href="http://en.wikipedia.org/wiki/Algorithm">위키</a>를 참고하길 바란다. 알고리즘에 있어서 중요한 몇 가지를 꼽자면, 먼저 input이 정의가 되어야하며 output을 가져야한다. 즉, 알고리즘은 특정 데이터에 대해 동작해야하며, 해당 데이터에 대한 알고리즘의 결과를 출력해야만한다. 그리고 알고리즘은 반드시 어떤 &#8216;목적&#8217;을 가지고 있다. 즉, 내가 만약 특정 지점부터 다른 특정 지점으로 이동하는 가장 짧은 path를 찾는 알고리즘을 작성해야만한다면 해당 알고리즘의 목적은 shortest path를 찾는 것이고, input은 임의의 graph와 시작점, 그리고 끝점이 될 것이다. 마지막으로 출력값은 shortest path가 될 것이다. 이런 것을 행할 수 있는 일종의 procedure가 알고리즘이라고 할 수 있다. 하지만 우리는 그냥 임의의 알고리즘이 필요한 것이 아니라 &#8216;좋은&#8217; 알고리즘이 필요하다. 예를 들어서 Algorithm A는 shortest path를 찾는데 1시간이 걸리고, Algorithm B는 4초가 걸린다면 당연히 B를 사용해야할 것이다. 그렇다면 알고리즘의 좋다 혹은 나쁘다는 무엇으로 구분하느냐, <a href="http://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a>의 역할이 바로 그것을 구분하는 역할을 하는 것인데, 이 notation은 해당하는 알고리즘이 &#8216;주어진 input의 크기에 대해&#8217; 계산량이 얼마나 필요하느냐를 indicate하는 notation이다. 표기는 O(n) 와 같은 꼴로 표시하게 된다. n은 input의 크기이다. 예를 들어 shortest path면 전체 graph의 node의 개수가 될 것이다. O notation은 일종의 upper limit로, 아무리 최악의 상황에서도 계산량이 O 안에 있는 양보다 적게 걸린다는 의미이다. 또한 만약 소요 시간이 2n 이거나 n+1 이거나 10000000000000000n 이어도 이 알고리즘들은 모두 O(n)이 된다. 이 정도 얘기는 조금만 구글링해도 많이 나오는 얘기니 여기까지만 적고, 진짜 중요한건 &#8216;polynomial time&#8217;일 것이다. 무슨 얘기이냐하면, 알고리즘의 실행시간이 input의 크기가 늘어나는 것에 대해 polynomial scale로 증가하는 알고리즘이 좋은 알고리즘이라는 뜻이다. 당연히 input에 대해 최대한 적게 증가하는 알고리즘이 좋기는 하지만, \( O(e^n) \) 보다는 \( O(n^4) \) 이 훨씬 더 좋다는 얘기이다. Exponential time이 소요되는 알고리즘은 사실상 거의 무한대의 시간이 걸린다고 봐도 될 정도로 절망적인 computation time을 의미하며, 제대로 활용 가능한 알고리즘이 되려면 그 알고리즘의 computation time은 반드시 polynomial time이어야한다.</p>


<p>Expotentially increase라는 말에는 정말 어마어마한 파괴력이 있다. 이것이 왜 절망적이냐하면, 우리가 linear한 10n 알고리즘을 가지고 있을 때 input의 size가 1, 2, 3 의 순으로 증가하더라도 여전히 computation time은 10, 20, 30이지만, exponential time이 필요한 경우에는 예를 들어 10^n이라고 한다면 10, 100, 1000만큼의 시간이 필요하다. 즉 input이 3배 증가했을 뿐인데 두 알고리즘은 1000/30 = 33.33 배 만큼의 성능차이가 나는 것이다. 만약 input size가 100이라면? \(10^{97}\) 만큼의 차이가 난다. Exponential이라는 것에는 이만큼의 파괴력이 있다. 그러나 polynomial time안에 풀 수 있다면, 100배가 증가했을 때, n과 \(n^2\)의 차이는 100에 불과하다. 이 때문에 polynomial time algorithm은 풀 수 있는 문제로 취급되고, exponential algorithm은 실제로 쓸 수 없는 알고리즘으로 취급받는 것이다. <a href="http://SanghyukChun.github.io/59#59-3-ms">이전 글의 model selection part</a>에서 &#8216;그리고 데이터가 많아지면 그런 validation set이 엄청나게 많아진다. 정확히는 exponential로 늘어나기 때문에 마냥 모든 데이터에 대해 cross-validation을 하는 것은 불가능하다.&#8217; 라는 표현을 했을 때 exponential 로 증가하는 validation이 불가능하다는 표현을 했던 것이다.</p>


<h5 id="60-2-np">P and NP</h5>


<p>P problem이란 해당하는 문제를 polynomial time안에 풀 수 있는 알고리즘을 제시할 수 있는 문제를 의미한다. 예를 들어 우리에게 주어진 데이터의 개수를 sorting하는 알고리즘은 \(n log n\) 의 시간이 필요하므로 P problem이라 할 수 있다. NP problem은 올바르지는 않지만 진짜 진짜 간단하게, 표현하면, &#8216;polynomial time안에 풀 수 없는 엄청나게 어려운 문제&#8217; 라고 할 수 있다. 하지만 이것은 올바르지 않은 정의이며, 심지어 정말 polynomial time안에 풀 수 없는지 조차 아직 확실하지 않다. NP problem의 정확한 정의는 &#8216;problem이 주어지고 해당 problem에 대해 어떤 suggested solution이 주어졌을 때 polynomial time안에 그 solution이 맞는 solution인지 아닌지 구분할 수 있는 문제&#8217;라고 할 수 있다. 당연히 정확한 답을 polynomial time안에 풀 수 있는 P는 NP의 subset이다. 즉, NP는 P를 포함하는 set이라고 할 수 있다. 그렇다면 NP는 반드시 P보다 크다고 할 수 있을까? 이 문제를 얘기하려면 먼저 Reduction에 대해 다뤄야한다.</p>


<h5 id="60-3-red">Reduction</h5>


<p>Problem X에서 Y로의 Reduction이란 만약 우리가 Problem Y를 풀 수 있는 Algorithm을 가지고 있을 때, 이 algorithm을 사용해 problem X를 풀 수 있는 algorithm을 찾을 수 있다는 것을 의미한다. 즉, 우리가 problem X를 풀기위해서는 problem Y를 풀기만 하면 된다. 즉, 간단히 생각하면 문제 Y가 X보다는 더 어려운 문제라고 생각하면 된다. 만약 우리가 problem Y 를 풀기위한 algorithm 중에서 P인 algorithm을 가지고 있다면, 그리고 reduction을 polynomial time안에 할 수 있다면 우리는 반드시 problem X를 polynomial time안에 풀 수 있을 것이다.</p>


<h5 id="60-4-npc">NP Complete</h5>


<p>NP Complete problem은 모든 NP problem이 해당 problem으로 reduction될 수 있는 문제를 의미한다. 즉, 내가 그 어떤 NP problem을 제시하더라도 반드시 어떤 NP complete problem으로 reduction시키는 것이 가능하다. 그리고 <a href="http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">Cook-Levin Theorem</a>에서 Boolean SAT problem이 NP problem이라는 것을 증명한다. 그렇다면 당연히 SAT problem을 통해서 다른 NP complete problem들을 찾을 수 있다. 우리가 많이 사용하는 NP complete problem들은 <a href="http://en.wikipedia.org/wiki/Independent_set_problem">Independent set problem</a>, <a href="http://en.wikipedia.org/wiki/Clique_problem">Clique problem</a>, <a href="http://en.wikipedia.org/wiki/Vertex_cover_problem">Vertex Cover problem</a>, <a href="http://en.wikipedia.org/wiki/Set_cover">Set Cover problem</a>, <a href="http://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum problem</a> <a href="http://en.wikipedia.org/wiki/Hamiltonian_path_problem">Hamiltonian path problem</a>, <a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling salesman problem</a>, <a href="http://en.wikipedia.org/wiki/Graph_coloring_problem">Graph Coloring problem</a> 등이 있다. 해당 문제들의 전체 목록은 <a href="http://en.wikipedia.org/wiki/NP-complete#NP-complete_problems">위키</a>에서도 볼 수 있다.</p>


<p>그렇다면 당연히 필연적으로 할 수 있는 질문은, &#8216;NP complete problem을 polynomial time안에 풀 수 있는가?&#8217; 라는 질문이 되겠다. 당연히 위에 서술한 그 어떤 문제 중에서 단 하나라도 polynomial solution을 제시할 수 있다면 모든 NP 문제들을 P로 풀 수 있을 것이다. 이 질문이 그 유명한 <a href="http://en.wikipedia.org/wiki/P_versus_NP_problem">P=NP?</a> 문제가 되겠다. 그리고 또 안타깝게도 이 문제는 <a href="http://en.wikipedia.org/wiki/Millennium_Prize_Problems">Millennium Prize Problems</a>라고 해서 엄청나게 어려운, 상금이 걸려있는 문제 중 하나이다. 즉, 아직도 결론이 나지 않은 문제이다. 하지만 그럼에도 대부분의 사람들이 NP complete는 polynomial time안에 풀 수 없다고 생각하고 있으며, 그 때문에 현재 우리가 사용 중인 모든 보안 알고리즘들은 이 NP completeness에 기반하여 만들어져있다. (정확히는 숫자를 곱하는 것은 쉬우나, 주어진 숫자가 소수인지아닌지 구분하는 것은 NP hard problem이라는 특성을 사용한다. - NP hard는 NP complete만큼 어렵거나 그보다 더 어려운 문제를 의미.) 따라서 일단 해당 문제를 reduction했더니 NP complete problem이 튀어나온다면 그 문제는 polynomial안에 답을 낼 수 없는 문제가 되겠다.</p>


<h5 id="60-4-aa">Approximation Algorithm</h5>


<p>그렇다고 이 문제는 NPC problem이니까 풀지말자! 라고 넘기기에는 세상에 너무나 많은 문제들이 NP complete problem이다. 그래서 정확하지는 않지만 NP complete problem을 풀기위한 여러가지 방법들이 존재한다. (<a href="http://en.wikipedia.org/wiki/NP-complete#Solving_NP-complete_problems">위키</a> 참고) 그 중에서도 approximation algorithm은 정확한 답을 구하는 것이 아니라 approximated solution을 polynomial안에 얻어내는 알고리즘을 의미한다. 즉, 원래 알고리즘이 x라는 답을 줬을 때, \(\alpha\)-approximation algorithm은 \(\alpha\)x 라는 답을 주게 된다. 자세한 점은 <a href="http://en.wikipedia.org/wiki/Approximation_algorithm">위키</a> 참고. 즉, NPC problem이 절망적으로 어려운 문제인 것은 맞지만 마냥 절망만 하고 있을 필요는 없다는 의미이며, approximation 말고도 NPC를 해결하는 방법은 여러 방법들이 존재한다. 하지만 일단 가장 중요한 개념 중 하나라고 할 수 있다.</p>


<p>수 많은 경우, Machine Learning 문제를 해결하다보면, 해당 문제가 NP complete problem인 경우가 많이 존재한다. 따라서 절대적인 값을 구하는 것이 불가능하여 어쩔 수 없이 local optimum을 구하는 경우도 있고, 혹은 해당 문제를 정확히 일치하지는 않지만 polynomial time안에 구할 수 있는 문제로 바꾸어 문제를 해결하는 방법도 존재한다. 즉, Machine learning에 대해 공부하기 위해서는 algorithm에 대한 이해가 매우매우 필수적이라고 할 수 있을 것이다.</p>




<h5>변경 이력</h5>


<ul>
<li>2014년 8월 10일: 글 등록</li>
<li>2015년 2월 28일: 변경 이력 추가, 문장 표현 등 수정 (알고리듬->알고리즘)</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (3) Overfitting]]></title>
    <link href="http://SanghyukChun.github.io/59/"/>
    <updated>2014-08-04T12:09:00+09:00</updated>
    <id>http://SanghyukChun.github.io/59</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Overfitting은 Machine Learning Algorithm을 design하고 실제 구현을 할 때 Algorithm 설계를 제외하면 가장 어렵고 머리를 아프게 하는 문제 중 하나이다. Overfitting을 잘 관리하지 못하면 실전에서 써먹을 수 없는 알고리즘이 되기 때문에 overfitting을 잘 관리하는 것의 중요성은 몇 번을 강조해도 부족하지 않다. 보통 overfitting을 따로 chapter로 빼거나 하는 등으로 설명하는 경우가 많이 없지만, 나는 그만큼 overfitting과 관련된 이슈들이 중요하다고 생각하고, 다룰 얘기가 많다고 생각하기 때문에 이 글을 통해 overfitting의 개념과 그것을 해결하기 위한 방법, overfitting이 발생하는 근본적인 원인 등에 대해 다루도록 하겠다.</p>


<h5 id="59-1-overfitting">Overfitting</h5>


<p><a href="http://en.wikipedia.org/wiki/Overfitting">Overfitting</a>이란 문자 그대로 너무 과도하게 데이터에 대해 모델을 learning을 한 경우를 의미한다. 현재에 대해 잘 설명하는 것 만으로 충분하지 않을까라고 생각할 수 있지만, 우리가 사실 원하는 정보는 기존에 알고 있는 데이터에 대한 것들이 아니라 새롭게 우리가 알게되는 데이터에 대한 것들을 알고 싶은 것인데, 정작 새로운 데이터에 대해서는 하나도 못맞추고, 즉 제대로 설명할 수 없는 경우라면 그 시스템은 그야말로 무용지물이라고 할 수 있을 것이다. <a href="http://SanghyukChun.github.io/14#Overfitting">이전에 적은 포스트</a>에서도 간략하게 다루고 있다.</p>


<h5 id="59-2-reg">Regularization</h5>


<p>Overfitting을 어떻게 해결할까 고민하기에 앞서 먼저 Overfitting이 일어나는 이유는 무엇인가에 대해서 한 번 생각해보자. 먼저 overfitting의 가장 간단한 예시를 하나 생각해보자.</p>


<p><img src="http://SanghyukChun.github.io/images/post/59-1.png" width="500"></p>

<p>위 그림에서도 알 수 있 듯, 만약 우리가 주어진 데이터에 비해서 높은 complexity를 가지는 model을 learning하게 된다면 overfitting이 일어날 확률이 높다. 그렇다면 한 가지 가설을 세울 수 있는데, &#8216;complexity가 높을 수록 별로 좋은 모델이 아니다.&#8217; 라는 가설이다. 이는 <a href="http://en.wikipedia.org/wiki/Occam%27s_razor">Occam&#8217;s razor</a>, 오컴의 면도날이라 하여 문제의 solution은 간단하면 간단할수록 좋다라는 가설과 일맥상통하는 내용이다. 하지만 그렇다고해서 너무 complexity가 낮은 model을 사용한다면 역시 부정확한 결과를 얻게 될 것은 거의 자명해보인다. 그렇기 때문에 우리는 원래 cost function에 complexity와 관련된 penalty term을 추가하여, 어느 정도 &#8216;적당한&#8217; complexity를 찾을 수 있다. 이를 regularization이라 한다. 이 이외에도 다양한 설명이 있을 수 있기에 <a href="http://en.wikipedia.org/wiki/Regularization_(mathematics)">위키 링크</a>를 첨부한다.</p>


<p>그리고 이를 Bayesian 관점에서 설명을 할 수도 있다.</p>


<p>\[ p(Y|X) = {p(X|Y) p(Y) \over p(X)} \]</p>


<p><a href="58#58-1-Bayes">이전 글</a>에서도 설명했던 것 처럼, 만약 우리가 어떤 사전지식, 혹은 prior knowledge가 존재한다면 단순히 observation만 하는 것 보다는 훨씬 더 잘 할 수 있을 것이다. 그리고 다시 Overfitting 문제로 돌아와서, overfitting이 생기는 가장 큰 이유는 너무 지금 데이터, 즉 observation에만 충실했던 것이 그 원인이다. 그러면 당연히 prior가 있으면 이를 해결할 수 있지 않을까? 라는 질문을 던질 수 있을 것이다. 즉, 우리의 prior는 high complexity solution은 나오지 않을 것이다. 어느정도 complexity가 높아지는 것 까지는 용인하지만, (표현할 수 있는 영역이 더 넓어지니까) 하지만 너무 그 complexity가 높아지면 문제가 생길 수 있다. 즉, 그런 high complexity를 가지는 solution이 나올 확률 자체가 매우 낮다. 라는 prior가 있다면 이를 간단하게 해결 할 수 있을 것이며, 이것이 결국 앞에서 봤었던 penalty와 동일하다는 것을 알 수 있다.</p>


<h5 id="59-3-ms">Model Selection</h5>


<p>그런데 제 아무리 우리가 좋은 prior를 넣고, 좋은 penalty term을 design하더라도 만약 우리가 제대로 되지 않은 데이터들을 이용해 learning을 한다면 문제가 생길 수 있다. 마치 장님 코끼리 만지듯 전체 데이터는 엄청나게 많이 분포해있는데 우리가 가진 데이터가 아주 일부분에 대한 정보라면, 혹은 갑자기 그 상황에서 갑자기 노이즈가 팍 튀어서 데이터가 통채로 잘못 들어온다면? 아마 그런 데이터로 learning을 했다가는 sample bias가 일어나게 되어 크게 성능이 저하되게 될 것이다. 사실 위에 complexity라는 말도 결국에는 &#8216;Data point 대비 높은 complexity&#8217;가 더 정확한 말이다. 이를 최대한 피하기 위하여 우리는 <a href="http://en.wikipedia.org/wiki/Generalization">generalization</a> 이라는걸 하게 되는데, 다시 말해서 우리의 solution이 specific한 결과만을 주는 것이 아니라 general한 결과를 주도록 하려는 것이다. 이를 위한 여러 방법이 있을 수 있지만, 가장 많이 사용하는 방법은 validation set이라는 것을 사용하는 것이다. 즉, 모든 data를 전부 training에 사용하는 것이 아니라, 일부만 training에 사용하고 나머지를 일종의 validation을 하는 용도로 확인하는 것이다. 만약 우리의 모델이 꽤 괜찮은 모델이고, validation set이 잘 선택이 되었다면 training set에서만큼 validation set에서도 좋은 결과가 나올 수 있을 것이다.</p>


<p>보통 전체 데이터 중에서 training과 validation의 비율은 8:2로 하는 것이 일반적이다. 하지만 만약 validation set이 너무 작다면, 이 마저도 좋은 결과를 내기에는 부족할 수 있다. 이를 해결할 수 있는 컨셉 중에서 cross-validation이라는 컨셉이 있는데, validation set을 하나만 가지는 것이 아니라 여러개의 validation set을 정해놓고 각각의 set에 대해서 learning을 하는 것이다. 예를 들어 우리가 데이터가 X={1,2,3,4,5,6,7,8,9,10} 이 있을 때, 첫 번째 learning에서는 {1,..,8}을 사용해 learning하고 그 다음에는 {2,..,9}까지 learning하는 식으로 모든 permutation에 대해서 learning을 할 수 있을 것이다. 그리고 당연히 이런 방식으로 여러번 learning을 하게되면 그 때 얻어지는 model parameter는 그때그때 달라질텐데, cross-validation은 그 값들을 적당히 사용하여 가장 적절한 parameter를 얻어내는 방식이다. average로 해도 되고, median으로 해도 되고, 여러 방법이 있을 수 있다. cross-validation의 단점은 algorithm의 running time이 데이터의 크기 뿐 아니라 validation을 하기 위한 그 여러 set들에 dependent하다는 것이다. 그리고 데이터가 많아지면 그런 validation set이 엄청나게 많아진다. 정확히는 exponential로 늘어나기 때문에 마냥 모든 데이터에 대해 cross-validation을 하는 것은 불가능하다.</p>


<p>그렇기 때문에 실제로 cross-validation을 할때는 모든 데이터를 사용하지는 않고, 적당히 몇 개의 set을 골라서 여러 번 model parameter를 &#8216;적당히&#8217; 구하는 방법을 사용한다. 물론 이론적으로 AIC, BIC 등의 개념이 존재하여 이에 맞춰서 모델을 고르는 방법도 존재하지만 (AIC는 Akaike Information Criterion이고 BIC는 Bayesian Information Criterion으로, 둘 다 어떤 &#8216;information criteria&#8217;를 사용하느냐에 대한 내용이다.) 지금 내가 다루고자 하는 내용에서 좀 벗어나기 때문에 나중에 여유가 되면 이에 대한 글을 작성해보도록하겠다.</p>


<h5 id="59-4-cd">Curse of dimension</h5>


<p>그러나 이게 끝이 아니다. 우리가 싸워 이겨내야할 문제들은 complexity, number of data 뿐 아니라 dimension of data 역시 존재한다. 즉, 우리가 1차원의 데이터를 다루는 것과 10000차원의 데이터를 다루는 것과는 정말 어마어마한 차이가 존재한다는 것이다. 이렇게 차원이 높은 데이터를 다룰 일이 있을까? 하고 약간 막연하게 생각할 수 있지만, 가장 간단한 예로, 100px by 100px 그림은 각각의 픽셀이 하나의 차원이라고 했을 때 10000차원 벡터로 표현이 가능하다. 실제로 머신러닝 분야에서 이미지를 다룰 때는 이런 식으로 처리를 하게 된다. 이 이외에도 high dimensioanl space 상에 존재하는 데이터를 다룰 일은 매우 많이 존재한다.</p>


<p>그렇다면 이런 high dimensional data가 왜 우리가 learning한 system의 성능을 나쁘게 만들까? 정말 간단하게 생각해보자. 만약 우리가 주어진 공간을 regular cell로 나눴다고 가정해보자. 그리고 각각의 cell에 가장 많이 존재하는 class를 그 cell의 class로 생각하여 무조건 그 cell에 존재하는 데이터는 그 class라고 하는 logic을 생각해보자. 당연히 cell의 개수를 무한하게 가져가게 된다면, 그리고 데이터가 무한하다면 이 logic은 반드시 truth로 수렴하게 될 것이다. 이 알고리듬이 제대로 동작하려면 각각의 cell, 혹은 bin이 반드시 차있어야한다. 즉, 비어있는 empty cell이 존재해서는 안된다. 따라서 데이터는 아무리 적어도 cell의 개수만큼은 존재해야한다. 그런데 이렇게 cell을 만들게 될 경우 그 cell의 개수는 dimension이 증가함에 따라 exponential하게 늘어나게 되는 것이다. 예를 들어 우리가 1차원상에서 3개의 bin을 가지고 있다고 하면, 이는 2차원상에서는 9개, 3차원상에서는 27개.. 이렇게 exponentially grow하게 되는 것을 알 수 있다. 이 모델의 parameter들이 exponentially 증가하는 것이다. (아래 슬라이드(<a href="http://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/">출처</a>) 참고)</p>


<p><img src="http://SanghyukChun.github.io/images/post/59-2.png" width="600"></p>

<p>따라서 당연히 각각의 bin이 비어있지 않도록 ensure해줄 수 있는 data의 개수 역시 exponentially 하게 늘어나게 되고, 즉 차원이 증가하게 되면 필요한 데이터가 exponentailly하게 늘어나게 된다는 것을 의미한다. 그러나 당연히 우리가 3차원 데이터보다 100000차원 데이터를 exponential하게 더 많이 가지고 있으리라는 법은 없고, 이로 인해 문제가 발생하게 되는 것이다.</p>


<p></p>

<p>그리고 또 문제가 되는 것은 high dimensional space에서 정의되는 metric들로, 특히 2-norm 혹은 euclidean distance의 경우는 그 왜곡이 매우 심하여, 실제 멀리 떨어진 데이터보다 별로 멀리 떨어져있지 않고 각 dimension의 방향으로 약간의 noise가 섞여있는 데이터에 더 큰 distance를 부여하는 등의 문제가 존재한다.</p>


<p>조금 다른 예를 들어보자. 만약 D-dimensional space에서 엄청나게 얇은 구각을 만들었다고 생각해보자. 여기에서 &#8216;구&#8217; 라는 것은 한 점에 대해 거리가 동일하게 떨어져있는 모든 점 내부의 영역을 의미한다는 것은 당연한 것이고.. 이 구의 부피는 \(V_D(r)=K_D r^D\) 가 될 것이며, \(K_D\)는 그냥 D에 대한 상수라고 생각하면 된다. 그럼 반지름이 1이고 두께가 \(\epsilon\)인 구각의 부피와 반지름이 1인 구의 부피의 비율은 \({V_D(1) - V_D(1-\epsilon) \over V_D(1)} = 1-(1-\epsilon)^D\) 가 될 것이다. 놀랍게도, 만약 very very high dimension D에서는 이 값이 1로 수렴하게 된다. 즉, 매우 얇은 구각의 부피가 구의 부피와 같다는 의미. 혹은 대부분의 부피가 거의 surface에 가까운 엄청나게 얇은 그 shell에 존재한다는 희한하고 요상한 의미가 된다.</p>


<p>즉, high dimension은 (1) model의 complexity도 증가시키며 (2) 필요한 데이터의 양도 exponentially 하게 늘어나게 하고 (3) 우리가 기존에 사용하던 metric이 제대로 동작하지 않는 그야말로 끔찍한 환경이라 할 수 있다. 그래서 이런 high dimensional space에서 일어나는 여러 문제점들을 통틀어 Curse of dimension이라 한다.</p>


<p>이를 해결하기 위해서는 결국 feature extraction 등의 기술을 사용하여 dimension을 가장 적절하게 낮추는 것이 바람직하다고 할 수 있다.</p>


<h5 id="59-5-bvt">Bias-variance Trade-off</h5>


<p><a href="http://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff">Bias-variance trade-off</a> 라는 개념은 사실 굉장히 유명한 개념이다. 간단하게 말하면 bias와 variance는 어쩔 수 없는 trade-off 관계를 가지고 있다는 의미이다. 자세한 증명과정은 링크해둔 위키피디아를 참고하면 된다. 간단히 컨셉만 언급하자면, Bias는 평균적으로 우리의 가설 h(x)가 얼마나 실제 현상 y(x)와 떨어져 있느냐에 대한 얘기이다. 즉, bias가 낮을수록 실제 현상에 유사하며, bias가 높을수록 실제 현상과 멀어진다. 이는 실제로 bias라는 단어가 가지고 있는 의미와 거의 유사하다. Variance는 평균에서 얼마나 멀리 떨어져있느냐를 의미하는데, variance가 높을수록 데이터들이 평균과 멀리 떨어져있고, variance가 낮을수록 데이터들은 평균과 가깝게 분포하여있다. 재미있는 점은 이 둘이 완전한 trade-off관계를 가지고 있다는 것인데, 증명 아이디어는, h(x)와 y(x)의 expected squared error를 계산해봤을 때 그 값이 정확하게 bias와 variance들에 대한 표현으로 decompose가 된다는 것이다. 주어진 데이터에 대해 bias가 낮으면 variance가 높고, bias가 높으면 variance가 낮다. 그런데 이때 bias는 overfitting 혹은 generalize에 대한 term이 되는데, 이유는 현재 관측하고 있는 데이터에 대해 bias가 낮다는 의미는 지금 데이터에만 너무 치중이 되어있다는 의미가 되기 때문이다. 즉, 너무 낮은 bias는 곧 overfitting과 거의 같은 의미라고 할 수 있다. 그 뿐 아니라 높은 variance는 다시 말해 complexity가 높다는 의미로도 받아들일 수 있기 때문에, 너무 낮은 bias 혹은 높은 variance를 피해야한다. 그렇지만 bias가 높은게 능사는 아닌데, 자칫 잘못하면 너무 bias가 높은 underfitted된 모델을 얻을 수도 있기 떄문이다. 즉, bias는 지금 내가 보고 있는 데이터를 얼마나 신뢰하느냐에 대한 척도라고 할 수 있는데, 지금 내가 보고 있는 데이터를 아예 신뢰하지 않는다고 한다면, 이는 machine learning을 통해 model을 얻었을 때 그 모델이 잘 동작할 것이라고 기대하기는 힘들 것이다.</p>


<p>굉장히 좋은 글을 발견해서 <a href="http://scott.fortmann-roe.com/docs/BiasVariance.html">링크</a>를 추가하도록 하겠다. 혹시 더 관심이 있는 사람들은 이 글을 읽어보면 될 것 같다.</p>


<p></p>

<h5 id="59-6-robust">Overfitting and Robustness</h5>


<p>마지막으로 Robustness라는 개념에 다루고 글을 마치도록 하겠다. 지금까지 overfitting에 대한 설명을 읽어보면 알 수 있듯, overfitting이라는 것은 generalize라는 concept과 거의 정반대의 개념이라는 것을 알 수 있다. Generalize라는 개념은 일부분에만 잘 설명이 되는 것이 아닌 일반적으로도 잘 맞아 떨어지는 설명을 할 수 있도록 시스템을 만드는 것이라 생각하면 편한데, 다시 말해서 overfitting이 적은 시스템을 만드는 것이라고 생각할 수 있다. 이 generalize라는 개념을 생각할 때에 robust라는 개념도 같이 생각을 할 필요가 있는데, 매우 간단하게 설명하면, robust라는 컨셉은 &#8216;잘못된 데이터가 들어와도 시스템이 크게 변하지 않는 것&#8217; 이라고 할 수 있다. 이때 잘못된 데이터를 흔히 outlier라고 하는데, 전혀 엉뚱한 데이터가 시스템에 들어온 경우 이 데이터로 인해 전체 시스템의 성능이 저하되지 않도록 하는 것을 의미한다. 보통 이런 엉뚱한 데이터는 noise에 의해 발생하게 되므로, robust라는 개념은 noisy한 환경에 덜 취약한 시스템을 구축하는 것이라 이해해도 좋을 것이다. 보통 robust한 시스템을 만들 때에 많이 사용하는 것은 metric을 변경하는 것이다. 즉, 대부분의 machine learning algorithm들이 metric을 기반으로 한 것들이 많은데, 거의 대부분이 2-norm의 제곱인 Euclidean distance를 사용한다. 때문에 이는 데이터의 제곱에 루트를 씌운 것에 또 제곱을 취하기 떄문에 그냥 절대값을 더하는 l1 norm등에 비해 outlier에 더 취약하다. 가장 robust한 norm은 l0 norm이지만 이것은 non-convex하기 때문에 보통 l1 norm으로 relax시켜서 계산을 하게 된다. 이런 robust system에 대해서는 이번 스터디에서는 직접 다루지는 않을 예정이지만, 현재 내 연구가 이쪽인만큼, 언젠가 한 번 큰 주제로 다뤄볼 수 있도록 하겠다.</p>




<h5>변경 이력</h5>


<ul>
<li>2014년 8월 4일: 글 등록</li>
<li>2014년 10월 9일: 구성 변경 및 내용 추가 (Bayes, Model Selection 등)</li>
<li>2015년 2월 28일: 변경 이력 추가, 문장 표현 등 수정</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (2) Probability Theory]]></title>
    <link href="http://SanghyukChun.github.io/58/"/>
    <updated>2014-08-03T14:18:00+09:00</updated>
    <id>http://SanghyukChun.github.io/58</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Probability thoery는 Machine Learning을 공부하기 전에 필수적으로 이해해야하는 개념들 중 하나이다. 이 글에서는 가장 기본적인 확률 개념에 대해서는 알고 있다고 가정한다. 예를 들어  independence, joint probability, marginal probability, conditional probability 등 기본적인 개념이나 \(p(X) = \sum_Y p(X,Y) \) 혹은 \(p(X,Y) = p(Y|X) p(X)\) 등 자주 사용되는 관계 등에 대해서는 이미 알고 있다고 생각했고, 또한 random variable 등에 대한 기본적인 지식이 이미 존재한다고 가정하고 글을 작성하였다. 만약 이런 개념들에 대해 잘 알지 못한다면 다른 글이나 강의 등을 통해 그 개념들을 먼저 이해하고 글을 읽으면 좋다.</p>


<h5 id="58-prob_view">Machine Learning - Probabilistic perspective</h5>


<p><a href="http://SanghyukChun.github.io/57">이전 글</a>에서 설명했던 머신러닝의 개념을 다시 생각해보자. 머신러닝은 아래 그림처럼 설명할 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/57-2.png" width="600"></p>

<p>이전 글에서 나는 머신러닝이 주어진 데이터를 가장 잘 설명하는 &#8216;함수&#8217;를 찾는 알고리즘을 디자인하는 것이라 설명했다. 그러나 머신러닝은 확률의 관점에서도 설명이 가능하다. 머신러닝을 <a href="http://en.wikipedia.org/wiki/Probability_density_function">probability density</a>를 찾는 과정으로 생각하는 것이다. 즉, 함수를 가정하는 것이 아니라 확률 분포를 가정하고, 적절한 확률 분포의 parameter를 유추하는 과정으로 생각하는 것이다. 주어진 데이터가 gaussian distribution으로 drawn되었다고 가정하고, 데이터와 현상을 가장 잘 설명하는 mean과 covariance를 찾는 과정과 비슷한 것이라고 생각하면 된다. 즉, 앞에서 설명한 방식은 function parameter를 찾는 방식이라면, 이제는 probability density function parameter를 찾는 것으로 바뀌는 것이다.</p>


<h5 id="58-MLE">Maximum Likelihood Estimation (MLE)</h5>


<p>보다 자세한 설명을 하기에 앞서, 몇 가지 개념들을 소개하고 넘어가도록 하겠다. <a href="http://en.wikipedia.org/wiki/Maximum_likelihood">Maximum Likelihood Estimation (MLE)</a>는 random variable의 parameter를 estimate하는 방법 중 하나인데, 오직 주어진 Observation, 혹은 데이터들 만을 토대로 parameter estimation을 하는 방법이다. 가장 간단한 예를 들어보자. 만약 우리가 \(p\)의 확률로 앞면이 나오고 \(1-p\)의 확률로 뒷면이 나오는 동전을 던져서 \(p\)를 예측한다고 생각해보자. MLE로 \(p\)를 계산하기 위해서는 간단하게 앞면이 나온 횟수를 전체 횟수로 나누면 된다.</p>


<p>보다 더 자세한 설명을 위해 알려지지 않은 probability density function \(f_0\)가 있다고 가정해보자. 그리고 \(X = (x_1, x_2, x_3, \ldots, x_n)\)를 그 확률로 생성되는 Observation 이라 하자 (측정한 데이터라고 생각하면 된다). 이제 density function이 다음과 같이 \(\theta\)로 parameterize된 어떤 분포의 family라고 가정해보자. \(\{f(\cdot|\theta)\}\). 만약 observation \(x\)가 주어진다면, \(\theta\)의 값만 알 수 있다면 바로 \(f(x|\theta)\)의 값을 계산할 수 있는 것이다. 만약 \(f\)가 가우시안이라면 \(\theta\)는 mean \(\mu\)와 covariance \(\Sigma\)일 것이고, Bernoulli라면 \(0 \leq p \leq 1\)가 될 것이다. 이렇게 정의하게 되면 Likelihood는 다음과 같이 정의할 수 있다.</p>


<p>\[\mathcal L (\theta;x_1, x_2, \ldots, x_n) = \mathcal L (\theta;X) = f(X|\theta) = f(x_1, x_2, \ldots, x_n|\theta) \]</p>


<p>Maximum Likelihood Estimation (MLE)는 \(\theta\)를 estimate하는 방법 중 하나로, Likelihood를 최대로 만드는 값으로 선택하는 것이다. 만약 우리가 선택하는 값을 \(\hat \theta\)라고 적는다면, MLE는 다음과 같은 방식으로 값을 찾는다.</p>


<p>\[\hat \theta = \arg\max_\theta \mathcal L (\theta;X) = \arg\max_\theta f(X|\theta)\]</p>


<p>참고로, 만약 observation이 i.i.d. (independent and identical distributed)하다면, \(f(X|\theta) = \prod_i f(x_i|\theta)\)가 되며, 여기에 log를 씌우면 덧셈 꼴이 된다. log는 단조증가함수이므로, log를 취했을 때 최대값을 가지는 지점과 원래 최대값을 가지는 지점이 동일하고, 보통 곱셈보다 덧셈이 계산이 더 간편하므로, 많은 경우에 likelihood가 아니라 log likelihood를 사용해 parameter estimation을 계산한다.</p>


<p>다시 원래 얘기로 돌아가보자. MLE는 가장 간단한 parameter estimation method이지만, observation에 따라 그 값이 너무 민감하게 변한다는 단점을 가지고 있다. 다시 동전 던지기를 예로 들어보자. 동전 던지기는 확률 과정이기 때문에 극단적인 경우로 \(n\)번을 던져서 앞면이 \(n\)번이 나올 수가 있다. 이 경우 MLE는 이 동전은 앞면만 나오는 동전이라고 판단해버린다. 만약 스팸필터를 만드는데 연속으로 스팸이 아닌 메일이 \(n\)개가 들어왔다고해서 모든 메일이 스팸이 아니라고 할 수 있을까?</p>


<h5 id="58-MAP">Maximum a Posteriori Estimation (MAP)</h5>


<p>MLE의 단점을 해결하기 위해 <a href="http://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation">Maximum a Posteriori Estimation(MAP)</a>이라는 방법을 사용하기도 한다. 이 방법은 \(\theta\)가 주어지고, 그 \(\theta\)에 대한 데이터들의 확률을 최대화하는 것이 아니라, 주어진 데이터에 대해 최대 확률을 가지는 \(\theta\)를 찾는다. 수식으로 표현하면 다음과 같다.</p>


<p>\[\hat \theta = \arg\max_\theta f(\theta|X)\]</p>


<p>MLE와 비교해 MAP는 보다 더 자연스러운 결과를 얻게 된다. MLE로 parameter estimation을 하게 되면 오직 지금 주어진 데이터만을 잘 설명하는 parameter 값을 찾게 된다. 그러나 앞서 예를 든 것처럼 만약 스팸필터를 만드는데 연속으로 스팸이 아닌 메일이 \(n\)개가 들어왔다고해서 모든 메일이 스팸이 아니라고 할 수 있을까? 우리가 원하는 것은 지금까지 들어온 값에 대해서만 잘 설명하는 것이 아니라 보다 더 general한 무언가를 원한다. 여러 paramter들 중에서 데이터가 주어졌을 때 가장 확률이 높은 \(\theta\)를 고를 수 있다면 가장 좋은 결과를 얻을 수 있을 것이다.</p>


<p>하지만 안타깝게도 MAP를 계산하기 위해서는 \(f(\theta|X)\)가 필요하지만 우리가 관측할 수 있는 것은 오직 \(f(X|\theta)\)뿐이다. \(f(\theta|X)\)를 구하기 위해서는 Bayes&#8217; Theorem이라는 새로운 개념이 필요하다.</p>


<h5 id="58-1-Bayes">Bayes&#8217; Theorem</h5>


<p>Bayes&#8217; Theorem은 \(p(Y|X)\)와 \(p(X|Y)\)의 관계를 표현하는 식이다. 식의 꼴은 매우 간단하지만, 이 theorem은 많은 의미를 가지고 있다. Thoerem은 다음과 같다.</p>


<p>\[ p(Y|X) = {p(X|Y) p(Y) \over p(X)} \]</p>


<p>이때 \(f(X|\theta)\)를 likelihood, \(f(\theta)\)를 prior, 그리고 \(f(\theta|X)\)를 posterior라고 하며 각각은 observation(likelihood), 현상에 대한 사전정보 (prior), 주어진 데이터에 대한 현상의 확률 (posterior)을 의미한다.</p>


<p>이 식이 중요한 이유는 우리가 관측할 수 있는 데이터 이외에도 데이터에 대한 적절한 가정이 있다면 <a class="red tip" title="MLE">관측한 데이터만을 사용하는 것</a> 보다 <a class="red tip" title="MAP">더 우수한 parameter estimation</a>을 가능하게 하기 때문이다.</p>


<p>다시 MLE와 MAP로 돌아가보자. Bayes&#8217; Theorem을 사용하면 MAP와 MLE의 관계를 다음과 같이 적을 수 있다.</p>


<p>\[\hat \theta = \arg\max_\theta f(\theta|X) = \arg\max_\theta \frac{f(X|\theta) f(\theta)}{f(X)} = \arg\max_\theta \frac{\mathcal L (\theta;X) f(\theta)}{f(X)}\]</p>


<p>이때, \(f(X)\) term은 \(\theta\)에 영향을 받는 term이 아니기 때문에 다음과 같이 적을 수 있다.</p>


<p>\[\hat \theta = \arg\max_\theta \mathcal L (\theta;X) f(\theta)\]</p>


<p>따라서, 만약 \(f(\theta)\)를 알고 있다면, MLE가 아니라 MAP를 하는 것이 가능하다. 즉, \(\theta\)에 대한 assumption을 사용해 결과를 더 향상시킬 수 있는 것이다. 예를 들어 우리가 시험 성적의 gaussian distribution을 estimation하고 있다고 해보자. 이 경우 mean은 반드시 시험 점수 범위 안에 포함되어야하고, 그 값을 벗어날 수 없다. 그리고 이전 시험들의 성적을 살펴보면 그 값이 대체로 40~60 점 사이에 몰려있다는 등의 정보가 있다고 가정해보자. MLE로는 이런 정보를 활용하는 것이 불가능하지만, \(f(\theta)\)를 가정하고, 이를 사용해 MAP를 사용할 수 있게 된다. 즉, 만약 우리가 데이터에 대한 적절한 가정을 할 수 있다면 더 나은 추론을 하는 것이 가능한 것이다. 이를 prior라고 한다. 만약 우리가 옳은 prior를 선택하게 된다면 MLE보다 MAP가 좋겠지만, 잘못된 prior를 선택하게 된다면 오히려 성능이 떨어질 수도 있다. 쉽게 생각해 prior는 일종의 &#8216;선입견&#8217;이다. 선입견으로 사람을 판단할 때 더 빠르게 좋은 선택을 할 수도 있지만 (이 사람은 xx씨에게 추천을 받았으니 좋은 인재겠구나) 잘못된 선입견으로 인해 나쁜 선택을 할 수도 있다 (학교가 S대가 아니니 일을 잘 못하겠지). 따라서 MAP는 데이터에 대한 정보가 아무것도 없어도 되는 MLE와는 달리, 데이터에 대한 좋은 prior를 선택하는 것이 매우 중요하다고 할 수 있다. 참고로, prior가 uniform distribution이라면 MLE와 MAP는 정확하게 같은 문제를 푸는 것과 같다.</p>


<p>정리하자면, Bayes&#8217; Theorem은 더 좋은 가정이 있다면 더 좋은 유추를 할 수 있음을 보여주는 수식이다. 많은 Machine Learning Technique들이 Bayes Theorem에 근거하여 만들어졌으며, 데이터 관측과 데이터에 대한 가정을 통해 더 정확한 추론인 MAP를 가능하게 만들어주는 강력한 방법론이기도 하다.</p>


<h5>Advanced Topic: Conjugate Prior</h5>


<p>보통 prior는 <a href="http://en.wikipedia.org/wiki/Exponential_family">exponential family</a>에서 고르는 경우가 많다. Bernoulli, binomial, Poisson, Gaussian, Laplace, gamma, beta distribution 등등이 exponential family에 속한다. Exponential family를 많이 선택하는 이유는 대부분의 데이터들이 이 모양을 띄고 있기 때문이기도 하며, 만약 likelihood가 exponential family일 때, prior를 &#8216;좋은&#8217; exponential family로 선택하게 되면 posterior와 prior가 같은 family에 속하게 되기 때문이다. 예를 들어 likelihood가 Bernoulli라고 하면, prior를 beta distribution으로 선택하게 되면 posterior도 beta distribution이 되며 이를 <a href="http://en.wikipedia.org/wiki/Conjugate_prior">conjugate prior</a>라고 한다.</p>




<h5>변경 이력</h5>


<ul>
<li>2014년 8월 3일: 글 등록</li>
<li>2015년 2월 28일: 변경 이력 추가, 구성 변경 및 내용 revise</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine learning 스터디 (1) Machine Learning이란?]]></title>
    <link href="http://SanghyukChun.github.io/57/"/>
    <updated>2014-08-02T18:48:00+09:00</updated>
    <id>http://SanghyukChun.github.io/57</id>
		<content type="html"><![CDATA[<h5>들어가며</h5>


<p>Machine learning이라는 것을 접한지 어느새 거의 1년 반이 넘는 시간이 지났다. 많은 <a href="http://SanghyukChun.github.io/blog/categories/machine-learning/">Machine learning 관련 글들</a>을 써왔지만, 제대로 정리된 글이 없어 근래에 다시 머신러닝에 대해 공부를 하는 김에 제대로 정리해보기로 했다. 이번 8월부터 연구실에서 머신러닝 스터디를 하기로 한 김에 새로 다시 읽고 있는 Bishop 책을 중심으로 글을 작성할 것 같다. 나는 Machine Learning을 차근차근 공부하기에 적절한 자료가 없는 것이 항상 아쉬웠다. Lecture나 책이 있지만, 불필요하게 내용이 너무 많거나 처음 개념을 잡기에는 시간이 오래 걸리는 경우가 많았다. 또한 Machine Learning은 한글 자료도 많지 않다. 이 스터디에서는 최대한 내가 중요하다고 생각되는 기초적인 머신러닝 개념들에 대해 다룰 예정이다. 이 스터디 글은 머신러닝을 모르는 사람도 차근차근 순서대로 읽을 수 있도록 작성할 것이며 해당 주제를 이해하기 위해 필요한 &#8216;개념&#8217; 설명 등에 집중하려고 한다. 앞서 말한대로 주로 Bishop을 중심으로 작성하게 될 것 같으며, 필요하면 다른 책이나 논문을 참고해서 글을 작성해보려 한다. 이 스터디에 작성하는 모든 표현들은 가급적 원래 단어를 영어로 쓰거나 한글 독음을 사용하여 작성할 것이다. 즉, Machine Learning은 머신러닝이나 Machine Learning으로 표기될 것이며, 거의 모든 경우에 기계학습으로 표기되지 않을 것이다.</p>


<h5>What is Machine Learning?</h5>


<p>본격적으로 첫 번째 글을 시작하기 전에 재미있는 짤방을 하나 보고 가자. 여러 사람들이 생각하는 Machine Learning이란?</p>


<p><img src="http://SanghyukChun.github.io/images/post/57-1.jpg" width="600"></p>

<p>재미있지 않은가? Machine Learning은 &#8216;기계를 학습시킨다&#8217;라는 의미이므로 일반적인 사람들이 생각하기에 마치 기계들을 모아놓고 수업을 하는 것 같은 모습을 연상하기 쉽다. 반면 다른 공학이나 과학을 전공하는 사람들의 입장에서는 AI를 연상하기 쉬우며, 특히 Machine이라는 뉘앙스 때문에 조금 더 Hardware에 focus된 것처럼 느끼기도 한다. 부모님은 자식이 구체적으로 무엇을 하는지는 모르겠지만 맨날 컴퓨터하고 서버 얘기하니까 IDS에서의 저런 모습을 생각할 수 있을 것 같다 ㅎㅎㅎ. 다른 프로그래머들은 뭔가 일반적인 프로그래밍과는 다르게 수학적으로 엄청 어려운 무언가를 하는 것 처럼 보이고 이상한 식들 막 적어놓고 &#8216;뭐야 저거 무서워&#8217; 이런 느낌으로 바라보기 마련이다. 저 식은 아마도 error function과 관련된 식인 것 같다. 그리고 나는 내가 하는 일이 진짜 멋있는 일이라고 생각하지만 실제로 내가 하는건 남들이 만들어놓은 library를 import해서 사용하는게 전부라는 짤이다 ㅋㅋㅋ</p>


<p>이 하나의 짤방에서 참 많은 얘기들을 할 수 있을 것 같은데.. 일단 내가 앞으로 얘기할 Machine Learning이라는 것은 위의 그림에서 찾자면 what other programmers think I do와 흡사하다. 내가 대부분 알고리듬, 모델링 등 수학적인 것들에 관련된 부분을 다룰 것이기 때문이다. 자세한 얘기는 조금 더 뒤에서 하자.</p>


<h5 id="57-1-WhatMLE">What is Machine Learning? - Easy Answer</h5>


<p>자 그러면 본론으로 들어가서 Machine Learning은 과연 무엇일까. Machine Learning은 컴퓨터에게 사람이 직접 명시적으로 Logic을 지시하지 않아도 데이터를 통해 컴퓨터가 &#8216;학습&#8217;을 하고 그것을 사용해 컴퓨터가 자동으로 문제를 해결하도록하는 것을 의미한다. 예를 들어 스팸메일을 자동으로 걸러내는 스팸필터를 만든다고 생각해보자. 가장 간단하게 생각할 수 있는 방법은 블랙리스트를 쓰는 것이다. 사용자들이 스팸이라고 많이 보고된 나쁜 발신자들을 모아서 블랙리스트에 추가하는 것이다. 하지만 이런 블랙리스트는 보내는 사람을 바꾸기만하면 우회하여 스팸을 보내기가 너무나 간단하다. 따라서 보낸 사람이 아니라 메일의 제목 혹은 내용으로 필터링을 해야한다. 역시 가장 간단한 방법은 단어의 블랙리스트를 만드는 것이다. 예를 들어 &#8216;광고&#8217;, &#8216;싸게&#8217; 등의 단어들이 포함되면 해당 메일을 스팸으로 분류하는 것이다. 하지만 이 방법역시 우회하기 쉬울 뿐더러 (광.고. 라고 쓴다거나) 일상 생활에서도 쓰일 수 있는 표현이 있을 수 있기 때문에 멀쩡한 사람의 email을 spam이라고 인식하게 되는 끔찍한 일이 벌어질 수 있다. 이 문제를 Machine Learning으로 해결해보자. 그렇게 하면 컴퓨터에게 스팸인 email과 스팸이 아닌 email들을 주고, 스팸인 email들이 왜 스팸인지 &#8216;Learning&#8217;을 시켜서 &#8216;데이터를 통해 컴퓨터가 자동으로 판별을 해&#8217; 스팸을 걸러내는 방식을 취하게 할 수 있다. 이렇게 스팸 필터를 만들게 될 경우 데이터가 많아질수록 더 많은 것들을 &#8216;Learning&#8217;할 수 있으므로 스팸 필터의 performance역시 증가하게 될 것이다.</p>


<p>머신러닝은 이렇게 &#8216;기계&#8217;가 일일이 코드로 명시하지 않은 동작을 데이터로부터 &#8216;학습&#8217;하여 실행할 수 있도록 하는 &#8216;알고리즘&#8217;을 개발하는 연구 분야이다. (1959년 아서 사무엘)</p>


<h5 id="57-2-WhatMLD">What is Machine Learning? - Deep Answer</h5>


<p>조금 더 엄밀하게 Machine Learning을 정의해보자. Machine Learning problem은 아래 요소들로 구성이 된다.</p>


<ul>
<li>Experience E를 Learning할 Computer Program</li>
<li>각각의 E에 대응되는 class of task T</li>
<li>Task의 Performace Measure P</li>
</ul>


<p>위에서 기술한 세 가지 요소들로부터 Machine Learning problem을 다음과 같이 정의할 수 있다. &#8216;Experience \(E\)를 사용하여 (Learning하여) task \(T\)의 performance \(P\)가 개선이 되도록 하는 program (Algorithm)&#8217;. 다시 말해서 머신러닝 문제는 어떤 task \(T\)를 풀기 위한 알고리즘을 개발하는 분야인데 이 알고리즘의 performance measure가 &#8216;기계&#8217; 혹은 Compute program이 &#8216;Learning&#8217;할 수 있는 Experiment \(E\)를 사용해 개선될 수 있는 알고리즘을 개발하는 문제인 것이다. 스팸필터 문제로 돌아가보자. 스팸필터 문제에서 해결하고자 하는 Task는 새로운 메일을 받았을 때 해당 메일이 스팸메일인지 아니면 그렇지 않은지 판별하는 것이다. 따라서 algorithm의 performance measure \(P\)는 얼마나 정확하게 스팸을 골라냈는지 accuracy를 측정하면 간단하게 구할 수 있다. 또한 Experiment \(E\)는 예전에 받았던 이메일 들이 될 것이다. 또한 블랙리스트 등은 데이터가 많다고 해서 그 성능이 개선되는 것이 아니기 때문에 머신러닝이라고 할 수 없다. 우리가 하고 싶은 것은, 스팸인지 아닌지 판별하기 위해 예전 이메일들로 스팸 필터를 &#8216;학습&#8217; 시켜서 스팸 필터의 성능을 향상시키는 것이다.</p>


<p>Machine Learnig이 하는 일은 주어진 <a class="red tip" title="스팸필터일 경우: 과거 이메일">&#8216;데이터&#8217;</a> \(X = (x_1, x_2, x_3, \ldots, x_n)\)와 각 데이터에 대응하는 실제 <a class="red tip" title="스팸필터일 경우: 각 이메일이 스팸인지 아닌지 알려주는 binary variable">&#8216;현상&#8217;</a> \(Y = (y_1, y_2, \ldots, y_n) \)에 대한 <a class="red tip" title="스팸필터일 경우: 어떤 이메일이 스팸인지 아닌지 판별하는 것">&#8216;관계&#8217;</a> function \(f\)를 찾는 과정과 같다. 정확한 함수 \(f\)를 찾기 위해 Machine Learnig 알고리즘들은 데이터에 대한 가정을 하고, 그 가정에 따라 주어진 데이터를 &#8216;최대한 잘 설명할 수 있는&#8217;, 함수 \(f&#8217;\)을 찾는다. 이때 이런 \(f&#8217;\)을 Hypothesis라고 한다.</p>


<h5>Problem Setting</h5>


<p>Machine Learning 문제를 풀기 위해서는 다음과 같은 것들이 필요하다.</p>


<ul>
    <li>Set of possible instance(domain): X</li>
    <li>Output: Y</li>
    <li><p>Unknown target function \(f:X \to Y\)</p></li>
    <li><p>Set of hypothesis function space \(H \in \{h|h:X \to Y\}\)</p></li>
</ul>


<p>Input</p>


<ul><li><p>Traing example \(\{ \langle x_i, y_i \rangle &#92;}\)</p></li></ul>


<p>Output</p>


<ul><li><p>\(h\in H\) that best approximates target function f with some performance measure</p></li></ul>


<p>Problem Setting의 네 번째 요소인 set of function hypothesis space는 모든 function들을 확인하는 것은 불가능하기 때문에 찾고자하는 function들의 set으로만 한정을 짓기 위해 필요하다. 이런 problem setting이 완료되고 나면 learning을 하기 위한 input data가 필요한데 이를 training data라고 한다. training data는 \(\{ \langle x_i, y_i \rangle &#92;}\) 식으로 주어지는데, 만약 label \(y\)가 주어지는 경우는 supervised learning, 주어지지 않는 경우는 unsupervised learning이라고 한다. 마지막으로 Machine Learning Algorithm의 output으로 \(h\in H\) 인 h 중에서 target function f와 가장 유사한 hypothesis를 return하게 된다.</p>


<p>위에서 설명한 얘기를 그림으로 설명하면 아래와 같은 그림을 그릴 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/57-2.png" width="600"></p>

<p>다시 한 번 스팸필터를 생각해보자. 데이터 X는 메일들이다. 우리가 받는 메일 하나하나가 데이터가 될 수도 있고, 그 메일 안에 있는 단어 하나하나가 될 수도, 혹은 아예 알파벳 하나하나가 될 수도 있다. 그것은 우리가 정하기 나름이니까. 현상 Y는 각각의 메일이 스팸인지, 아니면 일반 메일인지 구분하는 구분자, indicator, 혹은 Label, Class가 될 것이다. 마지막으로 데이터에 대한 가정을 통해 Hypothesis function space를 결정하고 그 function을 찾는 알고리즘을 적용하는 것이다.</p>


<h5 id="57-3-WhyML">Why Machine Learning?</h5>


<p>Machine Learning은 왜 사용하는 것일까? 만약 우리가 찾고자하는 것이 아주 간단한 함수이고, 머신러닝 기법을 사용하지 않고도 찾을 수 있다면 머신러닝을 꼭 사용할 필요는 없을 것이다. 그러나 만약 찾고자하는 함수가 매우 복잡하고 어렵다면 머신러닝은 아주 유용하게 쓰일 수 있다. 머신러닝 문제는 결국 어떤 상황을 해결하기 위한 문제를 세우고 그 문제를 풀기 위한 모델을 만들기 위해 데이터에 대한 가설을 세우고, 그 가설에 부합하는 알고리즘을 개발하는 과정이다. 따라서 우리가 명시적으로 문제 해결하는 방법을 결정하는 것이 아니라, 그 대신 문제를 해결하는 방법을 알려주고, 문제는 컴퓨터가 풀도록 할 수 있다. 머신러닝을 사용해 아주 많은 문제들을 풀 수 있다. 계속 예시로 든 스팸필터도 있고, 쇼핑 이력을 보고 고객이 어떤 물건을 더 사고 싶어할지 추천하거나 광고를 할 수도 있다. 날씨와 고속도로의 교통상황의 상관관계를 찾을 수도 있다. 즉, Machine Learning Problem의 형태에 맞게 문제를 만들고, 그 문제를 풀기 위한 데이터와 데이터에 대한 가설만 있다면 그 어떤 문제도 해결할 수 있는 것이다.</p>


<p>또한 최근 들어서 Machine Learning이 급부상하고 있는 가장 큰 이유 중 하나는 &#8216;빅데이터&#8217;이다. 과거와는 비교할 수 없을 정도로 데이터가 많아졌는데, 그 데이터에서 사람이 &#8216;의미&#8217;를 일일이 뽑아내기 너무 어렵기 때문이다. 이에 사람이 데이터를 분석하기보다는 기계에게 데이터를 학습시켜 알아서 문제를 판단하게 할 수 있으면 좋겠다라는 needs가 발생하였고, 이에 사람들이 Machine Learning을 많이 요구하게 되었다. 또한 Machine Learning Algorithm은 input data가 많으면 많을수록 성능이 좋아진다. 요즘같은 &#8216;빅데이터&#8217;가 부상하는 시기에 이만큼 적절한 기술도 찾기 힘들 것이다.</p>


<h5 id="57-4-ClassML">Class of Machine Learning</h5>


<p>Machine Learning은 정말 많은 분야를 포함하는 정말 큰 연구 분야이다. 하지만 그럼에도 일반적으로 Machine Learning은 Supervised Learning, Unsupervised Learning, Reinforcement Learning 세 가지로 분류할 수 있다. 앞서 설명한 것처럼 Supervised Learning, Unsupervised Learning의 차이점은 training data에 label이 있느냐 없느냐의 차이이다. Reinforcement Learning은 앞에서 다룬 두 문제와는 다소 다르다. 조금 복잡하기 때문에 이 스터디의 맨 마지막에 간단하게 다루도록 하겠다.</p>


<h5>변경 이력</h5>


<ul>
<li>2014년 8월 2일: 글 등록</li>
<li>2014년 8월 19일: 오탈자 수정, 예시 추가</li>
<li>2014년 10월 4일: 글 구성 변경. 그림 등 추가</li>
<li>2015년 2월 28일: 변경 이력 추가 및 내용 revise</li>
</ul>


<hr>


<p><a href="http://SanghyukChun.github.io/blog/categories/machine-learning-study/">Machine Learning 스터디</a>의 다른 글들</p>


<ul>
<li><a href="http://SanghyukChun.github.io/57">Machine Learning이란?</a></li>
<li><a href="http://SanghyukChun.github.io/58">Probability Theory</a></li>
<li><a href="http://SanghyukChun.github.io/59">Overfitting</a></li>
<li><a href="http://SanghyukChun.github.io/60">Algorithm</a></li>
<li><a href="http://SanghyukChun.github.io/61">Decision Theory</a></li>
<li><a href="http://SanghyukChun.github.io/62">Information Theory</a></li>
<li><a href="http://SanghyukChun.github.io/63">Convex Optimzation</a></li>
<li><a href="http://SanghyukChun.github.io/64">Classification Introduction (Decision Tree, Naïve Bayes, KNN)</a></li>
<li>Regression and Logistic Regression</li>
<li>PAC Learning &amp; Statistical Learning Theory</li>
<li>Support Vector Machine</li>
<li>Ensemble Learning (Random Forest, Ada Boost)</li>
<li>Graphical Model</li>
<li><a href="http://SanghyukChun.github.io/69">Clustering (K-means, Gaussian Mixture Model)</a></li>
<li><a href="http://SanghyukChun.github.io/70">EM algorithm</a></li>
<li>Hidden Markov Model</li>
<li>Dimensionality Reduction (LDA, PCA)</li>
<li>Recommendation System (Matrix Completion, Collaborative Filtering)</li>
<li>Neural Network Introduction</li>
<li>Deep Learning</li>
<li>Reinforcement Learning</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014 ICML 후기]]></title>
    <link href="http://SanghyukChun.github.io/55/"/>
    <updated>2014-06-26T16:16:00+09:00</updated>
    <id>http://SanghyukChun.github.io/55</id>
		<content type="html"><![CDATA[<p>이번에 <a href="icml.cc/2014/">ICML 2014</a>를 다녀왔다. 내 첫 해외 학회이기도 했고, 처음으로 Machine Learning과 관련된 연구를 하는 사람들의 talk을 듣고, 그 사람들이 직접 하는 일들을 많이 볼 수 있어서 개인적으로 많이 고무된 상태로 학회에 참여했었다. 첫 학회를 다녀온 기념으로 학회에서 내가 느낀 점들을 간단하게 정리해보고자 한다. 대충 보자면 아래 리스트 정도가 될 것 같다.</p>


<ul>
<li>항상 열정을 가지고 있고 열심인 사람들</li>
<li>어떤 식으로 연구를 해야겠다라는 생각</li>
<li>Machine Learning이라는 학문의 방대함</li>
<li>Neural Network와 Deep Learnig의 강세</li>
<li>Real Industry와 Machine Learning</li>
</ul>


<p>먼저 사람들. 개인적으로 내 자신에게 살짝 아쉬운 점이라면 학회에서 만난 사람들에게 먼저 다가가서 이야기를 걸거나 할 베짱이 많이 없었다는 것이다. 사실 내가 그렇게 사람들에게 먼저 다가가고 얘기를 나누기에는 내가 알고 있는 지식이 많이 부족함에도 원인이 있기는 하지만 그래도 다들 같은 분야에 관심을 가지고 (세부 관심사는 조금씩 다를 수 있지만) 나와 비슷한 입장을 가진 사람들도 있을 수 있었을텐데 내가 조금 적극적이지 못했던 부분이 있다. 학기 중에 윤준보교수님 수업에서 학회를 가면 그 사람들과 이야기를 많이 나누어보라는 얘기를 해주셨는데 막상 내게 그런 기회가 생기니 할 수 있는 말이 많이 없더라. 조금 더 정진해서 그런 대화에 두려움이 없을 정도의 지식을 쌓아야할텐데. 그런 개인적인 아쉬움은 잠시 넘겨서 생각을 해보자면, ICML에서 만난 사람들은 정말 열정있는 사람들이었다. 고작 15분에서 20분짜리 talk조차 이해하지 못하고 허덕이고 있는 나와는 다르게, 정말 발표자의 talk을 이해하고 그들과 communication하면서 질문하는 모습이 멋져보였다. 1시간 가까이 되는 invited talk이나 key note talk에서도 많은 부분을 놓치지 않으려 노력하는 모습도 멋졌다고 생각한다. 나도 그런 멋지다고 생각한 모습에 한 단계 더 다가가야할텐데.</p>


<p>그리고 그 다음은 역시 연구였다. 내가 대학원생이 되었고, 연구가 나에게 가장 중요한 비중을 차지하게 된 이상, 어떤 연구를 할 것이며 어떻게 연구를 할 것이며.. 혹은 왜 연구를 해야하는 것이냐 등의 물음은 나에게 굉장히 중요한 물음이다. 약간 어느 정도는 간접적으로 그 질문들에 대한 답을 얻을 수 있었던 것 같은데, 어떤 공명감으로 연구를 한다는 느낌보다는 이 문제를 풀어야하겠다는 그런 근본적인 호기심? 같은게 영향을 미치는게 아닌가 싶다. 사실 명확하게 이거다! 싶은 느낌은 잘 들지 않았지만 앞서 말했듯이 다들 열정적으로 임하고 질문 하나하나가 날카롭게 들어가는 모습을 보면서 이런 학회에 publish를 하는 사람들은 어떤 생각으로 다른 사람들의 talk을 듣는지 조금이나마 간접적으로라도 체험할 수 있지 않았나 싶다. 아무튼 진짜 열정적으로 해야한다. 그게 진짜 큰 것 같다.</p>


<p>또 학회에서 놀라웠던 점이라면 Machine Learning이라는 분야 자체가 생각보다도 훨씬 더 방대했다는 점이다. 전체 Track이 6개가 parallel 하게 돌아가면서 전체 다 합쳐서 거의 300개 가까이 되는 talk이 진행이 됐으니까.. (<a href="http://icml.cc/2014/index/article/12.htm">스케쥴</a>) 단순히 accept된 paper만 많은 것이 아니라 각 track의 주제 또한 너무나도 다양하였다. Networks and Graph-Based Learning, Reinforcement Learning, Bayesian Optimization and Gaussian Processes, Supervised Learning, Neural Networks and Deep Learning, Graphical Models, Bandits, Monte Carlo, Statistical Methods, Structured Prediction, Deep Learning and Vision, Matrix Completion and Graphs, Learning Theory, Clustering and Nonparametrics, Active Learning, Optimization, Large-Scale Learning, Latent Variable Models, Online Learning and Planning, Clustering, Metric Learning and Feature Selection, Optimization, Neural Language and Speech, Graphical Models and Approximate Inference, Online Learning, Monte Carlo and Approximate Inference, Method-Of-Moments and Spectral Methods, Boosting and Ensemble Methods, Matrix Factorization, Nonparametric Bayes, Manifolds, Kernel Methods, Unsupervised Learning and Detection, Crowd-Sourcing, Manifolds and Graphs, Regularization and Lasso, Nearest-Neighbors and Large-Scale Learning, Topic Models, Sparsity, Neural Theory and Spectral Methods, Features and Feature Selection, Time Series and Sequences&#8230;. 와 진짜 많다. 물론 이 전체를 또 잘 묶으면 더 줄어들 수 있겠지만 그래도 일단 각각의 Track들이 서로 다른 주제를 가지고 이렇게 많이 있다는 사실이 놀라웠다. 글쎄, 그래도 굳이 크게 나누자면, (1) Learning for Graphical Model (2) Traditional Machine Learning Problems (Bayesian, Supervised Learning&#8230;), (3) Optimization (4) Monte Carlo (5) Unsupervised Learning (Clustering, Metric Learning&#8230;) (6) Neural Network (7) Others 정도가 아닐까. 모르겠다 너무 많고 내가 모르는 분야가 너무 많아서. 아무튼 정말 Machine Learning이 어마어마하게 큰 분야라는 것을 다시 한 번 느끼게 되었다. 나는 저 많은 Track 중에서 어느 분야에 기여를 할 수 있을까?</p>


<p>꼭 그런건 아니었지만, 전반적으로 Deep learning 과 관련된 talk들. 심지어 &#8216;Deep&#8217; 이라는 이름이 들어가기만 해도 컨퍼런스 룸이 터질듯한 것을 볼 수 있었다. 정말 요즘 이게 핫하긴 핫하다. 근데 난 이상하게 정말 Deep learning이 싫은데.. 이유를 잘 모르겠다. 가장 practical하게 powerful해서 그렇겠지? 중국에서 해서 그런지는 모르겠지만 Deep learning세션은 중국인들이 바글바글 몰려서 진짜 산만했었다. 그만큼 가장 핫하다는 뜻이고, 중국인들이 이런 실용적인 것들에 무지 관심이 많다는 것을 느꼈다. 이론쪽보다는 확실히 그런 practical 한 세션에 중국인들이 압도적으로 많았다. Deep learning 관련 시스템 쪽도 사람 엄청 많았고.. 진짜 그야말로 Deep Learning의 시대라고 봐도 무방할 정도. 대단하더라.</p>


<p>마찬가지 맥락에서, 굉장히 많은 기업들이 ICML을 찾았다. 구글, Facebook, 아마존, MS, 야후 같은 글로벌 기업은 물론이고 바이두, 알리바바 같은 중국 기업들도 엄청 많았다. 그만큼 머신러닝을 전공한 사람들의 힘이 필요하다는, 그런 사람들에 대한 수요가 확실하구나.. 라는 그런 생각이 들더라. 기업 연구소 특히 MS나 구글 연구소 등에서도 많은 논문들이 나오는걸 보고, 저런 연구소에서 일하는 것도 생각보다는 나쁘지 않을 수도 있다는 그런 생각도 들고 그랬다.</p>


<p>ICML에서 여러모로 많은 자극을 받았다. 재미도 있었고. 내년 ICML은 내가 intivation 되서 갔으면 좋겠다! 나도 좋은 논문을 쓸 수 있었으면.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Science - Scale Free Network (Barabasi-Albert Network)]]></title>
    <link href="http://SanghyukChun.github.io/52/"/>
    <updated>2014-04-23T15:33:00+09:00</updated>
    <id>http://SanghyukChun.github.io/52</id>
		<content type="html"><![CDATA[<h5 id="52-1-before">들어가기 전에</h5>


<p>이 글은 <a href="http://SanghyukChun.github.io/47">2014년 KAIST Network Science 수업</a> 중 Scale Free Network 내용을 요약한 글이다. 이 렉쳐에서는 Scale Free Network라는 concept에 대해 다루게 된다.</p>


<h5 id="52-2-scalefreenetwork">Scale Free Network</h5>


<p>이전 글들에서 <a class="red tip" title="따로 글로 정리를 하지는 않았지만, Watts-Strogatz를 설명하면서 다뤘던 부분이다.">Regular Network</a>, <a href="http://SanghyukChun.github.io/50">Random Network</a>와 <a href="http://SanghyukChun.github.io/51">Small world Network</a>에 대해 다뤘던 것들 중 Path length, Clustering coefficient, 그리고 Degree distribution 부분을 정리해보자.</p>


<p>먼저 Path length이다. 우리가 관측하는 대부분의 network들은 Path length가 그 크기의 logarithm function으로 표현된다는 것을 알 수 있다. 조금 더 구체적으로 표현하자면 \(l_{rand} \approx {\log N \over \log \bar k}\)로 표현이 된다. 먼저 Regular Network의 path length는 \(l \approx N^{1/D}\)로 표현이 된다. 우리가 원하는 log 와는 다른 형태임을 알 수 있다. 그렇다면 Random Network와 Small world Network는 어떨까? 이전 결과들을 통해 확인할 수 있듯 \(l_{rand} \approx {\log N \over \log \bar k}\)로 표현이 된다는 사실을 알 수 있다. 즉, Erdös-Rényi Network와 Watts-Strogatz Network는 일반적으로 우리가 관측하는 네트워크와 비슷한 Path length를 지니고 있고 Regular Network는 그렇지 않음을 알 수 있다.</p>


<p>Clustering coefficient는 어떠한가? 대부분의 실제 네트워크의 clustering coefficient는 그 크기에 무관하게 항상 상수로 표현된다. 즉, \(C \sim const \)로 표현이 된다. Regular network와 small world network가 이 값이 상수임에 반해, Random network는 이 값이 \(C = p = {\bar k \over N}\)으로 표현이 된다. 즉, 크기가 커질수록 이 값이 감소하는 경향을 보이는데 이 부분은 실제 네트워크와 큰 차이가 있는 부분이다. 즉, Random network는 실제 네트워크보다 뭉침 현상이 덜 하고, Regular Network와 Small world network는 실제 네트워크와 그 뭉침 정도가 비슷하다는 것을 알 수 있다.</p>


<p>그렇다면 지금까지의 결론을 보면 Small world Network만 Path lenth, 그리고 Clustering의 두 가지 측면에서 실제 네트워크와 유사함을 알 수 있다. 그렇다면 마지막 Degree distribution은 어떠한가? 실제 네트워크에서 나타나는 degree distribution은 power law distribution으로 표현이 된다. 즉, \(P(k) \sim k^{-\gamma}\)로 표현이 된다. 그런데 Regular Network의 degree distribution은 \(P(k) = \delta (k-k_d)\)이며 Random Network는 \(P(k) = e^{-\bar k} {\bar k ^k \over k!}\)로 표현이 된다. 그리고 Small world network의 degree 역시 exponential function으로 표현이 된다. 즉, 지금까지 우리가 살펴본 그 어떤 네트워크도 실제 네트워크와 유사한 degree distribution을 보이지 않음을 알 수 있다.</p>


<p>이러한 문제점, 즉, degree distribution이 잘 맞지않는다는 문제점으로 인하여 새로운 Scale-Free network라는 개념이 등장하게 된다. Scale-Free network란 degree를 \(k\)라 했을 때 degree sequence \(g&#8217;\)이 power-law function \(h(k) \sim k^{-q}\)로 표현이 되는 네트워크를 의미한다. 이 때 exponent \(q\)의 값은 보통 2에서 3 사이로 결정이 된다. 수학적이지 않은 관점에서 바라본다면 scale-free network는 적은 숫자의 high degree node가 있고 그 이외의 많은 node들은 엄청 작은 degree를 가지는 네트워크를 의미한다. 그리고 이런 degree가 높은 node를 일컬어 hub라고 부르게 되며, 다시 말하자면 Scale-Free Network란 hub가 존재하는 네트워크를 의미하게 된다. 이 현상은 사실 생각해보면 우리 주변에도 많이 발생하는데, <a class="red tip" title="영어 단어의 분포는 그 단어의 빈도의 순위의 역수로 표현된다. 즉, 상위 일부가 전체 대다수를 차지한다.">Zipf의 법칙</a>나 <a class="red tip" title="상위 20%가 80%의 부를 가져간다는 법칙. 보통 2:8의 법칙으로 불린다">Pareto의 법칙</a> 등의 관측도 존재하고, 실제 social network에서도 친구가 엄청나게 많은 일부의 사람들이 존재하고 나머지 사람들은 그보다는 적은 사람의 친구를 가지는 등, 이미 hub라는 현상은 우리가 자연스럽게 받아들일 수 있는 개념이라는 것이다.</p>


<p>그렇다면 degree가 exponential인 것과 power-law인 것이 정말 크게 차이가 날까? 만약 그게 아니라면 우리는 충분히 Watts-Strogatz의 결과물을 사용할 수 있을 것이다. 아래 그 둘을 비교한 그림이 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/52-1.png" width="400"></p>

<p>이 그림을 통해 알 수 있듯, exponential과 power-law는 그 기울기의 감소 정도가 매우 많이 차이가 난다는 것을 알 수 있고, 우리는 degree distribution이 power-law를 가지는 새로운 network가 필요하다는 것을 알 수 있다. 이런 Scale-Free Network는 1999년 Alber, <a class="red tip" title="KAIST 물리과 정하웅 교수님">Jeong</a>, Barabasi에 의해서 처음 연구가 되었으며, 이런 네트워크를 만드는 과정을 Barabasi-Albert Procedure라고 부른다. 그렇다면 Scale-Free라는 이름은 왜 생긴 것일까? Small-world라는 말이 diameter의 증가 정도가 네트워크의 증가 속도보다 훨씬 느리기 때문에 붙은 알이라면, Scale-Free는 degree가 증가하는 정도와 실제 distribution이 같은 속도로 증가함을 의미한다. 수식으로 나타내자면 \(h( \alpha k = \beta h(k)\)로 표현이 된다. 즉, x-axis로 factor \(\alpha\) 만큼 scaling을 한 결과는 y-axis에 factor \(\beta\) 만큼 scaling을 한 것과 같다는 것이다. 따라서 이 power-law curve를 factor \(\alpha\)로 scaling을 하더라도 그 모양은 단순히 위아래로 움직이기만하는 형태로 표현이 된다는 것이다. 즉, 그 우리가 Scaling을 하더라도 그 형태가 변하지 않는 Scale-Free한 Network라는 것이다.</p>




<h5 id="conclusion">Conclusion</h5>


<p>Scale-Free Network를 한 번 정리하고 넘어가보자. 먼저 Scale-Free란 degree distribution이 power-law로 표현되는 network이며, 토폴로지 관점에서 봤을 때 Small-world와 Random network 사이 쯤에 존재하는 네트워크이다. 아래 그림을 보면 엔트로피와 Clustering Coefficient, Average path length, hub degree를 모두 비교해본 결과인데 이 결과를 보면 다른 네트워크와 비교했을 때 다른 값들은 대체로 높지만 상대적으로 뭉침 정도가 약함을 알 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/52-10.png" width="500"></p>

<p>Scale-free network의 entropy는 \(I(G) \sim O( \log_2 ( \Delta m) = O( \log_2 (density(n/2)))\)임을 알 수 있다. 이는 small-world network의 \(I(G) \sim O( \log_2 p )\)와 비슷한 결과이며, 따라서 엔트로피의 관점에서 봤을 때 random network보다는 small-world network에 가까움을 알 수 있다.</p>


<p>Path length는 fixed n에 대해 \(l = A - B k_{hub} \sim O({ \log (n) \over \log (n) + \log (density)}) \)으로 표현이 된다. 그리고 cost-effectiveness라는 것도 정의가 되는데, \(E = {1-\bar {l(density)} \over m}\)으로 표현이 되며 Density는 \(2 \frac {m} {n(n-1)}\)으로 표현이 된다. ========</p>


<p></p>




<h5>KAIST Network Science</h5>


<p>다른 요약글들 보기 (<a href="http://SanghyukChun.github.io/blog/categories/network-science/">카테고리로 이동</a>)</p>


<ul>
    <li>Lecture 1: <a href="http://SanghyukChun.github.io/47">Introduction</a></li>
    <li>Lecture 2: <a href="http://SanghyukChun.github.io/48">Graph Theory</a></li>
    <li>Lecture 3: <a href="http://SanghyukChun.github.io/49">Measures and Metric</a></li>
    <li>Lecture 4: <a href="http://SanghyukChun.github.io/50">Random Network</a></li>
    <li>Lecture 5: <a href="http://SanghyukChun.github.io/51">Small world Network</a></li>
    <li>Lecture 6: <a href="http://SanghyukChun.github.io/52">Scale free Network</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Science - Small World Network (Watts-Strogztz Network)]]></title>
    <link href="http://SanghyukChun.github.io/51/"/>
    <updated>2014-04-23T13:06:00+09:00</updated>
    <id>http://SanghyukChun.github.io/51</id>
		<content type="html"><![CDATA[<h5 id="51-1-before">들어가기 전에</h5>


<p>이 글은 <a href="http://SanghyukChun.github.io/47">2014년 KAIST Network Science 수업</a> 중 Small World Network 내용을 요약한 글이다. 이 렉쳐에서는 Small World Network라는 concept과 실제 그런 컨셉을 적용한 Network model 중 하나인 Watts-Strogztz Network에 대해 다루게 된다.</p>


<h5 id="51-2-problemofrandomnetwork">Prolem of Random Network</h5>


<p><a href="http://SanghyukChun.github.io/50#50-10-problems">이전 글</a>에서 다뤘 듯, Random Network는 실제 Network와 맞지 않는 부분이 많이 존재한다. 가장 큰 문제는 degree distribution과 clustering coefficient가 실제 network 분포와 크게 반하다는 점이다. 따라서 이 글에서는 그런 점들을 개선시킨 새로운 컨셉의 네트워크 모델링에 대해서 다루게 될 것이다. 사실 이 Small world network라는 것이 맨 처음 1998년도 논문으로 발표가 되었을 때 그 기반이 되는 Network가 <a href="http://en.wikipedia.org/wiki/Regular_graph">Regular Network</a>이기 때문에 이런 Regular Network에 대해서도 다룬 이후에 Small World Network를 다루는 것이 맞다고 생각하지만, 실제 강의 내용에서 Regular Network 생략되었기 때문에 나 역시 이 글에서 Regular Network에 대해서는 많이 다루지 않을 생각이다. 참고로 Regular Network는 모든 vertex가 같은 degree를 가지는 Network를 의미하며 k-regular network라고 하면 모든 vertex의 mean degree가 \(k\)라는 의미이다. 그런데 이 lecture에서는 local degree의 값이 \(k\)가 아니라 \(2k\)이며 \(k= {m \over n}\)으로 정의한다. 엄청나게 헷갈리기는 하지만.. 일단 lecture의 notation을 따르도록 하겠다. 즉, 2-regular network는 local degree가 4이며 즉, 각 vertex는 4개의 edge를 가진다. 실제 이 chapter 자체가 2-regular network를 small world network로 바꾸는 Watts-Strogztz Network에 대한 내용이므로 이 점을 꼭 숙지하고 넘어가야한다.</p>


<h5 id="51-3-smallworldnetwork">Small World Network</h5>


<p>Small world network란 예전 <a href="http://SanghyukChun.github.io/34#34-2-smallworld">인터넷 속의 수학</a>에서도 간략하게 다뤘던 내용이므로 예전 글을 참고해도 좋을 것 같다. Small World Network란 높은 clustering coefficient를 가지고 있고, 상대적으로 짧은 diameter를 가지고 있으며 entropy가 scalable한 sparse network를 의미한다. 여기에서 여러 가지 용어들이 나오는데, clustering coefficient는 넘어가도 되고, diameter는 network에서 가장 긴 shortest path, 그리고 entrophy는 이 graph를 나타내기 위한 information의 양을 의미한다. 마지막으로 sparse network라는 것은 모든 vertex pair사이에 edge가 존재하는 것이 아니라 edge가 존재하지 않는 vertex pair가 존재한다는 의미이다. Small world network는 regular network와 random network의 중간 정도 쯤 되는 network인데, 역시 이것도 <a href="http://SanghyukChun.github.io/34#34-3-poissonregularnetwork">이전 글</a>에서 다뤘던 내용이므로 관심이 있다면 간략하게 읽어보기를 권한다. 간단하게 설명하면 Samll world network는 regular network에 적당한 randomness를 추가하여 얻을 수 있기 때문에 이 두 개의 네트워크의 중간 정도라고 표현하는 것이다.</p>


<p>사실 이 Small world라는 단어는 Stanley Milgram의 6 degree 실험에서 처음 등장한 것인데, 이 실험에 대한 자세한 설명은 <a href="http://SanghyukChun.github.io/32#32-3-milgramexp">이전에 적은 글</a>을 참고하기를 바란다. 이 실험의 결론만 얘기하자면 실제 social 네트워크에서는 임의의 vertex pair를 선택했을 때 그 둘 사이를 지르는 가장 짧은 path의 길이가 network의 크기에 비해서 엄청나게 짧다는 것이다. 이 실험에서는 실제 미국 내의 네트워크에서 6개의 step이면 상대방에게 도달할 수 있다는 것을 알 수 있었다. (심지어 shortest path도 아니고 greedy search 였음에도 불구하고) 이 글에서 설명하게 될 Small world network 역시 상대적으로 짧은 diameter를 가지게 되고, clustering coefficient와 closeness centrality도 높다.</p>


<h5 id="51-4-wattsstrogatz">Watts-Strogatz Procedure</h5>


<p>그러면 이제 small world network를 generate하는 방법에 대해 생각해보자. 이 과정을 Watts-Strogatz Procedure라고 부른다. 이 algorithm은 k-regular network를 small world network로 만드는 알고리듬인데, 주어진 k-regular network의 임의의 \(pm\) 개의 edge를 random하게 rewire를 시킴으로써 얻을 수 있다. 즉, 내가 임의로 regualr network에서 p의 확률로 하나의 edge를 random 한 edge로 바꿔주는 과정을 계속 반복하기만 하면 된다. 이런 과정을 통해 우리는 regular network에 강제적으로 randomness를 주입할 수 있게 되며, \(p\)가 약 1~4% 정도가 되면 small-world effect가 나타난다고 한다. 이 \(p\)의 값 0.01 ~ 0.04를 transition threshold 혹은 crossover point라고 한다.</p>


<p>놀라운 사실은, 이렇게 간단한 algorithm을 적용하기만 해도 degree sequence distribution, diameter, average path length 등의 정보가 크게 달라지게 된다. 특히 diameter와 average path length는 아주 조금의 randomness만 주입하게 되어도 그 값이 크게 감소하게 되는데, 이런 극적인 거리 감소 현상을 곧 small-world effect라고 하는 것이다.</p>


<p>이런 과정을 통해 얻어지는 Small world network는 아래 그림과 같다. 이 그림은 vertex가 20개 있는 2-regular network를 WS procedure를 사용해 reconstruct한 것으로, p의 값이 점점 올라가면서 그 모양이 바뀌는 모습을 관측한 것이다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/51-1.png" width="600"></p>

<p>자 그런데 지금까지 설명한 방법은 완전히 random procedure이기 때문에 connected graph를 보장할 수 없다. 어떻게 이것을 개선시킬 수 있을까? 간단하게 생각할 수 있는 방법으로는 만약 선택한 edge를 제거했을 때 isolated vertex가 생기는 경우 해당 edge를 바꾸지 않도록 하는 방법이 있을 수 있을 것이다. 2000년도 뉴먼이 제시한 NSWS model에서는 이런 문제를 해결한 새로운 알고리듬을 제시했다고 하는데 <a href="http://arxiv.org/pdf/cond-mat/0001118.pdf">논문</a>은 찾은 것 같은데 자세히 읽어보지는 못했다.</p>


<h5 id="51-5-degreedist">Degree Sequence Distribution</h5>


<p>Degree Sequence는 Graph \(G\)의 모든 \(n\) vertex들의 degree value 들의 sequence이며 \(g=[d_1, d_2, d_3, &#8230;, d_n ]\) 과 같이 표현된다. 그리고 이것의 distribution, 즉, degree가 1인 node 들의 비율, 2인 node들의 비율.. 등등을 표현하는 distribution은 \(g&#8217; = [h_1, h_2, h_3, &#8230; h_{max_d}]\) 라고 표현할 수 있다.</p>


<p>맨 처음 k-regular network의 모든 vertex들이 가지는 edge의 개수는 \(2k\)이다. 그런데 \(p\)의 확률로 edge가 변경되더라도 결국 평균 edge의 개수, 혹은 connectivity는 \(c=2k\)로 고정될 것이라는 사실을 알 수 있다. 자 이제 \(P_p (c)\)를 degree의 probability distribution이라고 해보자. vertex들의 2k connection 중 k개의 connection은 아직 still untouched 일 것이므로, 이런 상황에서 vertex i의 connectivity는 \(c_i = k+n_i \ n_i \geq 0 \)라는 것을 알 수 있다. 이제 \(n_i \)라는 것도 두 가지 부분으로 나눠 생각할 수 있는데, 먼저 \(n_i^1 \leq k \) 은 \(1-p\)의 확률로 rewire되지 않는 link e들의 개수이고, \(n_i^2 = n_i - n_i^1\) 은 그 반대로 vertex \(i\)에 reconnected된 edge들을 의미한다. 그리고 총 \(N\)개의 vertex가 있다고 했을 때, 임의의 edge가 vertex \(i\)로 rewire될 확률은 \(p \over N \)라는 것도 알 수 있다.</p>


<p>그렇다면 우리는 이 사실을 통해 small world network의 degree sequence distribution을 다음과 같은 과정을 통해 얻을 수 있게 된다.</p>


<p>$$ P_1 (n_i^1) = {k \choose n_i^1} (1-p)^{n_i^1} p^{k-n_i^1} $$</p>


<p>$$ P_2 (n_i^2) = {(kp)^{n_i^2} \over n_i^2 !} e^{-pk} \ for \ large \ N $$</p>


<p>$$ P_p (c) = \sum_{n=0}^{min(c-k, k)} {k \choose n} (1-p)^n p^{k-n} {(kp)^{c-k-n} \over (c-k-n)!} e^{-pk} \ c \geq k $$</p>


<p>아래 그림은 degree sequence distribution \(P_p (c)\)를 connectivity \(c=2k\)에 대해 표현한 것이다.</p>


<p>  <br/>
<img src="http://SanghyukChun.github.io/images/post/51-2.png" width="600"></p>

<p>이 그림을 통해 우리는 degree sequence distribution이 평균값이 \(\bar c = 2k\)인 Poisson 분포임을 알 수 있다.</p>


<p>이번에는 random network와 실제 network data, 그리고 앞서 서명한 과정을 사용해 만들어낸 network의 degree distribution을 비교한 그림을 살펴보자</p>


<p><img src="http://SanghyukChun.github.io/images/post/51-3.png" width="600"></p>

<p>이 그림을 통해 우리는 random network보다 small world network가 더 실제 네트워크와 더 비슷하다는 것을 알 수 있다.</p>


<h5 id="51-6-entropy">Entropy</h5>


<p>앞서 정의했었던 Degree sequence distribution을 사용하면 Graph의 entropy \(I(G)\)를 정의할 수 있는데 이 값은 곧 네트워크를 표현 하기 위한 information의 양을 의미한다. 당연히 Regular Network는 Entropy가 낮고 Random Network는 Entropy가 높다. 다시 말해서 Graph \(G\)의 Entropy는 그 graph의 randomness를 bit로 표현한 값이 되며, 이 randomness는 다시 말해서 degree sequence \(g&#8217;\)으로 다음과 같이 나타낼 수 있다.</p>


<p>$$ I(G) = - \sum_{i=1}^{max_d} h_i (\log_2 h_i), \ where \ g&#8217; = [h_1, h_2, h_3, &#8230; h_{max_d}] $$</p>


<p>이 값을 확률 2-regular network를 \(p\)의 확률로 edge를 rewire하는 경우에 대해 ploting을 해보면 다음과 같은 결과를 얻을 수 있다.</p>


<p><img src="http://SanghyukChun.github.io/images/post/51-4.png" width="600"></p>

<p>즉, 엔트로피는 확률 \(p\)의 log scale로 증가하게 된다. 또한 entropy의 정의에 따라 이 값은 \(I_{WS} = -\sum_k h(d) \log_2 h(k) \)로도 표현이 된다. 이런 결과들을 통해 우리는 small world network가 scalable하다는 것을 알 수 있는데 왜냐하면 \(p\)가 0이면 엔트로피의 값은 regular network와 같은 0이지만 \(p\)가 증가함에 따라서 우리가 원하는 entropy를 randomness를 조절함으로써 얻을 수 있기 때문이다. 따라서 이런 Small world network는 scalable하다는 것을 알 수 있다. (일단 수업에서 배운대로 정리를 하기는 했지만 이부분은 너무나도 모호하다. 아무래도 네트워크의 scalable의 definition을 추가로 찾아보고 알아봐야 할 것 같다)</p>


<h5 id="51-7-entropyvsdensity">Entropy vs Density</h5>


<p>k-regular network의 density는 단순하게 \(density = 2 { k \over n }\)으로 계산할 수 있으며, 따라서 우리는 \(k = n {density \over 2}\) 라는 사실을 알 수 있다. 이 값을 통해서 우리는 small world network의 entropy와 density의 관계를 유추할 수 있다. 즉, parameter \(A, B, C\)를 주고 그 값에 대해 \(I_{WS(density)} = A log_2 B(density) - C \) 라는 엔트로피 식을 적을 수 있다. 이 때 \(A, B, C\)를 각각 0.5, 60, 0 이라고 한다면 이 식은 \(I_{WS(density)} = 0.5 log_2 (60(density)) = O(log_2 (density)) = O \left(log_2 \left( \sqrt {k \over n} \right) \right)\) 임을 알 수 있다. 즉, 우리는 entropy가 density에 \(O(\log_2 density)\)의 형태로 표현된다는 것을 알 수 있으며 이 값은 random network의 \(O(density)\)보다 훨씬 덜 가파른 증가율이라는 것을 알 수 있다. 죽, 조금 더 자세히 말하자면 Small world network의 density의 증가률 혹은 rewiring probability의 증가율에 대한 entropy의 증가율은 random network의 그것보다 훨씬 더디게 증가함을 알 수 있다. 이것을 Density에 대해 ploting하게 되면 아래와 같은 결과를 얻게 된다. (일단 3개의 term 중에서 entropy만 보면 된다)</p>


<p><img src="http://SanghyukChun.github.io/images/post/51-5.png" width="600"></p>

<p>다시 한번 정리하자면, small world network에서 density와 entropy는 logarithm relationship을 가진다.</p>


<h5 id="51-8-nmweq">Newman, Moore, and Watts Equation</h5>


<p>먼저 간단한 observation들을 나열해보자. 먼저 rewiring 이 없는 2-regular network는 average path가 \(n \over 4k\)로 표현이 된다. 그리고 바로 전 section에서 본 그림처럼 매우 작은 rewiring probability \(p\)에 대해서 average path length는 매우 빠르게 감소함을 알 수 있다. 그리고 마지막으로 어떤 early point \(p^*\)가 존재해서 이 값보다 작은 rewiring probability를 가진 small world network는 regular에 매우 가깝고 그보다 큰 값을 가지는 네트워크는 random에 더 가깝다. 이 지점을 우리는 crossover, 혹은 transition threshold라고 부르며 이런 현상을 네트워크의 phase transition이라 부른다.</p>


<p>Average path length는 \(p=0\)에서 \(n \over 4k\)의 값을 가지며, \(p\)가 증가함에 따라 감소한다. 이때 \(r=2pm\)이라는 값을 정의하면 \(r\)에 대한 path lenth scaling function을 아래와 같이 표현할 수 있다.</p>


<p>$$ f(r) = 4 {\tanh^{-1} {r \over \beta} \over \beta }; \ where \beta = \sqrt{r^2 + 4 r} $$</p>


<p>또한 average path length는 다음과 같이 표현이 된다.</p>


<p>$$ \bar L_{SW} = n {f(r) \over 2k} = {2n \over \beta k} tanh^{-1} {r \over \beta} $$</p>


<p>만약 \(n=100, m=200, k=2, density=0.04, p=0.04\)라는 조건을 넣고 이 값을 계산하면 average path length는 11.7이라는 값을 얻을 수 있다. 그런데 이 값은 ====</p>


<h5 id="51-9-avgpathlength">Average Path Length</h5>


<p>작성중</p>


<p>$$ log_2 \bar L(r) = \log_2 \left( {n \over 4k} \right) - q \log_2 r $$</p>


<p>$$ \bar L(r) = {n/4k \over r^q }, \ where \ r=pkn $$</p>


<p>즉, 이 값들을 통해 우리는 \(p\)가 0이 아닐 때 (0이면 regular network와 같은 값이 된다) 이 평균 path length는 \(\bar L(r) = {n/4k \over (pkn)^q }\) 로 표현된다는 것을 알 수 있다.</p>


<h5 id="51-10-clusteringcoefficient">Clustering Coefficient</h5>


<p>작성중</p>


<h5 id="51-11-closness">Closeness Centrality</h5>


<p>작성중</p>


<h5 id="51-12-search">Seach in Small World Network</h5>


<p>작성중</p>


<h5 id="51-13-conclusion">Conclusion</h5>


<p>자 이렇게 small world network에 대해 살펴보았다. Small world Network는 Regular Network에 확률 \(p\) 만큼 randomness를 부여해 만들어지는 graph이며, 이 randomness는 scalable하며, random network와 비교했을 때 훨씬 낮은 entropy를 가진다.또한 이런 small world network의 topology는 매우 높은 clustering coefficient와 closeness를 가지게 된다. 또한 그 크기에 비해 상대적으로 짧은 average path와 diameter를 가지게 된다. (그리고 이 특성 자체가 small world effect를 지칭하는 것이기도 하다) 그리고 small world network에서 가장 좋은 search algorithm은 max-degree search 알고리듬이라는 것도 알 수 있었다.</p>


<p>다만, 거의 대부분의 좋은 성질을 가지고 있음에도 불구하고 Small world network 혹은 Watts-Strogatz Model에는 real network와 반하는 특성이 하나 있는데, 바로 degree distribution이다. 일반적인 real network의 degree distribution이 \(P(k) \simeq k^{-\gamma}\)로 표현되는 것에 비해, WS model은 exponetial degree distribution을 가지게 된다. 따라서 이런 문제를 해결하기 위해서 우리는 degree distribution이 power law distribution으로 나타나는 새로운 형태의 network인 scale-free network에 대해 다루게 될 것이다.</p>




<h5>KAIST Network Science</h5>


<p>다른 요약글들 보기 (<a href="http://SanghyukChun.github.io/blog/categories/network-science/">카테고리로 이동</a>)</p>


<ul>
    <li>Lecture 1: <a href="http://SanghyukChun.github.io/47">Introduction</a></li>
    <li>Lecture 2: <a href="http://SanghyukChun.github.io/48">Graph Theory</a></li>
    <li>Lecture 3: <a href="http://SanghyukChun.github.io/49">Measures and Metric</a></li>
    <li>Lecture 4: <a href="http://SanghyukChun.github.io/50">Random Network</a></li>
    <li>Lecture 5: <a href="http://SanghyukChun.github.io/51">Small world Network</a></li>
    <li>Lecture 6: <a href="http://SanghyukChun.github.io/52">Scale free Network</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
